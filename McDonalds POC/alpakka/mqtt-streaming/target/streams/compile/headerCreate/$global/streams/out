[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/javadsl/MqttSession.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Materializer[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.streaming.scaladsl.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  ActorMqttClientSession => ScalaActorMqttClientSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m  ActorMqttServerSession => ScalaActorMqttServerSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttClientSession => ScalaMqttClientSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttServerSession => ScalaMqttServerSession[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents MQTT session state for both clients or servers. Session[0m
[0m[[0m[0mdebug[0m] [0m[0m * state can survive across connections i.e. their lifetime is[0m
[0m[[0m[0mdebug[0m] [0m[0m * generally longer.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Tell the session to perform a command regardless of the state it is[0m
[0m[[0m[0mdebug[0m] [0m[0m   * in. This is important for sending Publish messages in particular,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * as a connection may not have been established with a session.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param cp The command to perform[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of any carry for the command.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def tell[A](cp: Command[A]): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Shutdown the session gracefully[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def shutdown(): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents client-only sessions[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttClientSession extends MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[javadsl] val underlying: ScalaMqttClientSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def tell[A](cp: Command[A]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    underlying ! cp[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shutdown(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    underlying.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ActorMqttClientSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(settings: MqttSessionSettings, mat: Materializer, system: ActorSystem): ActorMqttClientSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ActorMqttClientSession(settings, mat, system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides an actor implementation of a client session[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param settings session settings[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ActorMqttClientSession(settings: MqttSessionSettings, mat: Materializer, system: ActorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends MqttClientSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected[javadsl] val underlying: ScalaActorMqttClientSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaActorMqttClientSession(settings)(mat, system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Used to signal that a client session has ended[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ClientSessionTerminated(clientId: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents server-only sessions[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttServerSession extends MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttServerSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[javadsl] val underlying: ScalaMqttServerSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Used to observe client connections being terminated[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def watchClientSessions: Source[ClientSessionTerminated, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def tell[A](cp: Command[A]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    underlying ! cp[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shutdown(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    underlying.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ActorMqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(settings: MqttSessionSettings, mat: Materializer, system: ActorSystem): ActorMqttServerSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ActorMqttServerSession(settings, mat, system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides an actor implementation of a server session[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param settings session settings[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ActorMqttServerSession(settings: MqttSessionSettings, mat: Materializer, system: ActorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends MqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttServerSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected[javadsl] val underlying: ScalaActorMqttServerSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaActorMqttServerSession(settings)(mat, system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def watchClientSessions: Source[ClientSessionTerminated, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    underlying.watchClientSessions.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ScalaMqttServerSession.ClientSessionTerminated(clientId) => ClientSessionTerminated(clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/javadsl/Mqtt.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.streaming.MqttCodec.DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.BidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{BidiFlow => ScalaBidiFlow}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Mqtt {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains client session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the client session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionId a identifier to distinguish the client connection so that the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                     can route the incoming requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttClientSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, DecodeErrorOrEvent[A], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    inputOutputConverter[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop(scaladsl.Mqtt.clientSessionFlow[A](session.underlying, connectionId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains client session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated Provide a connectionId instead (since 1.0.0)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the client session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Provide a connectionId instead", "1.0.0")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttClientSession[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, DecodeErrorOrEvent[A], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    inputOutputConverter[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop(scaladsl.Mqtt.clientSessionFlow[A](session.underlying, ByteString("0")))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains server session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the server session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionId a identifier to distinguish the client connection so that the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                     can route the incoming requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttServerSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, DecodeErrorOrEvent[A], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    inputOutputConverter[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop(scaladsl.Mqtt.serverSessionFlow[A](session.underlying, connectionId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Converts Java inputs to Scala, and vice-versa.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def inputOutputConverter[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaBidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunctions[Command[A], Command[A], Either[DecodeError, Event[A]], DecodeErrorOrEvent[A]]([0m
[0m[[0m[0mdebug[0m] [0m[0m        identity,[0m
[0m[[0m[0mdebug[0m] [0m[0m        DecodeErrorOrEvent.apply[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/MqttSessionSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSessionSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Factory method for Scala.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSessionSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Factory method for Java.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Configuration settings for client and server usage.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MqttSessionSettings private (val maxPacketSize: Int = 4096,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val clientTerminationWatcherBufferSize: Int = 100,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val commandParallelism: Int = 50,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val eventParallelism: Int = 10,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val receiveConnectTimeout: FiniteDuration = 5.minutes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val receiveConnAckTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val producerPubAckRecTimeout: FiniteDuration = 0.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val producerPubCompTimeout: FiniteDuration = 0.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val consumerPubAckRecTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val consumerPubCompTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val consumerPubRelTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val receiveSubAckTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val receiveUnsubAckTimeout: FiniteDuration = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val serverSendBufferSize: Int = 100) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  require([0m
[0m[[0m[0mdebug[0m] [0m[0m    commandParallelism >= 2,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"commandParallelism of $commandParallelism must be greater than or equal to 2 to support connection replies such as pinging"[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(maxPacketSize >= 0 && maxPacketSize <= (1 << 28),[0m
[0m[[0m[0mdebug[0m] [0m[0m          s"maxPacketSize of $maxPacketSize must be positive and less than ${1 << 28}")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The maximum size of a packet that is allowed to be decoded. Defaults to 4k.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxPacketSize(maxPacketSize: Int): MqttSessionSettings = copy(maxPacketSize = maxPacketSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The number of commands that can be processed at a time, with a default of 50. For client usage, note that each[0m
[0m[[0m[0mdebug[0m] [0m[0m   * CONNECT will reduced the availability of remaining command channels for other commands by 1. For server usage,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * each CONNACK received will reduce the availability of remaining command channels for other commands by 1.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCommandParallelism(commandParallelism: Int): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(commandParallelism = commandParallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This is the number of events that can be received in parallel at any one time, with a default of 10.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withEventParallelism(eventParallelism: Int): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(eventParallelism = eventParallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For servers, the amount of time a session can be disconnected before being re-connected. Defaults to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 5 minutes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveConnectTimeout(receiveConnectTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveConnectTimeout = receiveConnectTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For servers, the amount of time a session can be disconnected before being re-connected. Defaults to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 5 minutes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveConnectTimeout(receiveConnectTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveConnectTimeout = receiveConnectTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a connection. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a connect event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveConnAckTimeout(receiveConnAckTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveConnAckTimeout = receiveConnAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a connection. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a connect event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveConnAckTimeout(receiveConnAckTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveConnAckTimeout = receiveConnAckTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For producers of PUBLISH, the amount of time to wait to ack/receive a QoS 1/2 publish before retrying with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the DUP flag set. Defaults to 0 seconds, which means republishing only occurs on reconnect.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProducerPubAckRecTimeout(producerPubAckRecTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(producerPubAckRecTimeout = producerPubAckRecTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For producers of PUBLISH, the amount of time to wait to ack/receive a QoS 1/2 publish before retrying with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the DUP flag set. Defaults to 0 seconds, which means republishing only occurs on reconnect.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProducerPubAckRecTimeout(producerPubAckRecTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(producerPubAckRecTimeout = producerPubAckRecTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For producers of PUBLISH, the amount of time to wait for a server to complete a QoS 2 publish before retrying[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with another PUBREL. Defaults to 0 seconds, which means republishing only occurs on reconnect.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProducerPubCompTimeout(producerPubCompTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(producerPubCompTimeout = producerPubCompTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For producers of PUBLISH, the amount of time to wait for a server to complete a QoS 2 publish before retrying[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with another PUBREL. Defaults to 0 seconds, which means republishing only occurs on reconnect.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProducerPubCompTimeout(producerPubCompTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(producerPubCompTimeout = producerPubCompTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait before receiving an ack/receive command locally in reply[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to a QoS 1/2 publish event before failing. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubAckRecTimeout(consumerPubAckRecTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubAckRecTimeout = consumerPubAckRecTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait before receiving an ack/receive command locally in reply[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to a QoS 1/2 publish event before failing. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubAckRecTimeout(consumerPubAckRecTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubAckRecTimeout = consumerPubAckRecTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait before receiving a complete command locally in reply to a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * QoS 2 publish event before failing. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubCompTimeout(consumerPubCompTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubCompTimeout = consumerPubCompTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait before receiving a complete command locally in reply to a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * QoS 2 publish event before failing. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubCompTimeout(consumerPubCompTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubCompTimeout = consumerPubCompTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait for a server to release a QoS 2 publish before failing.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubRelTimeout(consumerPubRelTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubRelTimeout = consumerPubRelTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For consumers of PUBLISH, the amount of time to wait for a server to release a QoS 2 publish before failing.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerPubRelTimeout(consumerPubRelTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(consumerPubRelTimeout = consumerPubRelTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a subscribe. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a subscribe event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveSubAckTimeout(receiveSubAckTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveSubAckTimeout = receiveSubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a subscribe. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a subscribe event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveSubAckTimeout(receiveSubAckTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveSubAckTimeout = receiveSubAckTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a unsubscribe. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a unsubscribe event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveUnsubAckTimeout(receiveUnsubAckTimeout: FiniteDuration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveUnsubAckTimeout = receiveUnsubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For clients, the amount of time to wait for a server to ack a unsubscribe. For servers, the amount of time[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to wait before receiving an ack command locally in reply to a unsubscribe event. Defaults to 30 seconds.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReceiveUnsubAckTimeout(receiveUnsubAckTimeout: Duration): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(receiveUnsubAckTimeout = receiveUnsubAckTimeout.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The maximum number of client termination event observers permitted. Defaults to 100 which should be[0m
[0m[[0m[0mdebug[0m] [0m[0m   * more than adequate for most situations.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withClientTerminationWatcherBufferSize(clientTerminationWatcherBufferSize: Int): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(clientTerminationWatcherBufferSize = clientTerminationWatcherBufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Just for servers - the number of commands that can be buffered while connected to a client. Defaults[0m
[0m[[0m[0mdebug[0m] [0m[0m   * to 100. Any commands received beyond this will be dropped.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withServerSendBufferSize(serverSendBufferSize: Int): MqttSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(serverSendBufferSize = serverSendBufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(maxPacketSize: Int = maxPacketSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   clientTerminationWatcherBufferSize: Int = clientTerminationWatcherBufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   commandParallelism: Int = commandParallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   eventParallelism: Int = eventParallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   receiveConnectTimeout: FiniteDuration = receiveConnectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   receiveConnAckTimeout: FiniteDuration = receiveConnAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   producerPubAckRecTimeout: FiniteDuration = producerPubAckRecTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   producerPubCompTimeout: FiniteDuration = producerPubCompTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   consumerPubAckRecTimeout: FiniteDuration = consumerPubAckRecTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   consumerPubCompTimeout: FiniteDuration = consumerPubCompTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   consumerPubRelTimeout: FiniteDuration = consumerPubRelTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   receiveSubAckTimeout: FiniteDuration = receiveSubAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   receiveUnsubAckTimeout: FiniteDuration = receiveUnsubAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   serverSendBufferSize: Int = serverSendBufferSize) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSessionSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      maxPacketSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientTerminationWatcherBufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      commandParallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m      eventParallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m      receiveConnectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      receiveConnAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      producerPubAckRecTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      producerPubCompTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      consumerPubAckRecTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      consumerPubCompTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      consumerPubRelTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      receiveSubAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      receiveUnsubAckTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverSendBufferSize[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"MqttSessionSettings(maxPacketSize=$maxPacketSize,clientTerminationWatcherBufferSize=$clientTerminationWatcherBufferSize,commandParallelism=$commandParallelism,eventParallelism=$eventParallelism,receiveConnectTimeout=$receiveConnectTimeout,receiveConnAckTimeout=$receiveConnAckTimeout,receivePubAckRecTimeout=$producerPubAckRecTimeout,receivePubCompTimeout=$producerPubCompTimeout,receivePubAckRecTimeout=$consumerPubAckRecTimeout,receivePubCompTimeout=$consumerPubCompTimeout,receivePubRelTimeout=$consumerPubRelTimeout,receiveSubAckTimeout=$receiveSubAckTimeout,receiveUnsubAckTimeout=$receiveUnsubAckTimeout,serverSendBufferSize=$serverSendBufferSize)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/scaladsl/MqttSession.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicLong[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed, actor => untyped}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.scaladsl.adapter._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.event.Logging[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.streaming.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{BroadcastHub, Flow, Keep, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] type CommandFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[Command[A], ByteString, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] type EventFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[ByteString, Either[MqttCodec.DecodeError, Event[A]], NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents MQTT session state for both clients or servers. Session[0m
[0m[[0m[0mdebug[0m] [0m[0m * state can survive across connections i.e. their lifetime is[0m
[0m[[0m[0mdebug[0m] [0m[0m * generally longer.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Tell the session to perform a command regardless of the state it is[0m
[0m[[0m[0mdebug[0m] [0m[0m   * in. This is important for sending Publish messages in particular,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * as a connection may not have been established with a session.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param cp The command to perform[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of any carry for the command.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final def tell[A](cp: Command[A]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this ! cp[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Tell the session to perform a command regardless of the state it is[0m
[0m[[0m[0mdebug[0m] [0m[0m   * in. This is important for sending Publish messages in particular,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * as a connection may not have been established with a session.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param cp The command to perform[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of any carry for the command.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ![A](cp: Command[A]): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Shutdown the session gracefully[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def shutdown(): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents client-only sessions[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttClientSession extends MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a flow for commands to be sent to the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] def commandFlow[A](connectionId: ByteString): CommandFlow[A][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a flow for events to be emitted by the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] def eventFlow[A](connectionId: ByteString): EventFlow[A][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ActorMqttClientSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: MqttSessionSettings)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           system: untyped.ActorSystem): ActorMqttClientSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ActorMqttClientSession(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the CONNECT failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ConnectFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the SUBSCRIBE failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object SubscribeFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A PINGREQ failed to receive a PINGRESP - the connection must close[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.1.2.10 Keep Alive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object PingFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[scaladsl] val clientSessionCounter = new AtomicLong[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides an actor implementation of a client session[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param settings session settings[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ActorMqttClientSession(settings: MqttSessionSettings)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  system: untyped.ActorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends MqttClientSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import ActorMqttClientSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val clientSessionId = clientSessionCounter.getAndIncrement()[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val consumerPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(RemotePacketRouter[Consumer.Event], "client-consumer-packet-id-allocator-" + clientSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val producerPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(LocalPacketRouter[Producer.Event], "client-producer-packet-id-allocator-" + clientSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val subscriberPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(LocalPacketRouter[Subscriber.Event], "client-subscriber-packet-id-allocator-" + clientSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val unsubscriberPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(LocalPacketRouter[Unsubscriber.Event], "client-unsubscriber-packet-id-allocator-" + clientSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val clientConnector =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m      ClientConnector(consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m      "client-connector-" + clientSessionId[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttCodec._[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def ![A](cp: Command[A]): Unit = cp match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Command(cp: Publish, _, carry) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientConnector ! ClientConnector.PublishReceivedLocally(cp, carry)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case c: Command[A] => throw new IllegalStateException(c + " is not a client command that can be sent directly")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shutdown(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(clientConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(consumerPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(producerPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(subscriberPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(unsubscriberPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val pingReqBytes = PingReq.encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] override def commandFlow[A](connectionId: ByteString): CommandFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .lazyInitAsync { () =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val killSwitch = KillSwitches.shared("command-kill-switch-" + clientSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        Future.successful([0m
[0m[[0m[0mdebug[0m] [0m[0m          Flow[Command[A]][0m
[0m[[0m[0mdebug[0m] [0m[0m            .watch(clientConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .watchTermination() {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (_, terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                terminated.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Failure(_: WatchedActorTerminatedException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    clientConnector ! ClientConnector.ConnectionLost(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m                NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            .via(killSwitch.flow)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .flatMapMerge([0m
[0m[[0m[0mdebug[0m] [0m[0m              settings.commandParallelism, {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: Connect, _, carry) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Source[ClientConnector.ForwardConnectCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m                  clientConnector ! ClientConnector.ConnectReceivedLocally(connectionId, cp, carry, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFutureSource([0m
[0m[[0m[0mdebug[0m] [0m[0m                    reply.future.map(_.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnector.ForwardConnect => cp.encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnector.ForwardPingReq => pingReqBytes[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnector.ForwardPublish(publish, packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        publish.encode(ByteString.newBuilder, packetId).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnector.ForwardPubRel(packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        PubRel(packetId).encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                    }.mapError {[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case ClientConnector.ConnectFailed => ActorMqttClientSession.ConnectFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case Subscriber.SubscribeFailed => ActorMqttClientSession.SubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case ClientConnector.PingFailed => ActorMqttClientSession.PingFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m                      }[0m
[0m[[0m[0mdebug[0m] [0m[0m                      .watchTermination() { (_, done) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        done.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m                          case Success(_) => killSwitch.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m                          case Failure(t) => killSwitch.abort(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m                        }[0m
[0m[[0m[0mdebug[0m] [0m[0m                      })[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubAck, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubAck.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.Route(None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  Consumer.PubAckReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case e: RemotePacketRouter.CannotRoute =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                      ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubRec, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubRec.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.Route(None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  Consumer.PubRecReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubComp, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubComp.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.Route(None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  Consumer.PubCompReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: Subscribe, _, carry) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Subscriber.ForwardSubscribe][0m
[0m[[0m[0mdebug[0m] [0m[0m                  clientConnector ! ClientConnector.SubscribeReceivedLocally(connectionId, cp, carry, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture([0m
[0m[[0m[0mdebug[0m] [0m[0m                    reply.future.map(command => cp.encode(ByteString.newBuilder, command.packetId).result())[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: Unsubscribe, _, carry) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Unsubscriber.ForwardUnsubscribe][0m
[0m[[0m[0mdebug[0m] [0m[0m                  clientConnector ! ClientConnector.UnsubscribeReceivedLocally(connectionId, cp, carry, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture([0m
[0m[[0m[0mdebug[0m] [0m[0m                    reply.future.map(command => cp.encode(ByteString.newBuilder, command.packetId).result())[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: Disconnect.type, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[ClientConnector.ForwardDisconnect.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  clientConnector ! ClientConnector.DisconnectReceivedLocally(connectionId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result()))[0m
[0m[[0m[0mdebug[0m] [0m[0m                case c: Command[A] => throw new IllegalStateException(c + " is not a client command")[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            .filter(_.nonEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .log("client-commandFlow", _.iterator.decodeControlPacket(settings.maxPacketSize)) // we decode here so we can see the generated packet id[0m
[0m[[0m[0mdebug[0m] [0m[0m            .withAttributes(ActorAttributes.logLevels(onFailure = Logging.DebugLevel))[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] override def eventFlow[A](connectionId: ByteString): EventFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m      .watch(clientConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .watchTermination() {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          terminated.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Failure(_: WatchedActorTerminatedException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnector ! ClientConnector.ConnectionLost(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(new MqttFrameStage(settings.maxPacketSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.iterator.decodeControlPacket(settings.maxPacketSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .log("client-events")[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapAsync[Either[MqttCodec.DecodeError, Event[A]]](settings.eventParallelism) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: ConnAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[ClientConnector.ForwardConnAck][0m
[0m[[0m[0mdebug[0m] [0m[0m          clientConnector ! ClientConnector.ConnAckReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case ClientConnector.ForwardConnAck(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: SubAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Subscriber.ForwardSubAck][0m
[0m[[0m[0mdebug[0m] [0m[0m          subscriberPacketRouter ! LocalPacketRouter.Route(cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                           Subscriber.SubAckReceivedFromRemote(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                           reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Subscriber.ForwardSubAck(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: UnsubAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Unsubscriber.ForwardUnsubAck][0m
[0m[[0m[0mdebug[0m] [0m[0m          unsubscriberPacketRouter ! LocalPacketRouter.Route(cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             Unsubscriber.UnsubAckReceivedFromRemote(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Unsubscriber.ForwardUnsubAck(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: Publish) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Consumer.ForwardPublish.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          clientConnector ! ClientConnector.PublishReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubAck][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubAckReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubAck(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubRec) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubRec][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubRecReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubRec(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubRel) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Consumer.ForwardPubRel.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          consumerPacketRouter ! RemotePacketRouter.Route(None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          Consumer.PubRelReceivedFromRemote(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubComp) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubComp][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubCompReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubComp(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(PingResp) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[ClientConnector.ForwardPingResp.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          clientConnector ! ClientConnector.PingRespReceivedFromRemote(connectionId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(PingResp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp) => Future.failed(new IllegalStateException(cp + " is not a client event"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Left(de) => Future.successful(Left(de))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withAttributes(ActorAttributes.supervisionStrategy {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // Benign exceptions[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: LocalPacketRouter.CannotRoute | _: RemotePacketRouter.CannotRoute =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Supervision.Resume[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Supervision.Stop[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withAttributes(ActorAttributes.logLevels(onFailure = Logging.DebugLevel))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Used to signal that a client session has ended[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ClientSessionTerminated(clientId: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represents server-only sessions[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class MqttServerSession extends MqttSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttServerSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Used to observe client connections being terminated[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def watchClientSessions: Source[ClientSessionTerminated, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a flow for commands to be sent to the session in relation to a connection id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] def commandFlow[A](connectionId: ByteString): CommandFlow[A][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a flow for events to be emitted by the session in relation t a connection id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[streaming] def eventFlow[A](connectionId: ByteString): EventFlow[A][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ActorMqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: MqttSessionSettings)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           system: untyped.ActorSystem): ActorMqttServerSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ActorMqttServerSession(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A PINGREQ was not received within the required keep alive period - the connection must close[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.1.2.10 Keep Alive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object PingFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[scaladsl] val serverSessionCounter = new AtomicLong[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides an actor implementation of a server session[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param settings session settings[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ActorMqttServerSession(settings: MqttSessionSettings)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  system: untyped.ActorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends MqttServerSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttServerSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m  import ActorMqttServerSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val serverSessionId = serverSessionCounter.getAndIncrement()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val (terminations, terminationsSource) = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m    .queue[ServerConnector.ClientSessionTerminated](settings.clientTerminationWatcherBufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                    OverflowStrategy.dropNew)[0m
[0m[[0m[0mdebug[0m] [0m[0m    .toMat(BroadcastHub.sink)(Keep.both)[0m
[0m[[0m[0mdebug[0m] [0m[0m    .run()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def watchClientSessions: Source[ClientSessionTerminated, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    terminationsSource.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ServerConnector.ClientSessionTerminated(clientId) => ClientSessionTerminated(clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val consumerPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(RemotePacketRouter[Consumer.Event], "server-consumer-packet-id-allocator-" + serverSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val producerPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(LocalPacketRouter[Producer.Event], "server-producer-packet-id-allocator-" + serverSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val publisherPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(RemotePacketRouter[Publisher.Event], "server-publisher-packet-id-allocator-" + serverSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val unpublisherPacketRouter =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn(RemotePacketRouter[Unpublisher.Event], "server-unpublisher-packet-id-allocator-" + serverSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val serverConnector =[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m      ServerConnector(terminations,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m      "server-connector-" + serverSessionId[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttCodec._[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttSession._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def ![A](cp: Command[A]): Unit = cp match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Command(cp: Publish, _, carry) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverConnector ! ServerConnector.PublishReceivedLocally(cp, carry)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case c: Command[A] => throw new IllegalStateException(c + " is not a server command that can be sent directly")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shutdown(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(serverConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(consumerPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(producerPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(publisherPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.stop(unpublisherPacketRouter.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m    terminations.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val pingRespBytes = PingResp.encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def commandFlow[A](connectionId: ByteString): CommandFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .lazyInitAsync { () =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val killSwitch = KillSwitches.shared("command-kill-switch-" + serverSessionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        Future.successful([0m
[0m[[0m[0mdebug[0m] [0m[0m          Flow[Command[A]][0m
[0m[[0m[0mdebug[0m] [0m[0m            .watch(serverConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .watchTermination() {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (_, terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                terminated.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Failure(_: WatchedActorTerminatedException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    serverConnector ! ServerConnector.ConnectionLost(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m                NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            .via(killSwitch.flow)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .flatMapMerge([0m
[0m[[0m[0mdebug[0m] [0m[0m              settings.commandParallelism, {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: ConnAck, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Source[ClientConnection.ForwardConnAckCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m                  serverConnector ! ServerConnector.ConnAckReceivedLocally(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFutureSource([0m
[0m[[0m[0mdebug[0m] [0m[0m                    reply.future.map(_.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnection.ForwardConnAck =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        cp.encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnection.ForwardPingResp =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        pingRespBytes[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnection.ForwardPublish(publish, packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        publish.encode(ByteString.newBuilder, packetId).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case ClientConnection.ForwardPubRel(packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        PubRel(packetId).encode(ByteString.newBuilder).result()[0m
[0m[[0m[0mdebug[0m] [0m[0m                    }.mapError {[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case ServerConnector.PingFailed => ActorMqttServerSession.PingFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m                      }[0m
[0m[[0m[0mdebug[0m] [0m[0m                      .watchTermination() { (_, done) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                        done.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m                          case Success(_) => killSwitch.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m                          case Failure(t) => killSwitch.abort(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m                        }[0m
[0m[[0m[0mdebug[0m] [0m[0m                      })[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: SubAck, completed, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Publisher.ForwardSubAck.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  publisherPacketRouter ! RemotePacketRouter.RouteViaConnection(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                Publisher.SubAckReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                  reply.future.onComplete { result =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    completed[0m
[0m[[0m[0mdebug[0m] [0m[0m                      .foreach(_.complete(result.map(_ => Done)))[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source[0m
[0m[[0m[0mdebug[0m] [0m[0m                    .fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result()))[0m
[0m[[0m[0mdebug[0m] [0m[0m                    .recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: UnsubAck, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Unpublisher.ForwardUnsubAck.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  unpublisherPacketRouter ! RemotePacketRouter[0m
[0m[[0m[0mdebug[0m] [0m[0m                    .RouteViaConnection(connectionId, cp.packetId, Unpublisher.UnsubAckReceivedLocally(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubAck, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubAck.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.RouteViaConnection(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               Consumer.PubAckReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                      ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubRec, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubRec.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.RouteViaConnection(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               Consumer.PubRecReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Command(cp: PubComp, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val reply = Promise[Consumer.ForwardPubComp.type][0m
[0m[[0m[0mdebug[0m] [0m[0m                  consumerPacketRouter ! RemotePacketRouter.RouteViaConnection(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               Consumer.PubCompReceivedLocally(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                               reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Source.fromFuture(reply.future.map(_ => cp.encode(ByteString.newBuilder).result())).recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                    case _: RemotePacketRouter.CannotRoute => ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                case c: Command[A] => throw new IllegalStateException(c + " is not a server command")[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            .filter(_.nonEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .log("server-commandFlow", _.iterator.decodeControlPacket(settings.maxPacketSize)) // we decode here so we can see the generated packet id[0m
[0m[[0m[0mdebug[0m] [0m[0m            .withAttributes(ActorAttributes.logLevels(onFailure = Logging.DebugLevel))[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def eventFlow[A](connectionId: ByteString): EventFlow[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m      .watch(serverConnector.toUntyped)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .watchTermination() {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          terminated.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Failure(_: WatchedActorTerminatedException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnector ! ServerConnector.ConnectionLost(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(new MqttFrameStage(settings.maxPacketSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.iterator.decodeControlPacket(settings.maxPacketSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .log("server-events")[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapAsync[Either[MqttCodec.DecodeError, Event[A]]](settings.eventParallelism) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: Connect) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[ClientConnection.ForwardConnect.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.ConnectReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: Subscribe) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Publisher.ForwardSubscribe.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.SubscribeReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: Unsubscribe) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Unpublisher.ForwardUnsubscribe.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.UnsubscribeReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: Publish) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Consumer.ForwardPublish.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.PublishReceivedFromRemote(connectionId, cp, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubAck][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubAckReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubAck(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubRec) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubRec][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubRecReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubRec(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubRel) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Consumer.ForwardPubRel.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          consumerPacketRouter ! RemotePacketRouter.RouteViaConnection(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       cp.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       Consumer.PubRelReceivedFromRemote(reply),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(cp)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp: PubComp) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[Producer.ForwardPubComp][0m
[0m[[0m[0mdebug[0m] [0m[0m          producerPacketRouter ! LocalPacketRouter.Route(cp.packetId, Producer.PubCompReceivedFromRemote(reply), reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Producer.ForwardPubComp(carry: Option[A] @unchecked) => Right(Event(cp, carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(PingReq) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[ClientConnection.ForwardPingReq.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.PingReqReceivedFromRemote(connectionId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(PingReq)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(Disconnect) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val reply = Promise[ClientConnection.ForwardDisconnect.type][0m
[0m[[0m[0mdebug[0m] [0m[0m          serverConnector ! ServerConnector.DisconnectReceivedFromRemote(connectionId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m          reply.future.map(_ => Right(Event(Disconnect)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp) => Future.failed(new IllegalStateException(cp + " is not a server event"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Left(de) => Future.successful(Left(de))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withAttributes(ActorAttributes.supervisionStrategy {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // Benign exceptions[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: LocalPacketRouter.CannotRoute | _: RemotePacketRouter.CannotRoute =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Supervision.Resume[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Supervision.Stop[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withAttributes(ActorAttributes.logLevels(onFailure = Logging.DebugLevel))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/scaladsl/Mqtt.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, BidiShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.BidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Mqtt {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains client session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the MQTT client session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionId a identifier to distinguish the client connection so that the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                     can route the incoming requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttClientSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, Either[MqttCodec.DecodeError, Event[A]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    BidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFlows(session.commandFlow[A](connectionId), session.eventFlow[A](connectionId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop([0m
[0m[[0m[0mdebug[0m] [0m[0m        BidiFlow.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m          new CoupledTerminationBidi[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains client session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the MQTT client session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Provide a connectionId instead", "1.0.0")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttClientSession[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, Either[MqttCodec.DecodeError, Event[A]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    BidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFlows(session.commandFlow[A](ByteString("0")), session.eventFlow[A](ByteString("0")))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop([0m
[0m[[0m[0mdebug[0m] [0m[0m        BidiFlow.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m          new CoupledTerminationBidi[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a bidirectional flow that maintains server session state with an MQTT endpoint.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The bidirectional flow can be joined with an endpoint flow that receives[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[ByteString]] payloads and independently produces [[ByteString]] payloads e.g.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * an MQTT server.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param session the MQTT server session to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionId a identifier to distinguish the client connection so that the session[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                     can route the incoming requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the bidirectional flow[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverSessionFlow[A]([0m
[0m[[0m[0mdebug[0m] [0m[0m      session: MqttServerSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): BidiFlow[Command[A], ByteString, ByteString, Either[MqttCodec.DecodeError, Event[A]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    BidiFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFlows(session.commandFlow[A](connectionId), session.eventFlow[A](connectionId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atop([0m
[0m[[0m[0mdebug[0m] [0m[0m        BidiFlow.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m          new CoupledTerminationBidi[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** INTERNAL API - taken from Akka streams - perhaps it should be made public */[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[scaladsl] class CoupledTerminationBidi[I, O] extends GraphStage[BidiShape[I, I, O, O]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in1: Inlet[I] = Inlet("CoupledCompletion.in1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out1: Outlet[I] = Outlet("CoupledCompletion.out1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in2: Inlet[O] = Inlet("CoupledCompletion.in2")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out2: Outlet[O] = Outlet("CoupledCompletion.out2")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: BidiShape[I, I, O, O] = BidiShape(in1, out1, in2, out2)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val handler1: InHandler with OutHandler = new InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = push(out1, grab(in1))[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in1)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val handler2: InHandler with OutHandler = new InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = push(out2, grab(in2))[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in2)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandlers(in1, out1, handler1)[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandlers(in2, out2, handler2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/impl/MqttFrameStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object MqttFrameStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m  def frames([0m
[0m[[0m[0mdebug[0m] [0m[0m      maxPacketSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bytesReceived: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bytesToEmit: Vector[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Either[IllegalStateException, (immutable.Iterable[ByteString], ByteString)] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import MqttCodec._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val i = bytesReceived.iterator[0m
[0m[[0m[0mdebug[0m] [0m[0m    val _ = i.drop(1) // Length starts at offset 1[0m
[0m[[0m[0mdebug[0m] [0m[0m    i.decodeRemainingLength() match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Right(remainingLength) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val headerSize = bytesReceived.size - i.len[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetSize = remainingLength + headerSize[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (packetSize <= maxPacketSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (bytesReceived.size >= packetSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val (b0, b1) = bytesReceived.splitAt(packetSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m            frames(maxPacketSize, b1, bytesToEmit :+ b0)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            Right((bytesToEmit, bytesReceived))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(new IllegalStateException(s"Max packet size of $maxPacketSize exceeded with $packetSize"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _: Left[BufferUnderflow.type, Int] @unchecked =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right((bytesToEmit, bytesReceived))[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Handles the framing of MQTT streams given that a length byte starts at an offset of 1 and[0m
[0m[[0m[0mdebug[0m] [0m[0m * can then continue to be specified given the setting of a high bit, up to a maximum of[0m
[0m[[0m[0mdebug[0m] [0m[0m * 4 bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2.2.3 Remaining Length[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] final class MqttFrameStage(maxPacketSize: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ByteString, ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttFrameStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[ByteString]("MqttFrame.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[ByteString]("MqttFrame.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: FlowShape[ByteString, ByteString] = FlowShape.of(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        in,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          private var bytesReceived = ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val bytes = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            bytesReceived = bytesReceived ++ bytes[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            frames(maxPacketSize, bytesReceived, Vector.empty) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Right((framed, remaining)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                emitMultiple(out, framed)[0m
[0m[[0m[0mdebug[0m] [0m[0m                bytesReceived = remaining[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (!hasBeenPulled(in)) pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Left(ex) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (!hasBeenPulled(in)) pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/impl/ActorName.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.URLEncoder[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.StandardCharsets[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides the ability to form valid actor names[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi object ActorName {[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val Utf8 = StandardCharsets.UTF_8.name()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def mkName(name: String): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    URLEncoder.encode(name, Utf8)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/impl/ClientState.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.{ActorRef, Behavior, ChildFailed, PostStop, Terminated}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.scaladsl.{ActorContext, Behaviors}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Materializer, OverflowStrategy}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{BroadcastHub, Keep, Source, SourceQueueWithComplete}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Promise[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A client connector is a Finite State Machine that manages MQTT client[0m
[0m[[0m[0mdebug[0m] [0m[0m * session state. A client connects to a server, subscribes/unsubscribes[0m
[0m[[0m[0mdebug[0m] [0m[0m * from topics to receive publications on and publishes to its own topics.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object ClientConnector {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type ConnectData = Option[_][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the CONNECT failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ConnectFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A PINGREQ failed to receive a PINGRESP - the connection must close[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.1.2.10 Keep Alive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object PingFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            subscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Subscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            unsubscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Unsubscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m      Disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val subscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Subscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val unsubscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Unsubscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val subscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Subscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unsubscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Unsubscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectData: ConnectData,[0m
[0m[[0m[0mdebug[0m] [0m[0m      remote: SourceQueueWithComplete[ForwardConnectCommand],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val subscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Subscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unsubscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Unsubscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnAckReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectFlags: ConnectFlags,[0m
[0m[[0m[0mdebug[0m] [0m[0m      keepAlive: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pendingPingResp: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m      remote: SourceQueueWithComplete[ForwardConnectCommand],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val subscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Subscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unsubscriberPacketRouter: ActorRef[LocalPacketRouter.Request[Unsubscriber.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event(val connectionId: ByteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectReceivedLocally(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          connectData: ConnectData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          remote: Promise[Source[ForwardConnectCommand, NotUsed]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnAckReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             connAck: ConnAck,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             local: Promise[ForwardConnAck])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class ReceiveConnAckTimeout(override val connectionId: ByteString) extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class ConnectionLost(override val connectionId: ByteString) extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class DisconnectReceivedLocally(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             remote: Promise[ForwardDisconnect.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class SubscribeReceivedLocally(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            subscribe: Subscribe,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            subscribeData: Subscriber.SubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            remote: Promise[Subscriber.ForwardSubscribe])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             local: Promise[Consumer.ForwardPublish.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConsumerFree(topicName: String) extends Event(ByteString.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedLocally(publish: Publish, publishData: Producer.PublishData)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(ByteString.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ProducerFree(topicName: String) extends Event(ByteString.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class SendPingReqTimeout(override val connectionId: ByteString) extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PingRespReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              local: Promise[ForwardPingResp.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ReceivedProducerPublishingCommand(command: Producer.ForwardPublishingCommand)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(ByteString.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnsubscribeReceivedLocally(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              unsubscribe: Unsubscribe,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              unsubscribeData: Unsubscriber.UnsubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              remote: Promise[Unsubscriber.ForwardUnsubscribe])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class ForwardConnectCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardConnect extends ForwardConnectCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPingReq extends ForwardConnectCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPublish(publish: Publish, packetId: Option[PacketId]) extends ForwardConnectCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubRel(packetId: PacketId) extends ForwardConnectCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardConnAck(connectData: ConnectData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardDisconnect extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPingResp extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val ConsumerNamePrefix = "consumer-"[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val ProducerNamePrefix = "producer-"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnected(data: Disconnected)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (context, ConnectReceivedLocally(connectionId, connect, connectData, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val (queue, source) = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m            .queue[ForwardConnectCommand](1, OverflowStrategy.dropHead)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .toMat(BroadcastHub.sink)(Keep.both)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .run()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          remote.success(source)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          queue.offer(ForwardConnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (connect.connectFlags.contains(ConnectFlags.CleanSession)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.children.foreach(context.stop)[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                connectData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                queue,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.activeProducers.values.foreach { producer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              producer ! Producer.ReceiveConnect[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                connectData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                queue,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, ConnectionLost(_)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behavior.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          disconnected(data.copy(stash = data.stash :+ e))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(context: ActorContext[Event], remote: SourceQueueWithComplete[ForwardConnectCommand], data: Data)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit mat: Materializer[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Behavior[Event] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m      Disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverConnect(data: ConnectReceived)(implicit mat: Materializer): Behavior[Event] = Behaviors.withTimers {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceiveConnAck = "receive-connack"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!timer.isTimerActive(ReceiveConnAck))[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceiveConnAck,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               ReceiveConnAckTimeout(data.connectionId),[0m
[0m[[0m[0mdebug[0m] [0m[0m                               data.settings.receiveConnAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, connect @ ConnectReceivedLocally(connectionId, _, _, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if connectionId != data.connectionId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.self ! connect[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, event) if event.connectionId.nonEmpty && event.connectionId != data.connectionId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnAckReceivedFromRemote(_, connAck, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if connAck.returnCode.contains(ConnAckReturnCode.ConnectionAccepted) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardConnAck(data.connectData))[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnAckReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.connect.connectFlags,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.connect.keepAlive,[0m
[0m[[0m[0mdebug[0m] [0m[0m                pendingPingResp = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.remote,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.subscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unsubscriberPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnAckReceivedFromRemote(_, _, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardConnAck(data.connectData))[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ReceiveConnAckTimeout(_)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.fail(ConnectFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnectionLost(_)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnect(data.copy(stash = data.stash :+ e))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverConnected(data: ConnAckReceived,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      resetPingReqTimer: Boolean = true)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val SendPingreq = "send-pingreq"[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (resetPingReqTimer && data.keepAlive.toMillis > 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(SendPingreq, SendPingReqTimeout(data.connectionId), data.keepAlive)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, connect @ ConnectReceivedLocally(connectionId, _, _, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if connectionId != data.connectionId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.self ! connect[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, event) if event.connectionId.nonEmpty && event.connectionId != data.connectionId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnectionLost(_)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(SendPingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, DisconnectReceivedLocally(_, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote.success(ForwardDisconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(SendPingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, SubscribeReceivedLocally(_, _, subscribeData, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.watch([0m
[0m[[0m[0mdebug[0m] [0m[0m              context.spawnAnonymous(Subscriber(subscribeData, remote, data.subscriberPacketRouter, data.settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, UnsubscribeReceivedLocally(_, _, unsubscribeData, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.watch([0m
[0m[[0m[0mdebug[0m] [0m[0m              context[0m
[0m[[0m[0mdebug[0m] [0m[0m                .spawnAnonymous(Unsubscriber(unsubscribeData, remote, data.unsubscriberPacketRouter, data.settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedFromRemote(_, publish, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (publish.flags & ControlPacketFlags.QoSReserved).underlying == 0 =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(Consumer.ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data, resetPingReqTimer = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context,[0m
[0m[[0m[0mdebug[0m] [0m[0m                prfr @ PublishReceivedFromRemote(_, publish @ Publish(_, topicName, Some(packetId), _), local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.activeConsumers.get(topicName) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val consumerName = ActorName.mkName(ConsumerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m                val consumer =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  context.spawn(Consumer(publish, None, packetId, local, data.consumerPacketRouter, data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                consumerName)[0m
[0m[[0m[0mdebug[0m] [0m[0m                context.watchWith(consumer, ConsumerFree(publish.topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m                serverConnected(data.copy(activeConsumers = data.activeConsumers + (publish.topicName -> consumer)),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                resetPingReqTimer = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Some(consumer) if publish.flags.contains(ControlPacketFlags.DUP) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer ! Consumer.DupPublishReceivedFromRemote(local)[0m
[0m[[0m[0mdebug[0m] [0m[0m                serverConnected(data, resetPingReqTimer = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Some(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                serverConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.copy(pendingRemotePublications = data.pendingRemotePublications :+ (publish.topicName -> prfr)),[0m
[0m[[0m[0mdebug[0m] [0m[0m                  resetPingReqTimer = false[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConsumerFree(topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val i = data.pendingRemotePublications.indexWhere(_._1 == topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (i >= 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val prfr = data.pendingRemotePublications(i)._2[0m
[0m[[0m[0mdebug[0m] [0m[0m              val consumerName = ActorName.mkName(ConsumerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val consumer = context.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m                Consumer(prfr.publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         prfr.publish.packetId.get,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         prfr.local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumerName[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ConsumerFree(topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m                  activeConsumers = data.activeConsumers + (topicName -> consumer),[0m
[0m[[0m[0mdebug[0m] [0m[0m                  pendingRemotePublications =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.pendingRemotePublications.take(i) ++ data.pendingRemotePublications.drop(i + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected(data.copy(activeConsumers = data.activeConsumers - topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedLocally(publish, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (publish.flags & ControlPacketFlags.QoSReserved).underlying == 0 =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPublish(publish, None))[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, prl @ PublishReceivedLocally(publish, publishData)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val producerName = ActorName.mkName(ProducerNamePrefix + publish.topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (!data.activeProducers.contains(publish.topicName)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val reply = Promise[Source[Producer.ForwardPublishingCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              Source[0m
[0m[[0m[0mdebug[0m] [0m[0m                .fromFutureSource(reply.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m                .runForeach(msg => context.self ! ReceivedProducerPublishingCommand(msg))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producer =[0m
[0m[[0m[0mdebug[0m] [0m[0m                context.spawn(Producer(publish, publishData, reply, data.producerPacketRouter, data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                              producerName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                producer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ProducerFree(publish.topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected(data.copy(activeProducers = data.activeProducers + (publish.topicName -> producer)))[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy(pendingLocalPublications = data.pendingLocalPublications :+ (publish.topicName -> prl))[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ProducerFree(topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val i = data.pendingLocalPublications.indexWhere(_._1 == topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (i >= 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val prl = data.pendingLocalPublications(i)._2[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producerName = ActorName.mkName(ProducerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val reply = Promise[Source[Producer.ForwardPublishingCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              Source[0m
[0m[[0m[0mdebug[0m] [0m[0m                .fromFutureSource(reply.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m                .runForeach(msg => context.self ! ReceivedProducerPublishingCommand(msg))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producer = context.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m                Producer(prl.publish, prl.publishData, reply, data.producerPacketRouter, data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                producerName[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                producer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ProducerFree(topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m                  activeProducers = data.activeProducers + (topicName -> producer),[0m
[0m[[0m[0mdebug[0m] [0m[0m                  pendingLocalPublications =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.pendingLocalPublications.take(i) ++ data.pendingLocalPublications.drop(i + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              serverConnected(data.copy(activeProducers = data.activeProducers - topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ReceivedProducerPublishingCommand(Producer.ForwardPublish(publish, packetId))) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPublish(publish, packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ReceivedProducerPublishingCommand(Producer.ForwardPubRel(_, packetId))) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPubRel(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, SendPingReqTimeout(_)) if data.pendingPingResp =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.fail(PingFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(SendPingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, SendPingReqTimeout(_)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPingReq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data.copy(pendingPingResp = true))[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PingRespReceivedFromRemote(_, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardPingResp)[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data.copy(pendingPingResp = false))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ChildFailed(_, failure)) if failure == Subscriber.SubscribeFailed =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.fail(Subscriber.SubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ChildFailed(_, failure)) if failure == Unsubscriber.UnsubscribeFailed =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.fail(Unsubscriber.UnsubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            serverConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A subscriber manages the client state in relation to having made a[0m
[0m[[0m[0mdebug[0m] [0m[0m * subscription to a server-side topic. A subscriber is created[0m
[0m[[0m[0mdebug[0m] [0m[0m * per server per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Subscriber {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type SubscribeData = Option[_][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the subscription failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object SubscribeFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(subscribeData: SubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote: Promise[ForwardSubscribe],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    prepareServerSubscribe(Start(subscribeData, remote, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(subscribeData: SubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         remote: Promise[ForwardSubscribe],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ServerSubscribe(packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   subscribeData: SubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class AcquiredPacketId(packetId: PacketId) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnobtainablePacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class SubAckReceivedFromRemote(local: Promise[ForwardSubAck]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveSubAckTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardSubscribe(packetId: PacketId) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardSubAck(connectData: SubscribeData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def prepareServerSubscribe(data: Start): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val reply = Promise[LocalPacketRouter.Registered][0m
[0m[[0m[0mdebug[0m] [0m[0m    data.packetRouter ! LocalPacketRouter.Register(context.self, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m    import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(registered: LocalPacketRouter.Registered) => context.self ! AcquiredPacketId(registered.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(_) => context.self ! UnobtainablePacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case AcquiredPacketId(packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.remote.success(ForwardSubscribe(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m        serverSubscribe([0m
[0m[[0m[0mdebug[0m] [0m[0m          ServerSubscribe(packetId, data.subscribeData, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnobtainablePacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.remote.failure(SubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw SubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverSubscribe(data: ServerSubscribe): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceiveSuback = "client-receive-suback"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceiveSuback, ReceiveSubAckTimeout, data.settings.receiveSubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case SubAckReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardSubAck(data.subscribeData))[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceiveSubAckTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw SubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! LocalPacketRouter.Unregister(data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A unsubscriber manages the client state in relation to unsubscribing from a[0m
[0m[[0m[0mdebug[0m] [0m[0m * server-side topic. A unsubscriber is created per server per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Unsubscriber {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the unsubscription failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object UnsubscribeFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type UnsubscribeData = Option[_][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(unsubscribeData: UnsubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote: Promise[ForwardUnsubscribe],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    prepareServerUnsubscribe(Start(unsubscribeData, remote, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(unsubscribeData: UnsubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         remote: Promise[ForwardUnsubscribe],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ServerUnsubscribe(packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     unsubscribeData: UnsubscribeData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class AcquiredPacketId(packetId: PacketId) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnobtainablePacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnsubAckReceivedFromRemote(local: Promise[ForwardUnsubAck]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveUnsubAckTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardUnsubscribe(packetId: PacketId) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardUnsubAck(connectData: UnsubscribeData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def prepareServerUnsubscribe(data: Start): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val reply = Promise[LocalPacketRouter.Registered][0m
[0m[[0m[0mdebug[0m] [0m[0m    data.packetRouter ! LocalPacketRouter.Register(context.self, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m    import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(registered: LocalPacketRouter.Registered) => context.self ! AcquiredPacketId(registered.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(_) => context.self ! UnobtainablePacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case AcquiredPacketId(packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.remote.success(ForwardUnsubscribe(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m        serverUnsubscribe([0m
[0m[[0m[0mdebug[0m] [0m[0m          ServerUnsubscribe(packetId, data.unsubscribeData, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnobtainablePacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.remote.failure(UnsubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw UnsubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverUnsubscribe(data: ServerUnsubscribe): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceiveUnsubAck = "client-receive-unsubAck"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceiveUnsubAck, ReceiveUnsubAckTimeout, data.settings.receiveUnsubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case UnsubAckReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardUnsubAck(data.unsubscribeData))[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceiveUnsubAckTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw UnsubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! LocalPacketRouter.Unregister(data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/impl/ServerState.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.scaladsl.{ActorContext, Behaviors}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.{ActorRef, Behavior, ChildFailed, PostStop, Terminated}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.streaming.impl.ServerConnector.PingFailed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Materializer, OverflowStrategy}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{BroadcastHub, Keep, Source, SourceQueueWithComplete}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Promise[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A server connector is a Finite State Machine that manages MQTT client[0m
[0m[[0m[0mdebug[0m] [0m[0m * connections. A server receives connections from a client and[0m
[0m[[0m[0mdebug[0m] [0m[0m * manages their subscriptions along with receiving publications[0m
[0m[[0m[0mdebug[0m] [0m[0m * publishing them to subscribed topics.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object ServerConnector {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A PINGREQ was not received within the required keep alive period - the connection must close[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.1.2.10 Keep Alive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object PingFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Used to signal that a client connection has terminated[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ClientSessionTerminated(clientId: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(terminations: SourceQueueWithComplete[ClientSessionTerminated],[0m
[0m[[0m[0mdebug[0m] [0m[0m            consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    listening([0m
[0m[[0m[0mdebug[0m] [0m[0m      Data(Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m           terminations,[0m
[0m[[0m[0mdebug[0m] [0m[0m           consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m           producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m           publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m           unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m           settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Data(clientConnections: Map[ByteString, (String, ActorRef[ClientConnection.Event])],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        terminations: SourceQueueWithComplete[ClientSessionTerminated],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event(val connectionId: ByteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             local: Promise[ClientConnection.ForwardConnect.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ReceiveConnAckTimeout(override val connectionId: ByteString) extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnAckReceivedLocally(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          connAck: ConnAck,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          remote: Promise[Source[ClientConnection.ForwardConnAckCommand, NotUsed]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class SubscribeReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                               subscribe: Subscribe,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                               local: Promise[Publisher.ForwardSubscribe.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             local: Promise[Consumer.ForwardPublish.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedLocally(publish: Publish, publishData: Producer.PublishData)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(ByteString.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnsubscribeReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 unsubscribe: Unsubscribe,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 local: Promise[Unpublisher.ForwardUnsubscribe.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PingReqReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                             local: Promise[ClientConnection.ForwardPingReq.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class DisconnectReceivedFromRemote(override val connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                local: Promise[ClientConnection.ForwardDisconnect.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectionLost(override val connectionId: ByteString) extends Event(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val ClientConnectionNamePrefix = "client-connection-"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def forward(connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      clientConnections: Map[ByteString, (String, ActorRef[ClientConnection.Event])],[0m
[0m[[0m[0mdebug[0m] [0m[0m                      e: ClientConnection.Event): Behavior[Event] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    clientConnections.get(connectionId).foreach { case (_, cc) => cc ! e }[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listening(data: Data)(implicit mat: Materializer): Behavior[Event] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def childTerminated(terminatedCc: ActorRef[ClientConnection.Event]): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      data.clientConnections.find { case (_, (_, cc)) => cc == terminatedCc } match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Some((connectionId, (clientId, _))) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.terminations.offer(ClientSessionTerminated(clientId))[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.consumerPacketRouter ! RemotePacketRouter.UnregisterConnection(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.publisherPacketRouter ! RemotePacketRouter.UnregisterConnection(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.unpublisherPacketRouter ! RemotePacketRouter.UnregisterConnection(connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          listening(data.copy(clientConnections = data.clientConnections - connectionId))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (context, ConnectReceivedFromRemote(connectionId, connect, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val clientConnectionName = ActorName.mkName(ClientConnectionNamePrefix + connect.clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          val clientConnection = context.child(clientConnectionName) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m                ClientConnection(connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                clientConnectionName[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(ref) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val cc = ref.unsafeUpcast[ClientConnection.Event][0m
[0m[[0m[0mdebug[0m] [0m[0m              cc ! ClientConnection.ConnectReceivedFromRemote(connect, local)[0m
[0m[[0m[0mdebug[0m] [0m[0m              cc[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          context.watch(clientConnection)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.consumerPacketRouter ! RemotePacketRouter.RegisterConnection(connectionId, connect.clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.publisherPacketRouter ! RemotePacketRouter.RegisterConnection(connectionId, connect.clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.unpublisherPacketRouter ! RemotePacketRouter.RegisterConnection(connectionId, connect.clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          val newConnection = (connectionId, (connect.clientId, clientConnection))[0m
[0m[[0m[0mdebug[0m] [0m[0m          listening([0m
[0m[[0m[0mdebug[0m] [0m[0m            data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnections = data.clientConnections[0m
[0m[[0m[0mdebug[0m] [0m[0m                .filterNot { case (_, (clientId, _)) => clientId == connect.clientId } + newConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, ConnAckReceivedLocally(connectionId, connAck, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.ConnAckReceivedLocally(connAck, remote))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, SubscribeReceivedFromRemote(connectionId, subscribe, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.SubscribeReceivedFromRemote(subscribe, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PublishReceivedFromRemote(connectionId, publish, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.PublishReceivedFromRemote(publish, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PublishReceivedLocally(publish, publishData)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.clientConnections.values.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (_, cc) => cc ! ClientConnection.PublishReceivedLocally(publish, publishData)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, UnsubscribeReceivedFromRemote(connectionId, unsubscribe, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.clientConnections,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  ClientConnection.UnsubscribeReceivedFromRemote(unsubscribe, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PingReqReceivedFromRemote(connectionId, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.PingReqReceivedFromRemote(local))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, DisconnectReceivedFromRemote(connectionId, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.DisconnectReceivedFromRemote(local))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, ConnectionLost(connectionId)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          forward(connectionId, data.clientConnections, ClientConnection.ConnectionLost)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, Terminated(ref)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          childTerminated(ref.unsafeUpcast[ClientConnection.Event])[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, ChildFailed(ref, failure)) if failure == ClientConnection.ClientConnectionFailed =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          childTerminated(ref.unsafeUpcast[ClientConnection.Event])[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Handles events in relation to a specific client connection[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object ClientConnection {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the connection failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ClientConnectionFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A PINGREQ was not received within 1.5 times the keep alive so the connection will close[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.1.2.10 Keep Alive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object PingFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m            local: Promise[ForwardConnect.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m            consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    clientConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m      ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m        connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m        local,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val publishers: Set[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m      connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m      local: Promise[ForwardConnect.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publishers: Set[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnAckReplied([0m
[0m[[0m[0mdebug[0m] [0m[0m      connect: Connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m      remote: SourceQueueWithComplete[ForwardConnAckCommand],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publishers: Set[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m      override val stash: Seq[Event],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publishers: Set[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeConsumers: Map[String, ActorRef[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val activeProducers: Map[String, ActorRef[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingLocalPublications: Seq[(String, PublishReceivedLocally)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val pendingRemotePublications: Seq[(String, PublishReceivedFromRemote)],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val consumerPacketRouter: ActorRef[RemotePacketRouter.Request[Consumer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val producerPacketRouter: ActorRef[LocalPacketRouter.Request[Producer.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val publisherPacketRouter: ActorRef[RemotePacketRouter.Request[Publisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val unpublisherPacketRouter: ActorRef[RemotePacketRouter.Request[Unpublisher.Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val settings: MqttSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Data([0m
[0m[[0m[0mdebug[0m] [0m[0m        stash,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveConnAckTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnAckReceivedLocally(connAck: ConnAck, remote: Promise[Source[ForwardConnAckCommand, NotUsed]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class SubscribeReceivedFromRemote(subscribe: Subscribe, local: Promise[Publisher.ForwardSubscribe.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Subscribed(subscribe: Subscribe, remote: Promise[Publisher.ForwardSubAck.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedFromRemote(publish: Publish, local: Promise[Consumer.ForwardPublish.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConsumerFree(topicName: String) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PublishReceivedLocally(publish: Publish, publishData: Producer.PublishData) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ProducerFree(topicName: String) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnsubscribeReceivedFromRemote(unsubscribe: Unsubscribe,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 local: Promise[Unpublisher.ForwardUnsubscribe.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Unsubscribed(unsubscribe: Unsubscribe) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PingReqReceivedFromRemote(local: Promise[ForwardPingReq.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class DisconnectReceivedFromRemote(local: Promise[ForwardDisconnect.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ConnectionLost extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePingReqTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ReceivedProducerPublishingCommand(command: Producer.ForwardPublishingCommand) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ConnectReceivedFromRemote(connect: Connect, local: Promise[ClientConnection.ForwardConnect.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveConnectTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardConnect extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class ForwardConnAckCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardConnAck extends ForwardConnAckCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPingReq extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPingResp extends ForwardConnAckCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardDisconnect extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPublish(publish: Publish, packetId: Option[PacketId]) extends ForwardConnAckCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubRel(packetId: PacketId) extends ForwardConnAckCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val ConsumerNamePrefix = "consumer-"[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val ProducerNamePrefix = "producer-"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientConnect(data: ConnectReceived)(implicit mat: Materializer): Behavior[Event] = Behaviors.setup { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.local.trySuccess(ForwardConnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ReceiveConnAck = "receive-connack"[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!timer.isTimerActive(ReceiveConnAck))[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceiveConnAck, ReceiveConnAckTimeout, data.settings.receiveConnAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnAckReceivedLocally(_, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val (queue, source) = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m              .queue[ForwardConnAckCommand](data.settings.serverSendBufferSize, OverflowStrategy.dropNew)[0m
[0m[[0m[0mdebug[0m] [0m[0m              .toMat(BroadcastHub.sink)(Keep.both)[0m
[0m[[0m[0mdebug[0m] [0m[0m              .run()[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote.success(source)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            queue.offer(ForwardConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.activeProducers.values[0m
[0m[[0m[0mdebug[0m] [0m[0m              .foreach(_ ! Producer.ReceiveConnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnAckReplied([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                queue,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ReceiveConnAckTimeout) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            throw ClientConnectionFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ClientConnection.ConnectionLost) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            throw ClientConnectionFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedLocally(publish, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if !data.publishers.exists(Topics.filter(_, publish.topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnect(data.copy(stash = data.stash :+ e))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(context: ActorContext[Event], remote: SourceQueueWithComplete[ForwardConnAckCommand], data: Data)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit mat: Materializer[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Behavior[Event] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    clientDisconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m      Disconnected([0m
[0m[[0m[0mdebug[0m] [0m[0m        Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientConnected(data: ConnAckReplied)(implicit mat: Materializer): Behavior[Event] = Behaviors.withTimers {[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ReceivePingreq = "receive-pingreq"[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (data.connect.keepAlive.toMillis > 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceivePingreq,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               ReceivePingReqTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               FiniteDuration((data.connect.keepAlive.toMillis * 1.5).toLong, TimeUnit.MILLISECONDS))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, SubscribeReceivedFromRemote(subscribe, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val subscribed = Promise[Promise[Publisher.ForwardSubAck.type]][0m
[0m[[0m[0mdebug[0m] [0m[0m            context.watch([0m
[0m[[0m[0mdebug[0m] [0m[0m              context.spawnAnonymous([0m
[0m[[0m[0mdebug[0m] [0m[0m                Publisher(data.connect.clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          subscribe.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          subscribed,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            subscribed.future.foreach(remote => context.self ! Subscribed(subscribe, remote))(context.executionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, Subscribed(subscribe, remote)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote.success(Publisher.ForwardSubAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m              data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m                publishers = data.publishers ++ subscribe.topicFilters.map(_._1)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, UnsubscribeReceivedFromRemote(unsubscribe, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val unsubscribed = Promise[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m            context.watch([0m
[0m[[0m[0mdebug[0m] [0m[0m              context.spawnAnonymous([0m
[0m[[0m[0mdebug[0m] [0m[0m                Unpublisher(data.connect.clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            unsubscribe.packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            unsubscribed,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            unsubscribed.future.foreach(_ => context.self ! Unsubscribed(unsubscribe))(context.executionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, Unsubscribed(unsubscribe)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data.copy(publishers = data.publishers -- unsubscribe.topicFilters))[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedFromRemote(publish, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (publish.flags & ControlPacketFlags.QoSReserved).underlying == 0 =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(Consumer.ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, prfr @ PublishReceivedFromRemote(publish @ Publish(_, topicName, Some(packetId), _), local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.activeConsumers.get(topicName) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val consumerName = ActorName.mkName(ConsumerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m                val consumer =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  context.spawn(Consumer(publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         Some(data.connect.clientId),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         packetId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                consumerName)[0m
[0m[[0m[0mdebug[0m] [0m[0m                context.watchWith(consumer, ConsumerFree(publish.topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m                clientConnected(data.copy(activeConsumers = data.activeConsumers + (publish.topicName -> consumer)))[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Some(consumer) if publish.flags.contains(ControlPacketFlags.DUP) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer ! Consumer.DupPublishReceivedFromRemote(local)[0m
[0m[[0m[0mdebug[0m] [0m[0m                clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Some(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.copy(pendingRemotePublications = data.pendingRemotePublications :+ (publish.topicName -> prfr))[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConsumerFree(topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val i = data.pendingRemotePublications.indexWhere(_._1 == topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (i >= 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val prfr = data.pendingRemotePublications(i)._2[0m
[0m[[0m[0mdebug[0m] [0m[0m              val consumerName = ActorName.mkName(ConsumerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val consumer = context.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m                Consumer(prfr.publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         Some(data.connect.clientId),[0m
[0m[[0m[0mdebug[0m] [0m[0m                         prfr.publish.packetId.get,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         prfr.local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumerName[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ConsumerFree(topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m                  activeConsumers = data.activeConsumers + (topicName -> consumer),[0m
[0m[[0m[0mdebug[0m] [0m[0m                  pendingRemotePublications =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.pendingRemotePublications.take(i) ++ data.pendingRemotePublications.drop(i + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected(data.copy(activeConsumers = data.activeConsumers - topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedLocally(publish, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (publish.flags & ControlPacketFlags.QoSReserved).underlying == 0 &&[0m
[0m[[0m[0mdebug[0m] [0m[0m              data.publishers.exists(Topics.filter(_, publish.topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPublish(publish, None))[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, prl @ PublishReceivedLocally(publish, publishData))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if data.publishers.exists(Topics.filter(_, publish.topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val producerName = ActorName.mkName(ProducerNamePrefix + publish.topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (!data.activeProducers.contains(publish.topicName)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val reply = Promise[Source[Producer.ForwardPublishingCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m              import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m              reply.future.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m                _.runForeach(command => context.self ! ReceivedProducerPublishingCommand(command))[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producer =[0m
[0m[[0m[0mdebug[0m] [0m[0m                context.spawn(Producer(publish, publishData, reply, data.producerPacketRouter, data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                              producerName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                producer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ProducerFree(publish.topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected(data.copy(activeProducers = data.activeProducers + (publish.topicName -> producer)))[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy(pendingLocalPublications = data.pendingLocalPublications :+ (publish.topicName -> prl))[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ProducerFree(topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val i = data.pendingLocalPublications.indexWhere(_._1 == topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (i >= 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val prl = data.pendingLocalPublications(i)._2[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producerName = ActorName.mkName(ProducerNamePrefix + topicName + "-" + context.children.size)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val reply = Promise[Source[Producer.ForwardPublishingCommand, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m              import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m              reply.future.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m                _.runForeach(command => context.self ! ReceivedProducerPublishingCommand(command))[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              val producer = context.spawn([0m
[0m[[0m[0mdebug[0m] [0m[0m                Producer(prl.publish, prl.publishData, reply, data.producerPacketRouter, data.settings),[0m
[0m[[0m[0mdebug[0m] [0m[0m                producerName[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              context.watchWith([0m
[0m[[0m[0mdebug[0m] [0m[0m                producer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                ProducerFree(topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected([0m
[0m[[0m[0mdebug[0m] [0m[0m                data.copy([0m
[0m[[0m[0mdebug[0m] [0m[0m                  activeProducers = data.activeProducers + (topicName -> producer),[0m
[0m[[0m[0mdebug[0m] [0m[0m                  pendingLocalPublications =[0m
[0m[[0m[0mdebug[0m] [0m[0m                  data.pendingLocalPublications.take(i) ++ data.pendingLocalPublications.drop(i + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m                )[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              clientConnected(data.copy(activeProducers = data.activeProducers - topicName))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ReceivedProducerPublishingCommand(command)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            command match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Producer.ForwardPublish(publish, packetId) => data.remote.offer(ForwardPublish(publish, packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Producer.ForwardPubRel(_, packetId) => data.remote.offer(ForwardPubRel(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PingReqReceivedFromRemote(local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPingResp)[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardPingReq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnected(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ReceivePingReqTimeout) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.fail(ServerConnector.PingFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, DisconnectReceivedFromRemote(local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardDisconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ClientConnection.ConnectionLost) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnectReceivedFromRemote(connect, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if connect.connectFlags.contains(ConnectFlags.CleanSession) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.children.foreach(context.stop)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ConnectReceivedFromRemote(connect, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePingreq)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ChildFailed(_, failure))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if failure == Publisher.SubscribeFailed || failure == Unpublisher.UnsubscribeFailed =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            disconnect(context, data.remote, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clientDisconnected(data: Disconnected)(implicit mat: Materializer): Behavior[Event] = Behaviors.withTimers {[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ReceiveConnect = "receive-connect"[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!timer.isTimerActive(ReceiveConnect))[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceiveConnect, ReceiveConnectTimeout, data.settings.receiveConnectTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receivePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnectReceivedFromRemote(connect, local))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if connect.connectFlags.contains(ConnectFlags.CleanSession) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            context.children.foreach(context.stop)[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (context, ConnectReceivedFromRemote(connect, local)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceiveConnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.stash.foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientConnect([0m
[0m[[0m[0mdebug[0m] [0m[0m              ConnectReceived([0m
[0m[[0m[0mdebug[0m] [0m[0m                connect,[0m
[0m[[0m[0mdebug[0m] [0m[0m                local,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Vector.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publishers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeConsumers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.activeProducers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingLocalPublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.pendingRemotePublications,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.consumerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.producerPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.publisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.unpublisherPacketRouter,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data.settings[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ReceiveConnectTimeout) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            throw ClientConnectionFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, ConnectionLost) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behavior.same // We know... we are disconnected...[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PublishReceivedLocally(publish, _))[0m
[0m[[0m[0mdebug[0m] [0m[0m              if !data.publishers.exists(Topics.filter(_, publish.topicName)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientDisconnected(data.copy(stash = data.stash :+ e))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, _: Terminated) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A publisher manages the client state in relation to having received a[0m
[0m[[0m[0mdebug[0m] [0m[0m * subscription to a server-side topic. A publisher is created[0m
[0m[[0m[0mdebug[0m] [0m[0m * per client per topic filter.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Publisher {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the subscription failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object SubscribeFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m            local: Promise[ForwardSubscribe.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m            subscribed: Promise[Promise[ForwardSubAck.type]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    preparePublisher(Start(Some(clientId), packetId, local, subscribed, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val subscribed: Promise[Promise[ForwardSubAck.type]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(override val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         local: Promise[ForwardSubscribe.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val subscribed: Promise[Promise[ForwardSubAck.type]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(clientId, packetId, subscribed, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ServerSubscribe(override val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val subscribed: Promise[Promise[ForwardSubAck.type]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(clientId, packetId, subscribed, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object RegisteredPacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnobtainablePacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class SubAckReceivedLocally(remote: Promise[ForwardSubAck.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveSubAckTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardSubscribe extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardSubAck extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def preparePublisher(data: Start): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val reply = Promise[RemotePacketRouter.Registered.type][0m
[0m[[0m[0mdebug[0m] [0m[0m    data.packetRouter ! RemotePacketRouter.Register(context.self.unsafeUpcast, data.clientId, data.packetId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m    import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(RemotePacketRouter.Registered) => context.self ! RegisteredPacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(_) => context.self ! UnobtainablePacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case RegisteredPacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.success(ForwardSubscribe)[0m
[0m[[0m[0mdebug[0m] [0m[0m        serverSubscribe([0m
[0m[[0m[0mdebug[0m] [0m[0m          ServerSubscribe(data.clientId, data.packetId, data.subscribed, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnobtainablePacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.failure(SubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.subscribed.failure(SubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw SubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverSubscribe(data: ServerSubscribe): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceiveSuback = "server-receive-suback"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceiveSuback, ReceiveSubAckTimeout, data.settings.receiveSubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case SubAckReceivedLocally(remote) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.subscribed.success(remote)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceiveSubAckTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.subscribed.failure(SubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw SubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! RemotePacketRouter.Unregister(data.clientId, data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A unpublisher manages the client state in relation to unsubscribing from a[0m
[0m[[0m[0mdebug[0m] [0m[0m * server-side topic. A unpublisher is created per server per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Unpublisher {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the unsubscription failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object UnsubscribeFailed extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m            local: Promise[ForwardUnsubscribe.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m            unsubscribed: Promise[Done],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    prepareServerUnpublisher(Start(Some(clientId), packetId, local, unsubscribed, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val unsubscribed: Promise[Done],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(override val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         local: Promise[ForwardUnsubscribe.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val unsubscribed: Promise[Done],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(clientId, packetId, unsubscribed, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ServerUnsubscribe(override val clientId: Some[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     override val unsubscribed: Promise[Done],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(clientId, packetId, unsubscribed, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object RegisteredPacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnobtainablePacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnsubAckReceivedLocally(remote: Promise[ForwardUnsubAck.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveUnsubAckTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardUnsubscribe extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardUnsubAck extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def prepareServerUnpublisher(data: Start): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val reply = Promise[RemotePacketRouter.Registered.type][0m
[0m[[0m[0mdebug[0m] [0m[0m    data.packetRouter ! RemotePacketRouter.Register(context.self.unsafeUpcast, data.clientId, data.packetId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m    import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(RemotePacketRouter.Registered) => context.self ! RegisteredPacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(_) => context.self ! UnobtainablePacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case RegisteredPacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.success(ForwardUnsubscribe)[0m
[0m[[0m[0mdebug[0m] [0m[0m        serverUnsubscribe([0m
[0m[[0m[0mdebug[0m] [0m[0m          ServerUnsubscribe(data.clientId, data.packetId, data.unsubscribed, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnobtainablePacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.failure(UnsubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.unsubscribed.failure(UnsubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw UnsubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def serverUnsubscribe(data: ServerUnsubscribe): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceiveUnsubAck = "server-receive-unsubAck"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceiveUnsubAck, ReceiveUnsubAckTimeout, data.settings.receiveUnsubAckTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case UnsubAckReceivedLocally(remote) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          remote.success(ForwardUnsubAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.unsubscribed.success(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceiveUnsubAckTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.unsubscribed.failure(UnsubscribeFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw UnsubscribeFailed[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! RemotePacketRouter.Unregister(data.clientId, data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/impl/RequestState.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.{ActorRef, Behavior, PostStop}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.typed.scaladsl.Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Materializer, OverflowStrategy}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{BroadcastHub, Keep, Source, SourceQueueWithComplete}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Promise[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A producer manages the client state in relation to publishing to a server-side topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Producers are slightly special in that they should do all that they can to ensure that[0m
[0m[[0m[0mdebug[0m] [0m[0m * a PUBLISH message gets through. Hence, retries are indefinite.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * A producer is created per server per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Producer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type PublishData = Option[_][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishData: PublishData,[0m
[0m[[0m[0mdebug[0m] [0m[0m            remote: Promise[Source[ForwardPublishingCommand, NotUsed]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings)(implicit mat: Materializer): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    preparePublish(Start(publish, publishData, remote, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val publish: Publish, val publishData: PublishData, val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(override val publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val publishData: PublishData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         remote: Promise[Source[ForwardPublishingCommand, NotUsed]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(publish, publishData, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Publishing(remote: SourceQueueWithComplete[ForwardPublishingCommand],[0m
[0m[[0m[0mdebug[0m] [0m[0m                              packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              override val publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              override val publishData: PublishData,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              packetRouter: ActorRef[LocalPacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                              override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(publish, publishData, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class AcquiredPacketId(packetId: PacketId) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnacquiredPacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePubAckRecTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubAckReceivedFromRemote(local: Promise[ForwardPubAck]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubRecReceivedFromRemote(local: Promise[ForwardPubRec]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePubCompTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubCompReceivedFromRemote(local: Promise[ForwardPubComp]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceiveConnect extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class ForwardPublishingCommand extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPublish(publish: Publish, packetId: Option[PacketId]) extends ForwardPublishingCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubAck(publishData: PublishData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubRec(publishData: PublishData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubRel(publish: Publish, packetId: PacketId) extends ForwardPublishingCommand[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ForwardPubComp(publishData: PublishData) extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def preparePublish(data: Start)(implicit mat: Materializer): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    def requestPacketId(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val reply = Promise[LocalPacketRouter.Registered][0m
[0m[[0m[0mdebug[0m] [0m[0m      data.packetRouter ! LocalPacketRouter.Register(context.self.unsafeUpcast, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m      import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m      reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Success(acquired: LocalPacketRouter.Registered) => context.self ! AcquiredPacketId(acquired.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Failure(_) => context.self ! UnacquiredPacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    requestPacketId()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val (queue, source) = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m      .queue[ForwardPublishingCommand](1, OverflowStrategy.dropHead)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(BroadcastHub.sink)(Keep.both)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .run()[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.remote.success(source)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case AcquiredPacketId(packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          queue.offer(ForwardPublish(data.publish, Some(packetId)))[0m
[0m[[0m[0mdebug[0m] [0m[0m          publishUnacknowledged([0m
[0m[[0m[0mdebug[0m] [0m[0m            Publishing(queue, packetId, data.publish, data.publishData, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        case UnacquiredPacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          requestPacketId()[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          queue.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def publishUnacknowledged(data: Publishing)(implicit mat: Materializer): Behavior[Event] = Behaviors.withTimers {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceivePubackrec = "producer-receive-pubackrec"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (data.settings.producerPubAckRecTimeout.toNanos > 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceivePubackrec, ReceivePubAckRecTimeout, data.settings.producerPubAckRecTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case PubAckReceivedFromRemote(local)[0m
[0m[[0m[0mdebug[0m] [0m[0m              if data.publish.flags.contains(ControlPacketFlags.QoSAtLeastOnceDelivery) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardPubAck(data.publishData))[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m          case PubRecReceivedFromRemote(local)[0m
[0m[[0m[0mdebug[0m] [0m[0m              if data.publish.flags.contains(ControlPacketFlags.QoSExactlyOnceDelivery) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardPubRec(data.publishData))[0m
[0m[[0m[0mdebug[0m] [0m[0m            timer.cancel(ReceivePubackrec)[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishAcknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ReceivePubAckRecTimeout | ReceiveConnect =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer([0m
[0m[[0m[0mdebug[0m] [0m[0m              ForwardPublish(data.publish.copy(flags = data.publish.flags | ControlPacketFlags.DUP),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             Some(data.packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishUnacknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.packetRouter ! LocalPacketRouter.Unregister(data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def publishAcknowledged(data: Publishing)(implicit mat: Materializer): Behavior[Event] = Behaviors.withTimers {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceivePubrel = "producer-receive-pubrel"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (data.settings.producerPubCompTimeout.toNanos > 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m        timer.startSingleTimer(ReceivePubrel, ReceivePubCompTimeout, data.settings.producerPubCompTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      data.remote.offer(ForwardPubRel(data.publish, data.packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case PubCompReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            local.success(ForwardPubComp(data.publishData))[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ReceivePubCompTimeout | ReceiveConnect =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.offer(ForwardPubRel(data.publish, data.packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishAcknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.packetRouter ! LocalPacketRouter.Unregister(data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m            data.remote.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m            Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * A consumer manages the client state in relation to having made a[0m
[0m[[0m[0mdebug[0m] [0m[0m * subscription to a server-side topic. A consumer is created[0m
[0m[[0m[0mdebug[0m] [0m[0m * per server per topic per packet id.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object Consumer {[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No ACK received - the publication failed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class ConsumeFailed(publish: Publish) extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m            clientId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m            local: Promise[ForwardPublish.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m            packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: MqttSessionSettings): Behavior[Event] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    prepareClientConsumption(Start(publish, clientId, packetId, local, packetRouter, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Our FSM data, FSM events and commands emitted by the FSM[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Data(val publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val clientId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                             val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Start(override val publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val clientId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         local: Promise[ForwardPublish.type],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(publish, clientId, packetId, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class ClientConsuming(override val publish: Publish,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val clientId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val packetRouter: ActorRef[RemotePacketRouter.Request[Event]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   override val settings: MqttSessionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Data(publish, clientId, packetId, packetRouter, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object RegisteredPacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object UnobtainablePacketId extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubAckReceivedLocally(remote: Promise[ForwardPubAck.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubRecReceivedLocally(remote: Promise[ForwardPubRec.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePubAckRecTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubRelReceivedFromRemote(local: Promise[ForwardPubRel.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePubRelTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class PubCompReceivedLocally(remote: Promise[ForwardPubComp.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ReceivePubCompTimeout extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class DupPublishReceivedFromRemote(local: Promise[ForwardPublish.type]) extends Event[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPublish extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPubAck extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPubRec extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPubRel extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ForwardPubComp extends Command[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // State event handling[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def prepareClientConsumption(data: Start): Behavior[Event] = Behaviors.setup { context =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val reply = Promise[RemotePacketRouter.Registered.type][0m
[0m[[0m[0mdebug[0m] [0m[0m    data.packetRouter ! RemotePacketRouter.Register(context.self.unsafeUpcast, data.clientId, data.packetId, reply)[0m
[0m[[0m[0mdebug[0m] [0m[0m    import context.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    reply.future.onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(RemotePacketRouter.Registered) => context.self ! RegisteredPacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(_) => context.self ! UnobtainablePacketId[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case RegisteredPacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.success(ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m        consumeUnacknowledged([0m
[0m[[0m[0mdebug[0m] [0m[0m          ClientConsuming(data.publish, data.clientId, data.packetId, data.packetRouter, data.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnobtainablePacketId =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val ex = ConsumeFailed(data.publish)[0m
[0m[[0m[0mdebug[0m] [0m[0m        data.local.failure(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw ex[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def consumeUnacknowledged(data: ClientConsuming): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceivePubackrel = "consumer-receive-pubackrel"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceivePubackrel, ReceivePubAckRecTimeout, data.settings.consumerPubAckRecTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case PubAckReceivedLocally(remote) if data.publish.flags.contains(ControlPacketFlags.QoSAtLeastOnceDelivery) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          remote.success(ForwardPubAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case PubRecReceivedLocally(remote) if data.publish.flags.contains(ControlPacketFlags.QoSExactlyOnceDelivery) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          remote.success(ForwardPubRec)[0m
[0m[[0m[0mdebug[0m] [0m[0m          timer.cancel(ReceivePubackrel)[0m
[0m[[0m[0mdebug[0m] [0m[0m          consumeReceived(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case DupPublishReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m          consumeUnacknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceivePubAckRecTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw ConsumeFailed(data.publish)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! RemotePacketRouter.Unregister(data.clientId, data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def consumeReceived(data: ClientConsuming): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceivePubrel = "consumer-receive-pubrel"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceivePubrel, ReceivePubRelTimeout, data.settings.consumerPubRelTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case PubRelReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardPubRel)[0m
[0m[[0m[0mdebug[0m] [0m[0m          timer.cancel(ReceivePubrel)[0m
[0m[[0m[0mdebug[0m] [0m[0m          consumeAcknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case DupPublishReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m          consumeUnacknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceivePubRelTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw ConsumeFailed(data.publish)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! RemotePacketRouter.Unregister(data.clientId, data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def consumeAcknowledged(data: ClientConsuming): Behavior[Event] = Behaviors.withTimers { timer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ReceivePubcomp = "consumer-receive-pubcomp"[0m
[0m[[0m[0mdebug[0m] [0m[0m    timer.startSingleTimer(ReceivePubcomp, ReceivePubCompTimeout, data.settings.consumerPubCompTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveMessagePartial[Event] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case PubCompReceivedLocally(remote) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          remote.success(ForwardPubComp)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m        case DupPublishReceivedFromRemote(local) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          local.success(ForwardPublish)[0m
[0m[[0m[0mdebug[0m] [0m[0m          timer.cancel(ReceivePubcomp)[0m
[0m[[0m[0mdebug[0m] [0m[0m          consumeUnacknowledged(data)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case ReceivePubCompTimeout =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw ConsumeFailed(data.publish)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          data.packetRouter ! RemotePacketRouter.Unregister(data.clientId, data.packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object LocalPacketRouter {[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Raised on routing if a packet id cannot determine an actor to route to[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class CannotRoute(packetId: PacketId) extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * In case some brokers treat 0 as no packet id, we set our min to 1[0m
[0m[[0m[0mdebug[0m] [0m[0m   * e.g. https://renesasrulz.com/synergy/synergy_tech_notes/f/technical-bulletin-board-notification-postings/8998/mqtt-client-packet-identifier-is-0-by-default-which-causes-azure-iot-hub-to-reset-connection[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val MinPacketId = PacketId(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val MaxPacketId = PacketId(0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Requests[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Register[A](registrant: ActorRef[A], reply: Promise[Registered]) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Unregister[A](packetId: PacketId) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Route[A](packetId: PacketId, event: A, failureReply: Promise[_]) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Replies[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Reply[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Registered(packetId: PacketId) extends Reply[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A]: Behavior[Request[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new LocalPacketRouter[A].main(Map.empty, Some(MinPacketId), Vector.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Find the next free packet id after the specified one.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def findNextPacketId[A](registrantsByPacketId: Map[PacketId, ActorRef[A]], after: PacketId): Option[PacketId] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    @annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m    def step(c: PacketId): Option[PacketId] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.underlying == after.underlying) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // this is a bug, given our guard for entry into `step` checks size. this[0m
[0m[[0m[0mdebug[0m] [0m[0m        // means an illegal packet was stored in the map[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw new IllegalStateException("Cannot find a free packet id even though one is expected")[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.underlying <= MaxPacketId.underlying && !registrantsByPacketId.contains(c))[0m
[0m[[0m[0mdebug[0m] [0m[0m        Some(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m      else if (c.underlying < MaxPacketId.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m        step(PacketId(c.underlying + 1))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else[0m
[0m[[0m[0mdebug[0m] [0m[0m        step(MinPacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (registrantsByPacketId.size == (MaxPacketId.underlying - MinPacketId.underlying))[0m
[0m[[0m[0mdebug[0m] [0m[0m      None[0m
[0m[[0m[0mdebug[0m] [0m[0m    else[0m
[0m[[0m[0mdebug[0m] [0m[0m      step(PacketId(after.underlying + 1))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Route locally generated MQTT packets based on packet identifiers.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Callers are able to request that they be registered for routing and,[0m
[0m[[0m[0mdebug[0m] [0m[0m * in return, receive the packet identifier acquired. These[0m
[0m[[0m[0mdebug[0m] [0m[0m * callers then release packet identifiers so that they may then[0m
[0m[[0m[0mdebug[0m] [0m[0m * be re-used.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The acquisition algorithm is optimised to return newly allocated[0m
[0m[[0m[0mdebug[0m] [0m[0m * packet ids fast, and take the cost when releasing them as[0m
[0m[[0m[0mdebug[0m] [0m[0m * the caller isn't waiting on a reply.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] class LocalPacketRouter[A] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import LocalPacketRouter._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Processing[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def main(registrantsByPacketId: Map[PacketId, ActorRef[A]],[0m
[0m[[0m[0mdebug[0m] [0m[0m           nextPacketId: Option[PacketId],[0m
[0m[[0m[0mdebug[0m] [0m[0m           pendingRegistrations: Vector[Register[A]]): Behavior[Request[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receive[Request[A]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, register @ Register(registrant: ActorRef[A], reply)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          nextPacketId match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(currentPacketId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              reply.success(Registered(currentPacketId))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              val nextRegistrations = registrantsByPacketId + (currentPacketId -> registrant)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              main([0m
[0m[[0m[0mdebug[0m] [0m[0m                nextRegistrations,[0m
[0m[[0m[0mdebug[0m] [0m[0m                findNextPacketId(nextRegistrations, currentPacketId),[0m
[0m[[0m[0mdebug[0m] [0m[0m                pendingRegistrations[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              // all packet ids are taken, so we'll wait until one is unregistered[0m
[0m[[0m[0mdebug[0m] [0m[0m              // to continue[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              main(registrantsByPacketId, nextPacketId, pendingRegistrations :+ register)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (context, Unregister(packetId)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val remainingPacketIds = registrantsByPacketId - packetId[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          pendingRegistrations[0m
[0m[[0m[0mdebug[0m] [0m[0m            .foreach(context.self.tell)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          main(remainingPacketIds, Some(nextPacketId.getOrElse(packetId)), Vector.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, Route(packetId, event, failureReply)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          registrantsByPacketId.get(packetId) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(reply) => reply ! event[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None => failureReply.failure(CannotRoute(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .receiveSignal {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (_, PostStop) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          pendingRegistrations[0m
[0m[[0m[0mdebug[0m] [0m[0m            .foreach(_.reply.failure(new IllegalStateException("LocalPacketRouter was stopped")))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          Behaviors.stopped[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] object RemotePacketRouter {[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Raised on routing if a packet id cannot determine an actor to route to[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class CannotRoute(packetId: PacketId) extends Exception with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Requests[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Register[A](registrant: ActorRef[A],[0m
[0m[[0m[0mdebug[0m] [0m[0m                               clientId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                               packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               reply: Promise[Registered.type])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class RegisterConnection[A](connectionId: ByteString, clientId: String) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Unregister[A](clientId: Option[String], packetId: PacketId) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnregisterConnection[A](connectionId: ByteString) extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class Route[A](clientId: Option[String], packetId: PacketId, event: A, failureReply: Promise[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class RouteViaConnection[A](connectionId: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         event: A,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         failureReply: Promise[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends Request[A][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Replies[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class Reply[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object Registered extends Reply[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Construct with the starting state[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A]: Behavior[Request[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RemotePacketRouter[A].main(Map.empty, Map.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Route remotely generated MQTT packets based on packet identifiers.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Callers are able to request that they be registered for routing[0m
[0m[[0m[0mdebug[0m] [0m[0m * along with a packet id received from the remote.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[streaming] class RemotePacketRouter[A] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import RemotePacketRouter._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Processing[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def main(registrantsByPacketId: Map[(Option[String], PacketId), ActorRef[A]],[0m
[0m[[0m[0mdebug[0m] [0m[0m           clientIdsByConnectionId: Map[ByteString, String]): Behavior[Request[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Behaviors.receiveMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Register(registrant: ActorRef[A], clientId, packetId, reply) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        reply.success(Registered)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val key = (clientId, packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m        main(registrantsByPacketId + (key -> registrant), clientIdsByConnectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case RegisterConnection(connectionId, clientId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        main(registrantsByPacketId, clientIdsByConnectionId + (connectionId -> clientId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Unregister(clientId, packetId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val key = (clientId, packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m        main(registrantsByPacketId - key, clientIdsByConnectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case UnregisterConnection(connectionId) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        main(registrantsByPacketId, clientIdsByConnectionId - connectionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Route(clientId, packetId, event, failureReply) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val key = (clientId, packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m        registrantsByPacketId.get(key) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(reply) => reply ! event[0m
[0m[[0m[0mdebug[0m] [0m[0m          case None => failureReply.failure(CannotRoute(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m      case RouteViaConnection(connectionId, packetId, event, failureReply) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        clientIdsByConnectionId.get(connectionId) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case clientId: Some[String] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val key = (clientId, packetId)[0m
[0m[[0m[0mdebug[0m] [0m[0m            registrantsByPacketId.get(key) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Some(reply) => reply ! event[0m
[0m[[0m[0mdebug[0m] [0m[0m              case None => failureReply.failure(CannotRoute(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            failureReply.failure(CannotRoute(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        Behaviors.same[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Topics {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 4.7 Topic Names and Topic Filters[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Inspired by https://github.com/eclipse/paho.mqtt.java/blob/master/org.eclipse.paho.client.mqttv3/src/main/java/org/eclipse/paho/client/mqttv3/MqttTopic.java#L240[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def filter(topicFilterName: String, topicName: String): Boolean = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m    def matchStrings(tfn: String, tn: String): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (tfn == "/+" && tn == "/") {[0m
[0m[[0m[0mdebug[0m] [0m[0m        true[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else if (tfn.nonEmpty && tn.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val tfnHead = tfn.charAt(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val tnHead = tn.charAt(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (tfnHead == '/' && tnHead != '/') {[0m
[0m[[0m[0mdebug[0m] [0m[0m          false[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (tfnHead == '/' && tnHead == '/' && tn.length == 1) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          matchStrings(tfn, tn.tail)[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (tfnHead != '+' && tfnHead != '#' && tfnHead != tnHead) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          false[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (tfnHead == '+') {[0m
[0m[[0m[0mdebug[0m] [0m[0m          matchStrings(tfn.tail, tn.tail.dropWhile(_ != '/'))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (tfnHead == '#') {[0m
[0m[[0m[0mdebug[0m] [0m[0m          matchStrings(tfn.tail, "")[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          matchStrings(tfn.tail, tn.tail)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else if (tfn.isEmpty && tn.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        true[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else if (tfn == "/#" && tn.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        true[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        false[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    matchStrings(topicFilterName, topicName)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt-streaming/src/main/scala/akka/stream/alpakka/mqtt/streaming/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.streaming[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.ByteOrder[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.StandardCharsets[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.{NoSuchElementException, Optional}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.{CompletionStage, ForkJoinPool, TimeUnit}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.japi.{Pair => AkkaPair}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.streaming.Connect.ProtocolLevel[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.{ByteIterator, ByteString, ByteStringBuilder}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2.2.1 MQTT Control Packet type[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ControlPacketType {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Reserved1 = ControlPacketType(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val CONNECT = ControlPacketType(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val CONNACK = ControlPacketType(2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PUBLISH = ControlPacketType(3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PUBACK = ControlPacketType(4)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PUBREC = ControlPacketType(5)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PUBREL = ControlPacketType(6)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PUBCOMP = ControlPacketType(7)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val SUBSCRIBE = ControlPacketType(8)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val SUBACK = ControlPacketType(9)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val UNSUBSCRIBE = ControlPacketType(10)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val UNSUBACK = ControlPacketType(11)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PINGREQ = ControlPacketType(12)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PINGRESP = ControlPacketType(13)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val DISCONNECT = ControlPacketType(14)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Reserved2 = ControlPacketType(15)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ControlPacketType private (underlying: Int) extends AnyVal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2.2.2 Flags[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ControlPacketFlags {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val None = ControlPacketFlags(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReservedGeneral = ControlPacketFlags(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReservedPubRel = ControlPacketFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReservedSubscribe = ControlPacketFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReservedUnsubscribe = ControlPacketFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReservedUnsubAck = ControlPacketFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val DUP = ControlPacketFlags(1 << 3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val QoSAtMostOnceDelivery = ControlPacketFlags(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val QoSAtLeastOnceDelivery = ControlPacketFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val QoSExactlyOnceDelivery = ControlPacketFlags(2 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val QoSReserved = ControlPacketFlags(3 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val QoSFailure = ControlPacketFlags(1 << 7)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val RETAIN = ControlPacketFlags(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ControlPacketFlags private (underlying: Int) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise OR[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def |(rhs: ControlPacketFlags): ControlPacketFlags =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ControlPacketFlags(underlying | rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise AND[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def &(rhs: ControlPacketFlags): ControlPacketFlags =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ControlPacketFlags(underlying & rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience for testing bits - returns true if all passed in are set[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def contains(bits: ControlPacketFlags): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (underlying & bits.underlying) == bits.underlying[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2 MQTT Control Packet format[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class ControlPacket(val packetType: ControlPacketType, val flags: ControlPacketFlags)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object Reserved1 extends ControlPacket(ControlPacketType.Reserved1, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object Reserved2 extends ControlPacket(ControlPacketType.Reserved2, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2.3.1 Packet Identifier[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class PacketId private (underlying: Int) extends AnyVal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ConnectFlags {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val None = ConnectFlags(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Reserved = ConnectFlags(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val CleanSession = ConnectFlags(1 << 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val WillFlag = ConnectFlags(1 << 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val WillQoS = ConnectFlags(3 << 3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val WillRetain = ConnectFlags(1 << 5)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PasswordFlag = ConnectFlags(1 << 6)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val UsernameFlag = ConnectFlags(1 << 7)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.1.2.3 Connect Flags[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ConnectFlags private (underlying: Int) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise OR[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def |(rhs: ConnectFlags): ConnectFlags =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ConnectFlags(underlying | rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise AND[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def &(rhs: ConnectFlags): ConnectFlags =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ConnectFlags(underlying & rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience for testing bits - returns true if all passed in are set[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def contains(bits: ConnectFlags): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (underlying & bits.underlying) == bits.underlying[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Connect {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type ProtocolName = String[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Mqtt: ProtocolName = "MQTT"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type ProtocolLevel = Int[0m
[0m[[0m[0mdebug[0m] [0m[0m  val v311: ProtocolLevel = 4[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val DefaultConnectTimeout: FiniteDuration =[0m
[0m[[0m[0mdebug[0m] [0m[0m    60.seconds[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a connect object without credentials.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(clientId: String, connectFlags: ConnectFlags): Connect =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Connect(clientId, connectFlags)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a connect object with credentials. This function will also set the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * corresponding username and password flags.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(clientId: String, extraConnectFlags: ConnectFlags, username: String, password: String): Connect =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Connect(clientId, extraConnectFlags, username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.1 CONNECT – Client requests a connection to a Server[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Connect(protocolName: Connect.ProtocolName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         protocolLevel: Connect.ProtocolLevel,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         connectFlags: ConnectFlags,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         keepAlive: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         willTopic: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         willMessage: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         username: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                         password: Option[String])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.CONNECT, ControlPacketFlags.ReservedGeneral) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a connect object without credentials.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(clientId: String, connectFlags: ConnectFlags) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(Connect.Mqtt, Connect.v311, clientId, connectFlags, Connect.DefaultConnectTimeout, None, None, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a connect object with credentials. This function will also set the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * corresponding username and password flags.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(clientId: String, extraConnectFlags: ConnectFlags, username: String, password: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this([0m
[0m[[0m[0mdebug[0m] [0m[0m      Connect.Mqtt,[0m
[0m[[0m[0mdebug[0m] [0m[0m      Connect.v311,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      extraConnectFlags | ConnectFlags.UsernameFlag | ConnectFlags.PasswordFlag,[0m
[0m[[0m[0mdebug[0m] [0m[0m      Connect.DefaultConnectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      Some(username),[0m
[0m[[0m[0mdebug[0m] [0m[0m      Some(password)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""Connect(protocolName:$protocolName,protocolLevel:$protocolLevel,clientId:$clientId,connectFlags:$connectFlags,keepAlive:$keepAlive,willTopic:$willTopic,willMessage:$willMessage,username:$username,password:${password[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => "********")})"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ConnAckFlags {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val None = ConnAckFlags(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val SessionPresent = ConnAckFlags(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.2.2.1 Connect Acknowledge Flags[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ConnAckFlags private (underlying: Int) extends AnyVal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ConnAckReturnCode {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionAccepted = ConnAckReturnCode(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionRefusedUnacceptableProtocolVersion = ConnAckReturnCode(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionRefusedIdentifierRejected = ConnAckReturnCode(2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionRefusedServerUnavailable = ConnAckReturnCode(3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionRefusedBadUsernameOrPassword = ConnAckReturnCode(4)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConnectionRefusedNotAuthorized = ConnAckReturnCode(5)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.2.2.3 Connect Return code[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ConnAckReturnCode private (underlying: Int) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise OR[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def |(rhs: ConnAckReturnCode): ConnAckReturnCode =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ConnAckReturnCode(underlying | rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience bitwise AND[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def &(rhs: ConnAckReturnCode): ConnAckReturnCode =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ConnAckReturnCode(underlying & rhs.underlying)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convenience for testing bits - returns true if all passed in are set[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def contains(bits: ConnAckReturnCode): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (underlying & bits.underlying) == bits.underlying[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.2 CONNACK – Acknowledge connection request[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ConnAck(connectAckFlags: ConnAckFlags, returnCode: ConnAckReturnCode)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.CONNACK, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Publish {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.3 PUBLISH – Publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(flags: ControlPacketFlags, topicName: String, payload: ByteString): Publish =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Publish(flags, topicName, payload)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a publish message with at least once delivery[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topicName: String, payload: ByteString): Publish =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Publish(topicName, payload)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.3 PUBLISH – Publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Publish @InternalApi private[streaming] (override val flags: ControlPacketFlags,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          topicName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          packetId: Option[PacketId],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          payload: ByteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.PUBLISH, flags) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.3 PUBLISH – Publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(flags: ControlPacketFlags, topicName: String, payload: ByteString) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(flags, topicName, None, payload)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Conveniently create a publish message with at least once delivery[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicName: String, payload: ByteString) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(ControlPacketFlags.QoSAtLeastOnceDelivery, topicName, Some(PacketId(0)), payload)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""Publish(flags:$flags,topicName:$topicName,packetId:$packetId,payload:${payload.size}b)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.4 PUBACK – Publish acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class PubAck(packetId: PacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.PUBACK, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.5 PUBREC – Publish received (QoS 2 publish received, part 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class PubRec(packetId: PacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.PUBREC, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.6 PUBREL – Publish release (QoS 2 publish received, part 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class PubRel(packetId: PacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.PUBREL, ControlPacketFlags.ReservedPubRel)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.7 PUBCOMP – Publish complete (QoS 2 publish received, part 3)[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class PubComp(packetId: PacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.PUBCOMP, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Subscribe {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topicFilters: Seq[(String, ControlPacketFlags)]): Subscribe =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Subscribe(topicFilters)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  A convenience for subscribing to a single topic with at-least-once semantics[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topicFilter: String): Subscribe =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Subscribe(topicFilter)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Subscribe @InternalApi private[streaming] (packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                            topicFilters: Seq[(String, ControlPacketFlags)])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.SUBSCRIBE, ControlPacketFlags.ReservedSubscribe) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilters: Seq[(String, ControlPacketFlags)]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), topicFilters)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilters: java.util.List[AkkaPair[String, Integer]]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), topicFilters.asScala.toIndexedSeq.map(v => v.first -> ControlPacketFlags(v.second)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A convenience for subscribing to a single topic with at-least-once semantics[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilter: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), List(topicFilter -> ControlPacketFlags.QoSAtLeastOnceDelivery))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.9 SUBACK – Subscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class SubAck(packetId: PacketId, returnCodes: Seq[ControlPacketFlags])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.SUBACK, ControlPacketFlags.ReservedGeneral) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.9 SUBACK – Subscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(packetId: PacketId, returnCodes: java.util.List[Integer]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(packetId, returnCodes.asScala.toIndexedSeq.map(v => ControlPacketFlags(v)))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Unsubscribe {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topicFilters: Seq[String]): Unsubscribe =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Unsubscribe(topicFilters)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A convenience for unsubscribing from a single topic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topicFilter: String): Unsubscribe =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Unsubscribe(topicFilter)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Unsubscribe @InternalApi private[streaming] (packetId: PacketId, topicFilters: Seq[String])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.UNSUBSCRIBE, ControlPacketFlags.ReservedUnsubscribe) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilters: Seq[String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), topicFilters)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m   * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilters: java.util.List[String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), topicFilters.asScala.toIndexedSeq)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A convenience for unsubscribing from a single topic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(topicFilter: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(PacketId(0), List(topicFilter))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.11 UNSUBACK – Unsubscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class UnsubAck(packetId: PacketId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ControlPacket(ControlPacketType.UNSUBACK, ControlPacketFlags.ReservedUnsubAck)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.12 PINGREQ – PING request[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object PingReq extends ControlPacket(ControlPacketType.PINGREQ, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.13 PINGRESP – PING response[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object PingResp extends ControlPacket(ControlPacketType.PINGRESP, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3.14 DISCONNECT – Disconnect notification[0m
[0m[[0m[0mdebug[0m] [0m[0m * http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object Disconnect extends ControlPacket(ControlPacketType.DISCONNECT, ControlPacketFlags.ReservedGeneral)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides functions to decode bytes to various MQTT types and vice-versa.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Performed in accordance with http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html[0m
[0m[[0m[0mdebug[0m] [0m[0m * with section numbers referenced accordingly.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttCodec {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private implicit val byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Returned by decoding when no decoding can be performed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Not enough bytes in the byte iterator[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object BufferUnderflow extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Cannot determine the type/flags combination of the control packet[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnknownPacketType(packetType: ControlPacketType, flags: ControlPacketFlags) extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A message has been received that exceeds the maximum we have chosen--which is[0m
[0m[[0m[0mdebug[0m] [0m[0m   * typically much less than what the spec permits. The reported sizes do not[0m
[0m[[0m[0mdebug[0m] [0m[0m   * include the fixed header size of 2 bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class InvalidPacketSize(packetSize: Int, maxPacketSize: Int) extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Cannot determine the protocol name/level combination of the connect[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class UnknownConnectProtocol(protocolName: Either[DecodeError, String], protocolLevel: ProtocolLevel)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Bit 0 of the connect flag was set - which it should not be as it is reserved.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case object ConnectFlagReservedSet extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Something is wrong with the connect message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class BadConnectMessage(clientId: Either[MqttCodec.DecodeError, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     willTopic: Option[Either[MqttCodec.DecodeError, String]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     willMessage: Option[Either[MqttCodec.DecodeError, String]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     username: Option[Either[MqttCodec.DecodeError, String]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     password: Option[Either[MqttCodec.DecodeError, String]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends DecodeError {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"""BadConnectMessage(clientId:$clientId,willTopic:$willTopic,willMessage:$willMessage,username:$username,password:${password[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Left(x) => s"Left($x)"[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Right(x) => s"Right(" + x.map(_ => "********") + ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m        }})"""[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A reserved QoS was specified[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object InvalidQoS extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Bits 1 to 7 are set with the Connect Ack flags[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ConnectAckFlagReservedBitsSet extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Something is wrong with the publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class BadPublishMessage(topicName: Either[DecodeError, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     packetId: Option[PacketId],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     payload: ByteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends DecodeError {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"""BadPublishMessage(topicName:$topicName,packetId:$packetId,payload:${payload.size}b)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Something is wrong with the subscribe message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class BadSubscribeMessage(packetId: PacketId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       topicFilters: Seq[(Either[DecodeError, String], ControlPacketFlags)])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Something is wrong with the subscribe ack message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class BadSubAckMessage(packetId: PacketId, returnCodes: Seq[ControlPacketFlags]) extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Something is wrong with the unsubscribe message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class BadUnsubscribeMessage(packetId: PacketId, topicFilters: Seq[Either[DecodeError, String]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends DecodeError[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final case class DecodeErrorOrControlPacket(v: Either[DecodeError, ControlPacket]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getDecodeError: Optional[DecodeError] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(_) => Optional.empty()[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Left(de) => Optional.of(de)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getControlPacket: Optional[ControlPacket] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(cp) => Optional.of(cp)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Left(_) => Optional.empty()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 1.5.3 UTF-8 encoded strings[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttString(val v: String) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val length = v.length & 0xffff[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(length).putBytes(v.getBytes(StandardCharsets.UTF_8), 0, length)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 2 MQTT Control Packet format[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttControlPacket(val v: ControlPacket) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder, remainingLength: Int): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putByte((v.packetType.underlying << 4 | v.flags.underlying).toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      remainingLength.encode(bsb)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 2.2.3 Remaining Length[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttRemainingLength(val v: Int) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val b0 = v[0m
[0m[[0m[0mdebug[0m] [0m[0m      val b1 = v >> 7[0m
[0m[[0m[0mdebug[0m] [0m[0m      val b2 = v >> 14[0m
[0m[[0m[0mdebug[0m] [0m[0m      val b3 = v >> 21[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putByte(((b0 & 0x7f) | (if (b1 > 0) 0x80 else 0x00)).toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (b1 > 0) bsb.putByte(((b1 & 0x7f) | (if (b2 > 0) 0x80 else 0x00)).toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (b2 > 0) bsb.putByte(((b2 & 0x7f) | (if (b3 > 0) 0x80 else 0x00)).toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (b3 > 0) bsb.putByte(b3.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.1 CONNECT – Client requests a connection to a Server[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttConnect(val v: Connect) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val packetBsb = ByteString.newBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Variable header[0m
[0m[[0m[0mdebug[0m] [0m[0m      Connect.Mqtt.encode(packetBsb)[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putByte(Connect.v311.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putByte(v.connectFlags.underlying.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putShort(v.keepAlive.toSeconds.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Payload[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.clientId.encode(packetBsb)[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.willTopic.foreach(_.encode(packetBsb))[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.willMessage.foreach(_.encode(packetBsb))[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.username.foreach(_.encode(packetBsb))[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.password.foreach(_.encode(packetBsb))[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Fixed header[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, packetBsb.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.append(packetBsb.result())[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.2 CONNACK – Acknowledge connection request[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttConnAck(val v: ConnAck) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putByte(v.connectAckFlags.underlying.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putByte(v.returnCode.underlying.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.3 PUBLISH – Publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPublish(val v: Publish) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder, packetId: Option[PacketId]): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val packetBsb = ByteString.newBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Variable header[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.topicName.encode(packetBsb)[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetId.foreach(pi => packetBsb.putShort(pi.underlying.toShort))[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Payload[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.append(v.payload)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Fixed header[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, packetBsb.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.append(packetBsb.result())[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.4 PUBACK – Publish acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPubAck(val v: PubAck) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.5 PUBREC – Publish received (QoS 2 publish received, part 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPubRec(val v: PubRec) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.6 PUBREL – Publish release (QoS 2 publish received, part 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPubRel(val v: PubRel) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.7 PUBCOMP – Publish complete (QoS 2 publish received, part 3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPubComp(val v: PubComp) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttSubscribe(val v: Subscribe) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder, packetId: PacketId): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val packetBsb = ByteString.newBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Variable header[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putShort(packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Payload[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.topicFilters.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (topicFilter, topicFilterFlags) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          topicFilter.encode(packetBsb)[0m
[0m[[0m[0mdebug[0m] [0m[0m          packetBsb.putByte(topicFilterFlags.underlying.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Fixed header[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, packetBsb.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.append(packetBsb.result())[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.9 SUBACK – Subscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttSubAck(val v: SubAck) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val packetBsb = ByteString.newBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Variable header[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Payload[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.returnCodes.foreach { returnCode =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        packetBsb.putByte(returnCode.underlying.toByte)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Fixed header[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, packetBsb.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.append(packetBsb.result())[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttUnsubscribe(val v: Unsubscribe) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder, packetId: PacketId): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val packetBsb = ByteString.newBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Variable header[0m
[0m[[0m[0mdebug[0m] [0m[0m      packetBsb.putShort(packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Payload[0m
[0m[[0m[0mdebug[0m] [0m[0m      v.topicFilters.foreach(_.encode(packetBsb))[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Fixed header[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, packetBsb.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.append(packetBsb.result())[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.11 UNSUBACK – Unsubscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttUnsubAck(val v: UnsubAck) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb.putShort(v.packetId.underlying.toShort)[0m
[0m[[0m[0mdebug[0m] [0m[0m      bsb[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.12 PINGREQ – PING request[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPingReq(val v: PingReq.type) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder =[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.13 PINGRESP – PING response[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttPingResp(val v: PingResp.type) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder =[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // 3.14 DISCONNECT – Disconnect notification[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttDisconnect(val v: Disconnect.type) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def encode(bsb: ByteStringBuilder): ByteStringBuilder =[0m
[0m[[0m[0mdebug[0m] [0m[0m      (v: ControlPacket).encode(bsb, 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit class MqttByteIterator(val v: ByteIterator) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 1.5.3 UTF-8 encoded strings[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeString(): Either[DecodeError, String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val length = v.getShort & 0xffff[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(v.getByteString(length).utf8String)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 2 MQTT Control Packet format[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeControlPacket(maxPacketSize: Int): Either[DecodeError, ControlPacket] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val b = v.getByte & 0xff[0m
[0m[[0m[0mdebug[0m] [0m[0m        v.decodeRemainingLength() match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Right(l) if l <= maxPacketSize =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            (ControlPacketType(b >> 4), ControlPacketFlags(b & 0xf)) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.Reserved1, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Right(Reserved1)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.Reserved2, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Right(Reserved2)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.CONNECT, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeConnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.CONNACK, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeConnAck()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PUBLISH, flags) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodePublish(l, flags)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PUBACK, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodePubAck()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PUBREC, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodePubRec()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PUBREL, ControlPacketFlags.ReservedPubRel) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodePubRel()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PUBCOMP, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodePubComp()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.SUBSCRIBE, ControlPacketFlags.ReservedSubscribe) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeSubscribe(l)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.SUBACK, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeSubAck(l)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.UNSUBSCRIBE, ControlPacketFlags.ReservedUnsubscribe) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeUnsubscribe(l)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.UNSUBACK, ControlPacketFlags.ReservedUnsubAck) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                v.decodeUnsubAck()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PINGREQ, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Right(PingReq)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.PINGRESP, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Right(PingResp)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (ControlPacketType.DISCONNECT, ControlPacketFlags.ReservedGeneral) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Right(Disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case (packetType, flags) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Left(UnknownPacketType(packetType, flags))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Right(l) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Left(InvalidPacketSize(l, maxPacketSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Left(BufferUnderflow) => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 2.2.3 Remaining Length[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeRemainingLength(): Either[DecodeError, Int] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val l0 = v.getByte & 0xff[0m
[0m[[0m[0mdebug[0m] [0m[0m        val l1 = if ((l0 & 0x80) == 0x80) v.getByte & 0xff else 0[0m
[0m[[0m[0mdebug[0m] [0m[0m        val l2 = if ((l1 & 0x80) == 0x80) v.getByte & 0xff else 0[0m
[0m[[0m[0mdebug[0m] [0m[0m        val l3 = if ((l2 & 0x80) == 0x80) v.getByte & 0xff else 0[0m
[0m[[0m[0mdebug[0m] [0m[0m        val l = (l3 << 21) | ((l2 & 0x7f) << 14) | ((l1 & 0x7f) << 7) | (l0 & 0x7f)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(l)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.1 CONNECT – Client requests a connection to a Server[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeConnect(): Either[DecodeError, Connect] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val protocolName = v.decodeString()[0m
[0m[[0m[0mdebug[0m] [0m[0m        val protocolLevel = v.getByte & 0xff[0m
[0m[[0m[0mdebug[0m] [0m[0m        (protocolName, protocolLevel) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (Right(Connect.Mqtt), Connect.v311) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val connectFlags = ConnectFlags(v.getByte & 0xff)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (!connectFlags.contains(ConnectFlags.Reserved)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val keepAlive = FiniteDuration(v.getShort & 0xffff, TimeUnit.SECONDS)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val clientId = v.decodeString()[0m
[0m[[0m[0mdebug[0m] [0m[0m              val willTopic =[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (connectFlags.contains(ConnectFlags.WillFlag)) Some(v.decodeString()) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m              val willMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (connectFlags.contains(ConnectFlags.WillFlag)) Some(v.decodeString()) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m              val username =[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (connectFlags.contains(ConnectFlags.UsernameFlag)) Some(v.decodeString()) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m              val password =[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (connectFlags.contains(ConnectFlags.PasswordFlag)) Some(v.decodeString()) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m              (clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m               willTopic.fold[Either[DecodeError, Option[String]]](Right(None))(_.right.map(Some.apply)),[0m
[0m[[0m[0mdebug[0m] [0m[0m               willMessage.fold[Either[DecodeError, Option[String]]](Right(None))(_.right.map(Some.apply)),[0m
[0m[[0m[0mdebug[0m] [0m[0m               username.fold[Either[DecodeError, Option[String]]](Right(None))(_.right.map(Some.apply)),[0m
[0m[[0m[0mdebug[0m] [0m[0m               password.fold[Either[DecodeError, Option[String]]](Right(None))(_.right.map(Some.apply))) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case (Right(ci), Right(wt), Right(wm), Right(un), Right(pw)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Right(Connect(Connect.Mqtt, Connect.v311, ci, connectFlags, keepAlive, wt, wm, un, pw))[0m
[0m[[0m[0mdebug[0m] [0m[0m                case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Left(BadConnectMessage(clientId, willTopic, willMessage, username, password))[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Left(ConnectFlagReservedSet)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (pn, pl) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Left(UnknownConnectProtocol(pn, pl))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.2 CONNACK – Acknowledge connection request[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeConnAck(): Either[DecodeError, ConnAck] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val connectAckFlags = v.getByte & 0xff[0m
[0m[[0m[0mdebug[0m] [0m[0m        if ((connectAckFlags & 0xfe) == 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val resultCode = v.getByte & 0xff[0m
[0m[[0m[0mdebug[0m] [0m[0m          Right(ConnAck(ConnAckFlags(connectAckFlags), ConnAckReturnCode(resultCode)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(ConnectAckFlagReservedBitsSet)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.3 PUBLISH – Publish message[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodePublish(l: Int, flags: ControlPacketFlags): Either[DecodeError, Publish] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!flags.contains(ControlPacketFlags.QoSReserved)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val packetLen = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m          val topicName = v.decodeString()[0m
[0m[[0m[0mdebug[0m] [0m[0m          val packetId =[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (flags.contains(ControlPacketFlags.QoSAtLeastOnceDelivery) ||[0m
[0m[[0m[0mdebug[0m] [0m[0m                flags.contains(ControlPacketFlags.QoSExactlyOnceDelivery))[0m
[0m[[0m[0mdebug[0m] [0m[0m              Some(PacketId(v.getShort & 0xffff))[0m
[0m[[0m[0mdebug[0m] [0m[0m            else None[0m
[0m[[0m[0mdebug[0m] [0m[0m          val payload = v.getByteString(l - (packetLen - v.len))[0m
[0m[[0m[0mdebug[0m] [0m[0m          (topicName, packetId, payload) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (Right(tn), pi, p) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              Right(Publish(flags, tn, pi, p))[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              Left(BadPublishMessage(topicName, packetId, payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(InvalidQoS)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.4 PUBACK – Publish acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodePubAck(): Either[DecodeError, PubAck] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(PubAck(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.5 PUBREC – Publish received (QoS 2 publish received, part 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodePubRec(): Either[DecodeError, PubRec] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(PubRec(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.6 PUBREL – Publish release (QoS 2 publish received, part 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodePubRel(): Either[DecodeError, PubRel] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(PubRel(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.7 PUBCOMP – Publish complete (QoS 2 publish received, part 3)[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodePubComp(): Either[DecodeError, PubComp] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(PubComp(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.8 SUBSCRIBE - Subscribe to topics[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeSubscribe(l: Int): Either[DecodeError, Subscribe] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetLen = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m        def decodeTopicFilters([0m
[0m[[0m[0mdebug[0m] [0m[0m            remainingLen: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m            topicFilters: Vector[(Either[DecodeError, String], ControlPacketFlags)][0m
[0m[[0m[0mdebug[0m] [0m[0m        ): Vector[(Either[DecodeError, String], ControlPacketFlags)] =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (remainingLen > 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val packetLenAtTopicFilter = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m            val topicFilter = (v.decodeString(), ControlPacketFlags(v.getByte & 0xff))[0m
[0m[[0m[0mdebug[0m] [0m[0m            decodeTopicFilters(remainingLen - (packetLenAtTopicFilter - v.len), topicFilters :+ topicFilter)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            topicFilters[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        val topicFilters = decodeTopicFilters(l - (packetLen - v.len), Vector.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val topicFiltersValid = topicFilters.nonEmpty && topicFilters.foldLeft(true) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (true, (Right(_), tff)) if tff.underlying < ControlPacketFlags.QoSReserved.underlying => true[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (topicFiltersValid) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Right(Subscribe(packetId, topicFilters.flatMap {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (Right(tfs), tff) => List(tfs -> tff)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ => List.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m          }))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(BadSubscribeMessage(packetId, topicFilters))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.9 SUBACK – Subscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeSubAck(l: Int): Either[DecodeError, SubAck] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetLen = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m        def decodeReturnCodes(remainingLen: Int, returnCodes: Vector[ControlPacketFlags]): Vector[ControlPacketFlags] =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (remainingLen > 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val packetLenAtTopicFilter = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m            val returnCode = ControlPacketFlags(v.getByte & 0xff)[0m
[0m[[0m[0mdebug[0m] [0m[0m            decodeReturnCodes(remainingLen - (packetLenAtTopicFilter - v.len), returnCodes :+ returnCode)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            returnCodes[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        val returnCodes = decodeReturnCodes(l - (packetLen - v.len), Vector.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val returnCodesValid = returnCodes.nonEmpty && returnCodes.foldLeft(true) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (true, rc) if rc.underlying < ControlPacketFlags.QoSReserved.underlying => true[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (returnCodesValid) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Right(SubAck(packetId, returnCodes))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(BadSubAckMessage(packetId, returnCodes))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.10 UNSUBSCRIBE – Unsubscribe from topics[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeUnsubscribe(l: Int): Either[DecodeError, Unsubscribe] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetLen = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m        def decodeTopicFilters([0m
[0m[[0m[0mdebug[0m] [0m[0m            remainingLen: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m            topicFilters: Vector[Either[DecodeError, String]][0m
[0m[[0m[0mdebug[0m] [0m[0m        ): Vector[Either[DecodeError, String]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (remainingLen > 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val packetLenAtTopicFilter = v.len[0m
[0m[[0m[0mdebug[0m] [0m[0m            val topicFilter = v.decodeString()[0m
[0m[[0m[0mdebug[0m] [0m[0m            decodeTopicFilters(remainingLen - (packetLenAtTopicFilter - v.len), topicFilters :+ topicFilter)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            topicFilters[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        val topicFilters = decodeTopicFilters(l - (packetLen - v.len), Vector.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val topicFiltersValid = topicFilters.nonEmpty && topicFilters.foldLeft(true) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (true, Right(_)) => true[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (topicFiltersValid) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Right(Unsubscribe(packetId, topicFilters.flatMap {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Right(tfs) => List(tfs)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ => List.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m          }))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Left(BadUnsubscribeMessage(packetId, topicFilters))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // 3.11 UNSUBACK – Unsubscribe acknowledgement[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decodeUnsubAck(): Either[DecodeError, UnsubAck] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val packetId = PacketId(v.getShort & 0xffff)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Right(UnsubAck(packetId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NoSuchElementException => Left(BufferUnderflow)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Command {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Send a command to an MQTT session[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of data being carried through in general, but not here[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A](command: ControlPacket): Command[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Command(command)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Send a command to an MQTT session with data to carry through into[0m
[0m[[0m[0mdebug[0m] [0m[0m   * any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A](command: ControlPacket, carry: A): Command[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Command(command, carry)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Send a command to an MQTT session with optional data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m * into any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param completed A promise that is completed by the session when the command has been processed -[0m
[0m[[0m[0mdebug[0m] [0m[0m *                  useful for synchronizing when activities should occur in relation to a command[0m
[0m[[0m[0mdebug[0m] [0m[0m *                  The only command that supports this presently is SubAck on the server side. This[0m
[0m[[0m[0mdebug[0m] [0m[0m *                  is because it is important to know when to start publishing.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param carry The data to carry though[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam A The type of data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Command[A](command: ControlPacket, completed: Option[Promise[Done]], carry: Option[A]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Send a command to an MQTT session with optional data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   * into any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param completed A promise that is completed by the session when the command has been processed -[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                  useful for synchronizing when activities should occur in relation to a command[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                  The only command that supports this presently is SubAck on the server side. This[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                  is because it is important to know when to start publishing.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry though[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(command: ControlPacket, completed: Optional[CompletionStage[Done]], carry: Optional[A]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this([0m
[0m[[0m[0mdebug[0m] [0m[0m      command,[0m
[0m[[0m[0mdebug[0m] [0m[0m      completed.asScala.map { f =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val p = Promise[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m        p.future[0m
[0m[[0m[0mdebug[0m] [0m[0m          .foreach(f.toCompletableFuture.complete)(ExecutionContext.fromExecutorService(ForkJoinPool.commonPool()))[0m
[0m[[0m[0mdebug[0m] [0m[0m        p[0m
[0m[[0m[0mdebug[0m] [0m[0m      },[0m
[0m[[0m[0mdebug[0m] [0m[0m      carry.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Send a command to an MQTT session[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(command: ControlPacket) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(command, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Send a command to an MQTT session with data to carry through into[0m
[0m[[0m[0mdebug[0m] [0m[0m   * any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param command The command to send[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(command: ControlPacket, carry: A) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(command, None, Some(carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Event {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Receive an event from a MQTT session[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of data being carried through in general, but not here[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A](event: ControlPacket): Event[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Event(event)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Receive an event from a MQTT session with data to carry through into[0m
[0m[[0m[0mdebug[0m] [0m[0m   * any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[A](event: ControlPacket, carry: A): Event[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Event(event, carry)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Receive an event from a MQTT session with optional data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m * infrom ay related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param carry The data to carry though[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam A The type of data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Event[A](event: ControlPacket, carry: Option[A]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Receive an event from a MQTT session with optional data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   * infrom ay related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry though[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(event: ControlPacket, carry: Optional[A]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(event, carry.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Receive an event from a MQTT session[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(event: ControlPacket) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(event, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Receive an event from a MQTT session with data to carry through into[0m
[0m[[0m[0mdebug[0m] [0m[0m   * any related event.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param event The event to receive[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param carry The data to carry through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(event: ControlPacket, carry: A) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(event, Some(carry))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject DecodeErrorOrEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Return a Class object representing the carry's type. Java's[0m
[0m[[0m[0mdebug[0m] [0m[0m   * `.class` method does not do this, and there are many occassions[0m
[0m[[0m[0mdebug[0m] [0m[0m   * where the generic type needs to be retained.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam A The type of the carry[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The `DecodeErrorOrEvent` class including the carry type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def classOf[A]: Class[DecodeErrorOrEvent[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Predef.classOf[DecodeErrorOrEvent[A]][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * JAVA API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class DecodeErrorOrEvent[A](v: Either[MqttCodec.DecodeError, Event[A]]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getDecodeError: Optional[MqttCodec.DecodeError] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Right(_) => Optional.empty()[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Left(de) => Optional.of(de)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getEvent: Optional[Event[A]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Right(e) => Optional.of(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Left(_) => Optional.empty()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
