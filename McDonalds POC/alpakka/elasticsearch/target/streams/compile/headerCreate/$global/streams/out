[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/ReadResult.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Stream element type emitted by Elasticsearch sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The constructor is INTERNAL API, but you may construct instances for testing by using[0m
[0m[[0m[0mdebug[0m] [0m[0m * [[akka.stream.alpakka.elasticsearch.testkit.MessageFactory]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ReadResult[T] @InternalApi private[elasticsearch] (val id: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               val source: T,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               val version: Option[Long]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getVersion: java.util.Optional[Long] = version.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""ReadResult(id=$id,source=$source,version=${version.getOrElse("")})"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: ReadResult[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.id, that.id) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.source, that.source) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.version, that.version)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    source match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case o: AnyRef =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        java.util.Objects.hash(id, o, version)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        // TODO include source: AnyVal in hashcode[0m
[0m[[0m[0mdebug[0m] [0m[0m        java.util.Objects.hash(id, version)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/javadsl/ElasticsearchSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.jackson.databind.ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.jackson.databind.node.{ArrayNode, NumericNode}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.{Map => JMap}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API to create Elasticsearch sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of [[java.util.Map]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using default objectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             elasticsearchClient: RestClient): Source[ReadResult[java.util.Map[String, Object]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    create(indexName, typeName, query, settings, elasticsearchClient, new ObjectMapper())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of [[java.util.Map]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using custom objectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m             objectMapper: ObjectMapper): Source[ReadResult[java.util.Map[String, Object]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage([0m
[0m[[0m[0mdebug[0m] [0m[0m        indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option(typeName),[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map("query" -> query),[0m
[0m[[0m[0mdebug[0m] [0m[0m        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JacksonReader[java.util.Map[String, Object]](objectMapper, classOf[java.util.Map[String, Object]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of [[java.util.Map]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using custom objectMapper.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Example of searchParams-usage:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Map<String, String> searchParams = new HashMap<>();[0m
[0m[[0m[0mdebug[0m] [0m[0m   * searchParams.put("query", "{\"match_all\": {}}");[0m
[0m[[0m[0mdebug[0m] [0m[0m   * searchParams.put("_source", "[\"fieldToInclude\", \"anotherFieldToInclude\"]");[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             searchParams: JMap[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m             objectMapper: ObjectMapper): Source[ReadResult[java.util.Map[String, Object]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage([0m
[0m[[0m[0mdebug[0m] [0m[0m        indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option(typeName),[0m
[0m[[0m[0mdebug[0m] [0m[0m        searchParams.asScala.toMap,[0m
[0m[[0m[0mdebug[0m] [0m[0m        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JacksonReader[java.util.Map[String, Object]](objectMapper, classOf[java.util.Map[String, Object]])[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using default objectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m               elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m               clazz: Class[T]): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    typed[T](indexName, typeName, query, settings, elasticsearchClient, clazz, new ObjectMapper())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using custom objectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m               elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m               clazz: Class[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m               objectMapper: ObjectMapper): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage([0m
[0m[[0m[0mdebug[0m] [0m[0m        indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option(typeName),[0m
[0m[[0m[0mdebug[0m] [0m[0m        Map("query" -> query),[0m
[0m[[0m[0mdebug[0m] [0m[0m        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JacksonReader[T](objectMapper, clazz)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.javadsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Using custom objectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Example of searchParams-usage:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Map<String, String> searchParams = new HashMap<>();[0m
[0m[[0m[0mdebug[0m] [0m[0m   * searchParams.put("query", "{\"match_all\": {}}");[0m
[0m[[0m[0mdebug[0m] [0m[0m   * searchParams.put("_source", "[\"fieldToInclude\", \"anotherFieldToInclude\"]");[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               searchParams: JMap[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m               settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m               elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m               clazz: Class[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m               objectMapper: ObjectMapper): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage([0m
[0m[[0m[0mdebug[0m] [0m[0m        indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option(typeName),[0m
[0m[[0m[0mdebug[0m] [0m[0m        searchParams.asScala.toMap,[0m
[0m[[0m[0mdebug[0m] [0m[0m        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JacksonReader[T](objectMapper, clazz)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private final class JacksonReader[T](mapper: ObjectMapper, clazz: Class[T]) extends impl.MessageReader[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def convert(json: String): impl.ScrollResponse[T] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val jsonTree = mapper.readTree(json)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (jsonTree.has("error")) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        impl.ScrollResponse(Some(jsonTree.get("error").asText()), None)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val scrollId = jsonTree.get("_scroll_id").asText()[0m
[0m[[0m[0mdebug[0m] [0m[0m        val hits = jsonTree.get("hits").get("hits").asInstanceOf[ArrayNode][0m
[0m[[0m[0mdebug[0m] [0m[0m        val messages = hits.elements().asScala.toList.map { element =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val id = element.get("_id").asText()[0m
[0m[[0m[0mdebug[0m] [0m[0m          val source = element.get("_source")[0m
[0m[[0m[0mdebug[0m] [0m[0m          val version: Option[Long] = element.get("_version") match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case n: NumericNode => Some(n.asLong())[0m
[0m[[0m[0mdebug[0m] [0m[0m            case _ => None[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          new ReadResult[T](id, mapper.treeToValue(source, clazz), version)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        impl.ScrollResponse(None, Some(impl.ScrollResult(scrollId, messages)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/javadsl/ElasticsearchSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.jackson.databind.ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API to create Elasticsearch sinks.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      objectMapper: ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Sink[WriteMessage[T, NotUsed], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ElasticsearchFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .create(indexName, typeName, settings, elasticsearchClient, objectMapper)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore[WriteResult[T, NotUsed]], Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/javadsl/ElasticsearchFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.japi.Pair[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.{impl, _}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.jackson.databind.ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API to create Elasticsearch flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      objectMapper: ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Flow[WriteMessage[T, NotUsed], WriteResult[T, NotUsed], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m      .Flow[WriteMessage[T, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .batch(settings.bufferSize, immutable.Seq(_)) { case (seq, wm) => seq :+ wm }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        new impl.ElasticsearchFlowStage[T, NotUsed](indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                    typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                    elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                    settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                    new JacksonWriter[T](objectMapper))[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `passThrough` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithPassThrough[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m      indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      objectMapper: ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Flow[WriteMessage[T, C], WriteResult[T, C], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m      .Flow[WriteMessage[T, C]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .batch(settings.bufferSize, immutable.Seq(_)) { case (seq, wm) => seq :+ wm }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        new impl.ElasticsearchFlowStage[T, C](indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              new JacksonWriter[T](objectMapper))[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `context` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @throws IllegalArgumentException When settings configure retrying.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithContext[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m      indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      objectMapper: ObjectMapper[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Flow[Pair[WriteMessage[T, NotUsed], C], Pair[WriteResult[T, C], C], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m      .Flow[Pair[WriteMessage[T, NotUsed], C]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { pair =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        pair.first.withPassThrough(pair.second)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .batch(settings.bufferSize, immutable.Seq(_)) { case (seq, wm) => seq :+ wm }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        new impl.ElasticsearchFlowStage[T, C](indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              new JacksonWriter[T](objectMapper))[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { wr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Pair.create(wr, wr.message.passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private final class JacksonWriter[T](mapper: ObjectMapper) extends MessageWriter[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def convert(message: T): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m      mapper.writeValueAsString(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/testkit/MessageFactory.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.testkit[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.{ReadResult, WriteMessage, WriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MessageFactory {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For use with testing.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createReadResult[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      id: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      source: T,[0m
[0m[[0m[0mdebug[0m] [0m[0m      version: Option[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ReadResult[T] = new ReadResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    id,[0m
[0m[[0m[0mdebug[0m] [0m[0m    source,[0m
[0m[[0m[0mdebug[0m] [0m[0m    version[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For use with testing.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createReadResult[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      id: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      source: T,[0m
[0m[[0m[0mdebug[0m] [0m[0m      version: java.util.Optional[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ReadResult[T] = new ReadResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    id,[0m
[0m[[0m[0mdebug[0m] [0m[0m    source,[0m
[0m[[0m[0mdebug[0m] [0m[0m    version.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWriteResult[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      message: WriteMessage[T, PT],[0m
[0m[[0m[0mdebug[0m] [0m[0m      error: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): WriteResult[T, PT] = new WriteResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    message,[0m
[0m[[0m[0mdebug[0m] [0m[0m    error[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWriteResult[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      message: WriteMessage[T, PT],[0m
[0m[[0m[0mdebug[0m] [0m[0m      error: java.util.Optional[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): WriteResult[T, PT] = new WriteResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    message,[0m
[0m[[0m[0mdebug[0m] [0m[0m    error.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/WriteMessage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] sealed abstract class Operation(val command: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String = command[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] object Operation {[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Index extends Operation("index")[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Create extends Operation("create")[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Update extends Operation("update")[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Upsert extends Operation("update")[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Delete extends Operation("delete")[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class WriteMessage[T, PT] private (val operation: Operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val id: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val source: Option[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val passThrough: PT = NotUsed,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val version: Option[Long] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val indexName: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         val customMetadata: Map[String, java.lang.String] = Map.empty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSource(value: T): WriteMessage[T, PT] = copy(source = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PT2](value: PT2): WriteMessage[T, PT2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage[T, PT2](operation = operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             id = id,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             source = source,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             value,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             version = version,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             indexName = indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             customMetadata = customMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withVersion(value: Long): WriteMessage[T, PT] = copy(version = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withIndexName(value: String): WriteMessage[T, PT] = copy(indexName = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: define custom metadata for this message. Fields should[0m
[0m[[0m[0mdebug[0m] [0m[0m   * have the full metadata field name as key (including the "_" prefix if there is one)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCustomMetadata(value: Map[String, java.lang.String]): WriteMessage[T, PT] = copy(customMetadata = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: define custom metadata for this message. Fields should[0m
[0m[[0m[0mdebug[0m] [0m[0m   * have the full metadata field name as key (including the "_" prefix if there is one)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCustomMetadata(metadata: java.util.Map[String, String]): WriteMessage[T, PT] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this.copy(customMetadata = metadata.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(operation: Operation = operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   id: Option[String] = id,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   source: Option[T] = source,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   passThrough: PT = passThrough,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   version: Option[Long] = version,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   indexName: Option[String] = indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   customMetadata: Map[String, String] = customMetadata): WriteMessage[T, PT] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage[T, PT](operation = operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            id = id,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            source = source,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            passThrough = passThrough,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            version = version,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            indexName = indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            customMetadata = customMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""WriteMessage(operation=$operation,id=$id,source=$source,passThrough=$passThrough,version=$version,indexName=$indexName,customMetadata=$customMetadata)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: WriteMessage[_, _] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.operation, that.operation) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.id, that.id) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.source, that.source) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.passThrough, that.passThrough) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.version, that.version) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.indexName, that.indexName) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.customMetadata, that.customMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    passThrough match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case pt: AnyRef =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        java.util.Objects.hash(operation, id, source, pt, version, indexName, customMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        java.util.Objects.hash(operation, id, source, version, indexName, customMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject WriteMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import Operation._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createIndexMessage[T](source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Index, id = None, source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createIndexMessage[T](id: String, source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Index, id = Option(id), source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createCreateMessage[T](id: String, source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Create, id = Option(id), source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createUpdateMessage[T](id: String, source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Update, id = Option(id), source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createUpsertMessage[T](id: String, source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Upsert, id = Option(id), source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createDeleteMessage[T](id: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Delete, id = Option(id), None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Stream element type emitted by Elasticsearch flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The constructor is INTERNAL API, but you may construct instances for testing by using[0m
[0m[[0m[0mdebug[0m] [0m[0m * [[akka.stream.alpakka.elasticsearch.testkit.MessageFactory]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class WriteResult[T2, C2] @InternalApi private[elasticsearch] (val message: WriteMessage[T2, C2],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     /** JSON structure of the Elasticsearch error. */[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val error: Option[String]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val success: Boolean = error.isEmpty[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: JSON structure of the Elasticsearch error. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getError: java.util.Optional[String] = error.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** `reason` field value of the Elasticsearch error. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def errorReason: Option[String] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import spray.json._[0m
[0m[[0m[0mdebug[0m] [0m[0m    error.flatMap(_.parseJson.asJsObject.fields.get("reason").map(_.asInstanceOf[JsString].value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: `reason` field value from the Elasticsearch error */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getErrorReason: java.util.Optional[String] = errorReason.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""WriteResult(message=$message,error=$error)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: WriteResult[T2, C2] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.message, that.message) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.error, that.error)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    java.util.Objects.hash(message, error)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait MessageWriter[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def convert(message: T): String[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/ElasticsearchWriteSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait RetryLogic {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def shouldRetry(retries: Int, errors: immutable.Seq[String]): Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  def nextRetry(retries: Int): FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject RetryNever extends RetryLogic {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shouldRetry(retries: Int, errors: immutable.Seq[String]): Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def nextRetry(retries: Int): FiniteDuration = Duration.Zero[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Note: If using retries, you will receive[0m
[0m[[0m[0mdebug[0m] [0m[0m * messages out of order downstream in cases where[0m
[0m[[0m[0mdebug[0m] [0m[0m * elastic returns error one some of the documents in a[0m
[0m[[0m[0mdebug[0m] [0m[0m * bulk request.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class RetryAtFixedRate private (maxRetries: Int, retryInterval: scala.concurrent.duration.FiniteDuration)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends RetryLogic {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shouldRetry(retries: Int, errors: immutable.Seq[String]): Boolean = retries < maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def nextRetry(retries: Int): FiniteDuration = retryInterval[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject RetryAtFixedRate {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(maxRetries: Int, retryInterval: scala.concurrent.duration.FiniteDuration): RetryAtFixedRate =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RetryAtFixedRate(maxRetries, retryInterval)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(maxRetries: Int, retryInterval: java.time.Duration): RetryAtFixedRate =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RetryAtFixedRate(maxRetries, retryInterval.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Configure Elasticsearch sinks and flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ElasticsearchWriteSettings private (val bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                val retryLogic: RetryLogic,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                val versionType: Option[String]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBufferSize(value: Int): ElasticsearchWriteSettings = copy(bufferSize = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withRetryLogic(value: RetryLogic): ElasticsearchWriteSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(retryLogic = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withVersionType(value: String): ElasticsearchWriteSettings = copy(versionType = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bufferSize: Int = bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   retryLogic: RetryLogic = retryLogic,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   versionType: Option[String] = versionType): ElasticsearchWriteSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ElasticsearchWriteSettings(bufferSize = bufferSize, retryLogic = retryLogic, versionType = versionType)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"ElasticsearchUpdateSettings(bufferSize=$bufferSize,retryLogic=$retryLogic,versionType=$versionType)"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchWriteSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Default = new ElasticsearchWriteSettings(bufferSize = 10, retryLogic = RetryNever, versionType = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): ElasticsearchWriteSettings = Default[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): ElasticsearchWriteSettings = Default[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/ElasticsearchSourceSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Configure Elastiscsearch sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ElasticsearchSourceSettings private (val bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 val includeDocumentVersion: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 val scrollDuration: FiniteDuration) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBufferSize(value: Int): ElasticsearchSourceSettings = copy(bufferSize = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withScrollDuration(value: FiniteDuration): ElasticsearchSourceSettings = copy(scrollDuration = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withScrollDuration(value: java.time.Duration): ElasticsearchSourceSettings = copy(scrollDuration = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If includeDocumentVersion is true, '_version' is returned with the search-results[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  * http://nocf-www.elastic.co/guide/en/elasticsearch/reference/current/search-request-version.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  * https://www.elastic.co/guide/en/elasticsearch/guide/current/optimistic-concurrency-control.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withIncludeDocumentVersion(value: Boolean): ElasticsearchSourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (includeDocumentVersion == value) this else copy(includeDocumentVersion = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bufferSize: Int = bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   includeDocumentVersion: Boolean = includeDocumentVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   scrollDuration: FiniteDuration = scrollDuration): ElasticsearchSourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ElasticsearchSourceSettings(bufferSize = bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    includeDocumentVersion = includeDocumentVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    scrollDuration = scrollDuration)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def scroll: String = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scrollString = scrollDuration.unit match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.DAYS => "d"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.HOURS => "h"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.MINUTES => "m"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.SECONDS => "s"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.MILLISECONDS => "ms"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.MICROSECONDS => "micros"[0m
[0m[[0m[0mdebug[0m] [0m[0m      case TimeUnit.NANOSECONDS => "nanos"[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"${scrollDuration.length}$scrollString"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""ElasticsearchSourceSettings(bufferSize=$bufferSize,includeDocumentVersion=$includeDocumentVersion,scrollDuration=$scrollDuration)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchSourceSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Default = new ElasticsearchSourceSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferSize = 10,[0m
[0m[[0m[0mdebug[0m] [0m[0m    includeDocumentVersion = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    scrollDuration = FiniteDuration(5, TimeUnit.MINUTES)[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): ElasticsearchSourceSettings = Default[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): ElasticsearchSourceSettings = Default[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/scaladsl/ElasticsearchSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API to create Elasticsearch sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   * of Spray's [[spray.json.JsObject]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Alias of [[create]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: ElasticsearchSourceSettings = ElasticsearchSourceSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[JsObject], NotUsed] = create(indexName, typeName, query, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   * of Spray's [[spray.json.JsObject]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Alias of [[create]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Example of searchParams-usage:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""" )[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""", "_source" -> """ ["fieldToInclude", "anotherFieldToInclude"] """ )[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m            typeName: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m            searchParams: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m            settings: ElasticsearchSourceSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[JsObject], NotUsed] = create(indexName, typeName, searchParams, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   * of Spray's [[spray.json.JsObject]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             settings: ElasticsearchSourceSettings = ElasticsearchSourceSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[JsObject], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    create(indexName, Option(typeName), query, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   * of Spray's [[spray.json.JsObject]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String, typeName: Option[String], query: String, settings: ElasticsearchSourceSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[JsObject], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    create(indexName, typeName, Map("query" -> query), settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   * of Spray's [[spray.json.JsObject]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Example of searchParams-usage:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""" )[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""", "_source" -> """ ["fieldToInclude", "anotherFieldToInclude"] """ )[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             typeName: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             searchParams: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             settings: ElasticsearchSourceSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[JsObject], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage([0m
[0m[[0m[0mdebug[0m] [0m[0m        indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        searchParams,[0m
[0m[[0m[0mdebug[0m] [0m[0m        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new SprayJsonReader[JsObject]()(DefaultJsonProtocol.RootJsObjectFormat)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * converted by Spray's [[spray.json.JsonReader]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               query: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               settings: ElasticsearchSourceSettings = ElasticsearchSourceSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      reader: JsonReader[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    typed(indexName, Option(typeName), query, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * converted by Spray's [[spray.json.JsonReader]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String, typeName: Option[String], query: String, settings: ElasticsearchSourceSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonReader: JsonReader[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    typed(indexName, typeName, Map("query" -> query), settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a [[akka.stream.scaladsl.Source]] from Elasticsearch that streams [[ReadResult]]s of type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * converted by Spray's [[spray.json.JsonReader]][0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Example of searchParams-usage:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""" )[0m
[0m[[0m[0mdebug[0m] [0m[0m   *  Map( "query" -> """{"match_all": {}}""", "_source" -> """ ["fieldToInclude", "anotherFieldToInclude"] """ )[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typed[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               typeName: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m               searchParams: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m               settings: ElasticsearchSourceSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonReader: JsonReader[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ReadResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new impl.ElasticsearchSourceStage(indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        searchParams,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        new SprayJsonReader[T]()(sprayJsonReader))[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private final class SprayJsonReader[T](implicit reader: JsonReader[T]) extends impl.MessageReader[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def convert(json: String): impl.ScrollResponse[T] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val jsObj = json.parseJson.asJsObject[0m
[0m[[0m[0mdebug[0m] [0m[0m      jsObj.fields.get("error") match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Some(error) => {[0m
[0m[[0m[0mdebug[0m] [0m[0m          impl.ScrollResponse(Some(error.toString), None)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case None => {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val scrollId = jsObj.fields("_scroll_id").asInstanceOf[JsString].value[0m
[0m[[0m[0mdebug[0m] [0m[0m          val hits = jsObj.fields("hits").asJsObject.fields("hits").asInstanceOf[JsArray][0m
[0m[[0m[0mdebug[0m] [0m[0m          val messages = hits.elements.reverse.map { element =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val doc = element.asJsObject[0m
[0m[[0m[0mdebug[0m] [0m[0m            val id = doc.fields("_id").asInstanceOf[JsString].value[0m
[0m[[0m[0mdebug[0m] [0m[0m            val source = doc.fields("_source").asJsObject[0m
[0m[[0m[0mdebug[0m] [0m[0m            // Maybe we got the _version-property[0m
[0m[[0m[0mdebug[0m] [0m[0m            val version: Option[Long] = doc.fields.get("_version").map(_.asInstanceOf[JsNumber].value.toLong)[0m
[0m[[0m[0mdebug[0m] [0m[0m            new ReadResult(id, source.convertTo[T], version)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          impl.ScrollResponse(None, Some(impl.ScrollResult(scrollId, messages)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/scaladsl/ElasticsearchSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json.JsonWriter[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API to create Elasticsearch sinks.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                settings: ElasticsearchWriteSettings = ElasticsearchWriteSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonWriter: JsonWriter[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[WriteMessage[T, NotUsed], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ElasticsearchFlow.create[T](indexName, typeName, settings).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/scaladsl/ElasticsearchFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API to create Elasticsearch flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ElasticsearchFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is port of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This factory method requires an implicit Spray JSON writer for `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                settings: ElasticsearchWriteSettings = ElasticsearchWriteSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonWriter: JsonWriter[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[WriteMessage[T, NotUsed], WriteResult[T, NotUsed], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    create[T](indexName, typeName, settings, new SprayJsonWriter[T]()(sprayJsonWriter))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is port of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](indexName: String, typeName: String, settings: ElasticsearchWriteSettings, writer: MessageWriter[T])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[WriteMessage[T, NotUsed], WriteResult[T, NotUsed], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[WriteMessage[T, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .batch(settings.bufferSize, immutable.Seq(_)) { case (seq, wm) => seq :+ wm }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        new impl.ElasticsearchFlowStage[T, NotUsed]([0m
[0m[[0m[0mdebug[0m] [0m[0m          indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m          typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m          elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          writer[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `passThrough` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This factory method requires an implicit Spray JSON writer for `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithPassThrough[T, C](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  settings: ElasticsearchWriteSettings = ElasticsearchWriteSettings.Default)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonWriter: JsonWriter[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[WriteMessage[T, C], WriteResult[T, C], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    createWithPassThrough[T, C](indexName, typeName, settings, new SprayJsonWriter[T]()(sprayJsonWriter))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `passThrough` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Warning: When settings configure retrying, messages are emitted out-of-order when errors are detected.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithPassThrough[T, C](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  writer: MessageWriter[T])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[WriteMessage[T, C], WriteResult[T, C], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[WriteMessage[T, C]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .batch(settings.bufferSize, immutable.Seq(_)) { case (seq, wm) => seq :+ wm }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        new impl.ElasticsearchFlowStage[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m          indexName,[0m
[0m[[0m[0mdebug[0m] [0m[0m          typeName,[0m
[0m[[0m[0mdebug[0m] [0m[0m          elasticsearchClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          writer[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `context` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This factory method requires an implicit Spray JSON writer for `T`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @throws IllegalArgumentException When settings configure retrying.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithContext[T, C](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              settings: ElasticsearchWriteSettings = ElasticsearchWriteSettings())([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sprayJsonWriter: JsonWriter[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[(WriteMessage[T, NotUsed], C), (WriteResult[T, C], C), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    createWithContext[T, C](indexName, typeName, settings, new SprayJsonWriter[T]()(sprayJsonWriter))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update Elasticsearch with [[akka.stream.alpakka.elasticsearch.WriteMessage WriteMessage]]s containing type `T`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * with `context` of type `C`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The result status is part of the [[akka.stream.alpakka.elasticsearch.WriteResult WriteResult]] and must be checked for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * successful execution.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @throws IllegalArgumentException When settings configure retrying.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWithContext[T, C](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              writer: MessageWriter[T])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit elasticsearchClient: RestClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[(WriteMessage[T, NotUsed], C), (WriteResult[T, C], C), NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    require(settings.retryLogic == RetryNever,[0m
[0m[[0m[0mdebug[0m] [0m[0m            "`withContext` may not be used with retrying enabled, as it disturbs element order")[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[(WriteMessage[T, NotUsed], C)][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (wm, pt) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          wm.withPassThrough(pt)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(createWithPassThrough(indexName, typeName, settings, writer))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { wr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        (wr, wr.message.passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private final class SprayJsonWriter[T](implicit writer: JsonWriter[T]) extends MessageWriter[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def convert(message: T): String = message.toJson.toString()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/impl/ElasticsearchFlowStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.StandardCharsets[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.Operation._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.impl.ElasticsearchFlowStage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.http.entity.StringEntity[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.http.message.BasicHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.http.util.EntityUtils[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.{Response, ResponseListener, RestClient}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] final class ElasticsearchFlowStage[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m    indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    typeName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    client: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m    settings: ElasticsearchWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    writer: MessageWriter[T][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStage[FlowShape[immutable.Seq[WriteMessage[T, C]], immutable.Seq[WriteResult[T, C]]]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(indexName != null, "You must define an index name")[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(typeName != null, "You must define a type name")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[immutable.Seq[WriteMessage[T, C]]]("messages")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[immutable.Seq[WriteResult[T, C]]]("result")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = new StageLogic()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private class StageLogic extends TimerGraphStageLogic(shape) with InHandler with OutHandler with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private val typeNameTuple = "_type" -> JsString(typeName)[0m
[0m[[0m[0mdebug[0m] [0m[0m    private val versionTypeTuple: Option[(String, JsString)] = settings.versionType.map { versionType =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      "version_type" -> JsString(versionType)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private var upstreamFinished = false[0m
[0m[[0m[0mdebug[0m] [0m[0m    private var inflight = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private val failureHandler = getAsyncCallback[(immutable.Seq[WriteMessage[T, C]], Throwable)](handleFailure)[0m
[0m[[0m[0mdebug[0m] [0m[0m    private val responseHandler = getAsyncCallback[(immutable.Seq[WriteMessage[T, C]], Response)](handleResponse)[0m
[0m[[0m[0mdebug[0m] [0m[0m    private var failedMessages: immutable.Seq[WriteMessage[T, C]] = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m    private var retryCount: Int = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def tryPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!isClosed(in) && !hasBeenPulled(in)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onTimer(timerKey: Any): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (log.isDebugEnabled) log.debug("retrying inflight={} {}", inflight, failedMessages)[0m
[0m[[0m[0mdebug[0m] [0m[0m      sendBulkUpdateRequest(failedMessages)[0m
[0m[[0m[0mdebug[0m] [0m[0m      failedMessages = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def handleFailure(args: (immutable.Seq[WriteMessage[T, C]], Throwable)): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val (messages, exception) = args[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!settings.retryLogic.shouldRetry(retryCount, List(exception.toString))) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.error("Received error from elastic. Giving up after {} tries. {}, Error: {}",[0m
[0m[[0m[0mdebug[0m] [0m[0m                  retryCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  settings.retryLogic,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m        failStage(exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.warning("Received error from elastic. Try number {}. {}, Error: {}",[0m
[0m[[0m[0mdebug[0m] [0m[0m                    retryCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    settings.retryLogic,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m        retryCount = retryCount + 1[0m
[0m[[0m[0mdebug[0m] [0m[0m        failedMessages = messages[0m
[0m[[0m[0mdebug[0m] [0m[0m        scheduleOnce(RetrySend, settings.retryLogic.nextRetry(retryCount))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def handleResponse(args: (immutable.Seq[WriteMessage[T, C]], Response)): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val (messages, response) = args[0m
[0m[[0m[0mdebug[0m] [0m[0m      val responseJson = EntityUtils.toString(response.getEntity).parseJson[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (log.isDebugEnabled) log.debug("response {}", responseJson.prettyPrint)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // If some commands in bulk request failed, pass failed messages to follows.[0m
[0m[[0m[0mdebug[0m] [0m[0m      val items = responseJson.asJsObject.fields("items").asInstanceOf[JsArray][0m
[0m[[0m[0mdebug[0m] [0m[0m      val messageResults: immutable.Seq[WriteResult[T, C]] = items.elements.zip(messages).map {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (item, message) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val command = message.operation.command[0m
[0m[[0m[0mdebug[0m] [0m[0m          val res = item.asJsObject.fields(command).asJsObject[0m
[0m[[0m[0mdebug[0m] [0m[0m          val error: Option[String] = res.fields.get("error").map(_.toString())[0m
[0m[[0m[0mdebug[0m] [0m[0m          new WriteResult(message, error)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val failedMsgs = messageResults.filterNot(_.error.isEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (failedMsgs.nonEmpty && settings.retryLogic.shouldRetry(retryCount, failedMsgs.map(_.error.get).toList)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        retryPartialFailedMessages(messageResults, failedMsgs)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        retryCount = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m        emitResults(messageResults)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def retryPartialFailedMessages([0m
[0m[[0m[0mdebug[0m] [0m[0m        messageResults: immutable.Seq[WriteResult[T, C]],[0m
[0m[[0m[0mdebug[0m] [0m[0m        failedMsgs: immutable.Seq[WriteResult[T, C]][0m
[0m[[0m[0mdebug[0m] [0m[0m    ): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (log.isDebugEnabled) log.debug("retryPartialFailedMessages inflight={} {}", inflight, failedMsgs)[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Retry partial failed messages[0m
[0m[[0m[0mdebug[0m] [0m[0m      // NOTE: When we partially return message like this, message will arrive out of order downstream[0m
[0m[[0m[0mdebug[0m] [0m[0m      // and it can break commit-logic when using Kafka[0m
[0m[[0m[0mdebug[0m] [0m[0m      retryCount = retryCount + 1[0m
[0m[[0m[0mdebug[0m] [0m[0m      failedMessages = failedMsgs.map(_.message) // These are the messages we're going to retry[0m
[0m[[0m[0mdebug[0m] [0m[0m      scheduleOnce(RetrySend, settings.retryLogic.nextRetry(retryCount))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val successMsgs = messageResults.filter(_.error.isEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (successMsgs.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // push the messages that DID succeed[0m
[0m[[0m[0mdebug[0m] [0m[0m        emitResults(successMsgs)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def emitResults(successMsgs: immutable.Seq[WriteResult[T, C]]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      emit(out, successMsgs)[0m
[0m[[0m[0mdebug[0m] [0m[0m      tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m      inflight -= successMsgs.size[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (upstreamFinished && inflight == 0) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def sendBulkUpdateRequest(messages: immutable.Seq[WriteMessage[T, C]]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val json = messages[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val sharedFields: Seq[(String, JsString)] = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m            "_index" -> JsString(message.indexName.getOrElse(indexName)),[0m
[0m[[0m[0mdebug[0m] [0m[0m            typeNameTuple[0m
[0m[[0m[0mdebug[0m] [0m[0m          ) ++ message.customMetadata.map { case (field, value) => field -> JsString(value) }[0m
[0m[[0m[0mdebug[0m] [0m[0m          val tuple: (String, JsObject) = message.operation match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Index =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val fields = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m                message.version.map { version =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  "_version" -> JsNumber(version)[0m
[0m[[0m[0mdebug[0m] [0m[0m                },[0m
[0m[[0m[0mdebug[0m] [0m[0m                versionTypeTuple,[0m
[0m[[0m[0mdebug[0m] [0m[0m                message.id.map { id =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  "_id" -> JsString(id)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              ).flatten[0m
[0m[[0m[0mdebug[0m] [0m[0m              "index" -> JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m                (sharedFields ++ fields): _*[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Create =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val fields = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m                message.id.map { id =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  "_id" -> JsString(id)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              ).flatten[0m
[0m[[0m[0mdebug[0m] [0m[0m              "create" -> JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m                (sharedFields ++ fields): _*[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Update | Upsert =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val fields = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m                message.version.map { version =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  "_version" -> JsNumber(version)[0m
[0m[[0m[0mdebug[0m] [0m[0m                },[0m
[0m[[0m[0mdebug[0m] [0m[0m                versionTypeTuple,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Option("_id" -> JsString(message.id.get))[0m
[0m[[0m[0mdebug[0m] [0m[0m              ).flatten[0m
[0m[[0m[0mdebug[0m] [0m[0m              "update" -> JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m                (sharedFields ++ fields): _*[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Delete =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val fields = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m                message.version.map { version =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  "_version" -> JsNumber(version)[0m
[0m[[0m[0mdebug[0m] [0m[0m                },[0m
[0m[[0m[0mdebug[0m] [0m[0m                versionTypeTuple,[0m
[0m[[0m[0mdebug[0m] [0m[0m                Option("_id" -> JsString(message.id.get))[0m
[0m[[0m[0mdebug[0m] [0m[0m              ).flatten[0m
[0m[[0m[0mdebug[0m] [0m[0m              "delete" -> JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m                (sharedFields ++ fields): _*[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          JsObject(tuple).compactPrint + messageToJsonString(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mkString("", "\n", "\n")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.debug("Posting data to Elasticsearch: {}", json)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      client.performRequestAsync([0m
[0m[[0m[0mdebug[0m] [0m[0m        "POST",[0m
[0m[[0m[0mdebug[0m] [0m[0m        "/_bulk",[0m
[0m[[0m[0mdebug[0m] [0m[0m        java.util.Collections.emptyMap[String, String](),[0m
[0m[[0m[0mdebug[0m] [0m[0m        new StringEntity(json, StandardCharsets.UTF_8),[0m
[0m[[0m[0mdebug[0m] [0m[0m        new ResponseListener() {[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onFailure(exception: Exception): Unit = failureHandler.invoke((messages, exception))[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onSuccess(response: Response): Unit = responseHandler.invoke((messages, response))[0m
[0m[[0m[0mdebug[0m] [0m[0m        },[0m
[0m[[0m[0mdebug[0m] [0m[0m        new BasicHeader("Content-Type", "application/x-ndjson")[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def messageToJsonString(message: WriteMessage[T, C]): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m      message.operation match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Index | Create =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          "\n" + writer.convert(message.source.get)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Upsert =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          "\n" + JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m            "doc" -> writer.convert(message.source.get).parseJson,[0m
[0m[[0m[0mdebug[0m] [0m[0m            "doc_as_upsert" -> JsTrue[0m
[0m[[0m[0mdebug[0m] [0m[0m          ).toString[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Update =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          "\n" + JsObject([0m
[0m[[0m[0mdebug[0m] [0m[0m            "doc" -> writer.convert(message.source.get).parseJson[0m
[0m[[0m[0mdebug[0m] [0m[0m          ).toString[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Delete =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          ""[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit = tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val messages = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      inflight += messages.size[0m
[0m[[0m[0mdebug[0m] [0m[0m      sendBulkUpdateRequest(messages)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (inflight == 0) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      else upstreamFinished = true[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] object ElasticsearchFlowStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private object RetrySend[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/elasticsearch/src/main/scala/akka/stream/alpakka/elasticsearch/impl/ElasticsearchSourceStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.elasticsearch.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.ByteArrayOutputStream[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.elasticsearch.{ElasticsearchSourceSettings, ReadResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, OutHandler, StageLogging}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.http.entity.StringEntity[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.http.message.BasicHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.elasticsearch.client.{Response, ResponseListener, RestClient}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json.DefaultJsonProtocol._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport spray.json._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] case class ScrollResponse[T](error: Option[String], result: Option[ScrollResult[T]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] case class ScrollResult[T](scrollId: String, messages: Seq[ReadResult[T]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] trait MessageReader[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def convert(json: String): ScrollResponse[T][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] final class ElasticsearchSourceStage[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               typeName: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               searchParams: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               client: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               reader: MessageReader[T])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[SourceShape[ReadResult[T]]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(indexName != null, "You must define an index name")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ReadResult[T]] = Outlet("ElasticsearchSource.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: SourceShape[ReadResult[T]] = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ElasticsearchSourceLogic[T](indexName, typeName, searchParams, client, settings, out, shape, reader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[elasticsearch] final class ElasticsearchSourceLogic[T](indexName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               typeName: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               searchParams: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               client: RestClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               settings: ElasticsearchSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               out: Outlet[ReadResult[T]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               shape: SourceShape[ReadResult[T]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                               reader: MessageReader[T])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageLogic(shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with ResponseListener[0m
[0m[[0m[0mdebug[0m] [0m[0m    with OutHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m    with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var scrollId: String = null[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val responseHandler = getAsyncCallback[Response](handleResponse)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val failureHandler = getAsyncCallback[Throwable](handleFailure)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var waitingForElasticData = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var pullIsWaitingForData = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var dataReady: Option[ScrollResponse[T]] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sendScrollScanRequest(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    try {[0m
[0m[[0m[0mdebug[0m] [0m[0m      waitingForElasticData = true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (scrollId == null) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.debug("Doing initial search")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        // Add extra params to search[0m
[0m[[0m[0mdebug[0m] [0m[0m        val extraParams = Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m          if (!searchParams.contains("size")) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            Some(("size" -> settings.bufferSize.toString))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            None[0m
[0m[[0m[0mdebug[0m] [0m[0m          },[0m
[0m[[0m[0mdebug[0m] [0m[0m          // Tell elastic to return the documents '_version'-property with the search-results[0m
[0m[[0m[0mdebug[0m] [0m[0m          // http://nocf-www.elastic.co/guide/en/elasticsearch/reference/current/search-request-version.html[0m
[0m[[0m[0mdebug[0m] [0m[0m          // https://www.elastic.co/guide/en/elasticsearch/guide/current/optimistic-concurrency-control.html[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (!searchParams.contains("version") && settings.includeDocumentVersion) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            Some(("version" -> "true"))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            None[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val completeParams = searchParams ++ extraParams.flatten[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val searchBody = "{" + completeParams[0m
[0m[[0m[0mdebug[0m] [0m[0m          .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (name, json) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              "\"" + name + "\":" + json[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mkString(",") + "}"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val endpoint: String = (indexName, typeName) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (i, Some(t)) => s"/$i/$t/_search"[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (i, None) => s"/$i/_search"[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        client.performRequestAsync([0m
[0m[[0m[0mdebug[0m] [0m[0m          "POST",[0m
[0m[[0m[0mdebug[0m] [0m[0m          endpoint,[0m
[0m[[0m[0mdebug[0m] [0m[0m          Map("scroll" -> settings.scroll, "sort" -> "_doc").asJava,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new StringEntity(searchBody),[0m
[0m[[0m[0mdebug[0m] [0m[0m          this,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new BasicHeader("Content-Type", "application/json")[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.debug("Fetching next scroll")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        client.performRequestAsync([0m
[0m[[0m[0mdebug[0m] [0m[0m          "POST",[0m
[0m[[0m[0mdebug[0m] [0m[0m          s"/_search/scroll",[0m
[0m[[0m[0mdebug[0m] [0m[0m          Map[String, String]().asJava,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new StringEntity(Map("scroll" -> settings.scroll, "scroll_id" -> scrollId).toJson.toString),[0m
[0m[[0m[0mdebug[0m] [0m[0m          this,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new BasicHeader("Content-Type", "application/json")[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ex: Exception => handleFailure(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onFailure(exception: Exception) = failureHandler.invoke(exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onSuccess(response: Response) = responseHandler.invoke(response)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def handleFailure(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    waitingForElasticData = false[0m
[0m[[0m[0mdebug[0m] [0m[0m    failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def handleResponse(res: Response): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    waitingForElasticData = false[0m
[0m[[0m[0mdebug[0m] [0m[0m    val json = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val out = new ByteArrayOutputStream()[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        res.getEntity.writeTo(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m        new String(out.toByteArray, "UTF-8")[0m
[0m[[0m[0mdebug[0m] [0m[0m      } finally {[0m
[0m[[0m[0mdebug[0m] [0m[0m        out.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scrollResponse = reader.convert(json)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (pullIsWaitingForData) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.debug("Received data from elastic. Downstream has already called pull and is waiting for data")[0m
[0m[[0m[0mdebug[0m] [0m[0m      pullIsWaitingForData = false[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (handleScrollResponse(scrollResponse)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // we should go and get more data[0m
[0m[[0m[0mdebug[0m] [0m[0m        sendScrollScanRequest()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.debug("Received data from elastic. Downstream have not yet asked for it")[0m
[0m[[0m[0mdebug[0m] [0m[0m      // This is a prefetch of data which we received before downstream has asked for it[0m
[0m[[0m[0mdebug[0m] [0m[0m      dataReady = Some(scrollResponse)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Returns true if we should continue to work[0m
[0m[[0m[0mdebug[0m] [0m[0m  def handleScrollResponse(scrollResponse: ScrollResponse[T]): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scrollResponse match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ScrollResponse(Some(error), _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        failStage(new IllegalStateException(error))[0m
[0m[[0m[0mdebug[0m] [0m[0m        false[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ScrollResponse(None, Some(result)) if result.messages.isEmpty =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        false[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ScrollResponse(_, Some(result)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        scrollId = result.scrollId[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.debug("Pushing data downstream")[0m
[0m[[0m[0mdebug[0m] [0m[0m        emitMultiple(out, result.messages.toIterator)[0m
[0m[[0m[0mdebug[0m] [0m[0m        true[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler(out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    dataReady match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(data) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        // We already have data ready[0m
[0m[[0m[0mdebug[0m] [0m[0m        log.debug("Downstream is pulling data and we already have data ready")[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (handleScrollResponse(data)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          // We should go and get more data[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          dataReady = None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (!waitingForElasticData) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            sendScrollScanRequest()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (pullIsWaitingForData) throw new Exception("This should not happen: Downstream is pulling more than once")[0m
[0m[[0m[0mdebug[0m] [0m[0m        pullIsWaitingForData = true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!waitingForElasticData) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.debug("Downstream is pulling data. We must go and get it")[0m
[0m[[0m[0mdebug[0m] [0m[0m          sendScrollScanRequest()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.debug("Downstream is pulling data. Already waiting for data")[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
