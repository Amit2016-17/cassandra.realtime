[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/javadsl/MqttSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT source factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttSourceSettings, bufferSize: Int): Source[MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atMostOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int): Source[MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MqttSource[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atMostOnce(settings, subscriptions, bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use atLeastOnce with MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atLeastOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(settings: MqttSourceSettings, bufferSize: Int): Source[MqttMessageWithAck, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  bufferSize: Int): Source[MqttMessageWithAck, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MqttSource[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atLeastOnce(settings, subscriptions, bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(MqttMessageWithAck.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/javadsl/MqttFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT flow factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use atMostOnce() instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(sourceSettings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m             defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atMostOnce(sourceSettings.connectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m               MqttSubscriptions(sourceSettings.subscriptions),[0m
[0m[[0m[0mdebug[0m] [0m[0m               bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m               defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use atMostOnce() instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atMostOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MqttFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atMostOnce(settings, subscriptions, bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use atLeastOnce with MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atLeastOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      defaultQos: MqttQoS[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[MqttMessage, MqttMessageWithAck, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      defaultQos: MqttQoS[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[MqttMessage, MqttMessageWithAck, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MqttFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atLeastOnce(settings, subscriptions, bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(MqttMessageWithAck.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/javadsl/MqttSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT sink factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink sending messages to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on stream completion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(connectionSettings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             defaultQos: MqttQoS): Sink[MqttMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MqttFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atMostOnce(connectionSettings, MqttSubscriptions.empty, bufferSize = 0, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore[MqttMessage], Keep.right[CompletionStage[Done], CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/javadsl/MqttMessageWithAck.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.MqttMessage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT Message and a handle to acknowledge message reception to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait MqttMessageWithAck {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The message received from MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val message: MqttMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use commit instead, since 0.21[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use ack() instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def messageArrivedComplete(): CompletionStage[Done] = ack()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Signals `messageArrivedComplete` to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return completion indicating, if the acknowledge reached MQTT[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ack(): CompletionStage[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[javadsl] object MqttMessageWithAck {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toJava(cm: scaladsl.MqttMessageWithAck): MqttMessageWithAck = new MqttMessageWithAck {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override val message: MqttMessage = cm.message[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def ack(): CompletionStage[Done] = cm.ack().toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/settings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.eclipse.paho.client.mqttv3.{MqttClientPersistence, MqttConnectOptions}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Map[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.{FiniteDuration, _}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Quality of Service constants as defined in[0m
[0m[[0m[0mdebug[0m] [0m[0m *[[http://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttMessage.html#setQos-int-]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class MqttQoS {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def value: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Quality of Service constants as defined in[0m
[0m[[0m[0mdebug[0m] [0m[0m * [[http://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttMessage.html#setQos-int-]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttQoS {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 0 - indicates that a message should be delivered at most once (zero or one times). The message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * will not be persisted to disk, and will not be acknowledged across the network. This QoS is the fastest, but should[0m
[0m[[0m[0mdebug[0m] [0m[0m   * only be used for messages which are not valuable.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  object AtMostOnce extends MqttQoS {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val value: Int = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 1 - indicates that a message should be delivered at least once (one or more times). The message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * can only be delivered safely if it can be persisted, so the application must supply a means of persistence using[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[MqttConnectionSettings]]. If a persistence mechanism is not specified, the message will not be delivered in the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * event of a client failure. The message will be acknowledged across the network.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  object AtLeastOnce extends MqttQoS {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val value: Int = 1[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 2 - indicates that a message should be delivered once. The message will be persisted to disk,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and will be subject to a two-phase acknowledgement across the network. The message can only be delivered safely[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if it can be persisted, so the application must supply a means of persistence using [[MqttConnectionSettings]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If a persistence mechanism is not specified, the message will not be delivered in the event of a client failure.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  object ExactlyOnce extends MqttQoS {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val value: Int = 2[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 0 - indicates that a message should be delivered at most once (zero or one times). The message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * will not be persisted to disk, and will not be acknowledged across the network. This QoS is the fastest, but should[0m
[0m[[0m[0mdebug[0m] [0m[0m   * only be used for messages which are not valuable.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce: MqttQoS = AtMostOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 1 - indicates that a message should be delivered at least once (one or more times). The message[0m
[0m[[0m[0mdebug[0m] [0m[0m   * can only be delivered safely if it can be persisted, so the application must supply a means of persistence using[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[MqttConnectionSettings]]. If a persistence mechanism is not specified, the message will not be delivered in the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * event of a client failure. The message will be acknowledged across the network.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce: MqttQoS = AtLeastOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Quality of Service 2 - indicates that a message should be delivered once. The message will be persisted to disk,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and will be subject to a two-phase acknowledgement across the network. The message can only be delivered safely[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if it can be persisted, so the application must supply a means of persistence using [[MqttConnectionSettings]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If a persistence mechanism is not specified, the message will not be delivered in the event of a client failure.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def exactlyOnce: MqttQoS = ExactlyOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * The mapping of topics to subscribe to and the requested Quality of Service ([[MqttQoS]]) per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MqttSubscriptions private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val subscriptions: Map[String, MqttQoS][0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSubscriptions(subscriptions: Map[String, MqttQoS]): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(subscriptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSubscriptions(subscriptions: java.util.List[akka.japi.Pair[String, MqttQoS]]): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(subscriptions.asScala.map(_.toScala).toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Add this subscription to the map of subscriptions configured already. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def addSubscription(topic: String, qos: MqttQoS): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(this.subscriptions.updated(topic, qos))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * The mapping of topics to subscribe to and the requested Quality of Service ([[MqttQoS]]) per topic.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSubscriptions {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val empty = new MqttSubscriptions(Map.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(subscriptions: Map[String, MqttQoS]): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(subscriptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(topic: String, qos: MqttQoS): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(Map(topic -> qos))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(subscription: (String, MqttQoS)): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(Map(subscription))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(subscriptions: java.util.List[akka.japi.Pair[String, MqttQoS]]): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(subscriptions.asScala.map(_.toScala).toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(topic: String, qos: MqttQoS): MqttSubscriptions =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttSubscriptions(Map(topic -> qos))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param subscriptions the mapping between a topic name and a [[MqttQoS]].[0m
[0m[[0m[0mdebug[0m] [0m[0m * @deprecated use MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@deprecated("use MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m@java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class MqttSourceSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    subscriptions: Map[String, MqttQoS] = Map.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @annotation.varargs[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSubscriptions(subscriptions: akka.japi.Pair[String, MqttQoS]*) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(subscriptions = subscriptions.map(_.toScala).toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * @deprecated use MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@deprecated("use MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m@java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSourceSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[MqttSourceSettings]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use MqttConnectionSettings and MqttSubscriptions instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(connectionSettings: MqttConnectionSettings) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MqttSourceSettings(connectionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[mqtt] final case class MqttOfflinePersistenceSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferSize: Int = 5000,[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteOldestMessage: Boolean = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    persistBuffer: Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Connection settings passed to the underlying Paho client.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * See [[https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttConnectOptions.html]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MqttConnectionSettings private (val broker: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val persistence: org.eclipse.paho.client.mqttv3.MqttClientPersistence,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val auth: Option[(String, String)],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val socketFactory: Option[javax.net.ssl.SSLSocketFactory],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val cleanSession: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val will: Option[MqttMessage],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val automaticReconnect: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val keepAliveInterval: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val connectionTimeout: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val disconnectQuiesceTimeout: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val disconnectTimeout: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val maxInFlight: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val mqttVersion: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val serverUris: immutable.Seq[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val sslHostnameVerifier: Option[javax.net.ssl.HostnameVerifier],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val sslProperties: Map[String, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val offlinePersistenceSettings: Option[MqttOfflinePersistenceSettings] =[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              None) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBroker(value: String): MqttConnectionSettings = copy(broker = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withClientId(clientId: String): MqttConnectionSettings = copy(clientId = clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPersistence(value: org.eclipse.paho.client.mqttv3.MqttClientPersistence): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(persistence = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAuth(username: String, password: String): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(auth = Some((username, password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSocketFactory(value: javax.net.ssl.SSLSocketFactory): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(socketFactory = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCleanSession(value: Boolean): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (cleanSession == value) this else copy(cleanSession = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withWill(value: MqttMessage): MqttConnectionSettings = copy(will = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAutomaticReconnect(value: Boolean): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (automaticReconnect == value) this else copy(automaticReconnect = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKeepAliveInterval(value: FiniteDuration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(keepAliveInterval = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKeepAliveInterval(value: java.time.Duration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    withKeepAliveInterval([0m
[0m[[0m[0mdebug[0m] [0m[0m      value.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionTimeout(value: FiniteDuration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectionTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionTimeout(value: java.time.Duration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    withConnectionTimeout([0m
[0m[[0m[0mdebug[0m] [0m[0m      value.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectQuiesceTimeout(value: FiniteDuration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(disconnectQuiesceTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectQuiesceTimeout(value: java.time.Duration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    withDisconnectQuiesceTimeout([0m
[0m[[0m[0mdebug[0m] [0m[0m      value.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectTimeout(value: FiniteDuration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(disconnectTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectTimeout(value: java.time.Duration): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    withDisconnectTimeout([0m
[0m[[0m[0mdebug[0m] [0m[0m      value.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxInFlight(value: Int): MqttConnectionSettings = copy(maxInFlight = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMqttVersion(value: Int): MqttConnectionSettings = copy(mqttVersion = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withServerUri(value: String): MqttConnectionSettings = copy(serverUris = immutable.Seq(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withServerUris(values: immutable.Seq[String]): MqttConnectionSettings = copy(serverUris = values)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withServerUris(values: java.util.List[String]): MqttConnectionSettings = copy(serverUris = values.asScala.toList)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSslHostnameVerifier(value: javax.net.ssl.HostnameVerifier): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(sslHostnameVerifier = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSslProperties(value: Map[String, String]): MqttConnectionSettings = copy(sslProperties = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSslProperties(value: java.util.Map[String, String]): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(sslProperties = value.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withOfflinePersistenceSettings(bufferSize: Int = 5000,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     deleteOldestMessage: Boolean = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     persistBuffer: Boolean = true): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      offlinePersistenceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option(MqttOfflinePersistenceSettings(bufferSize, deleteOldestMessage, persistBuffer))[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use with [[java.time.Duration]] instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKeepAliveInterval(keepAliveInterval: Int, unit: TimeUnit): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(keepAliveInterval = FiniteDuration(keepAliveInterval, unit))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use with [[java.time.Duration]] instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionTimeout(connectionTimeout: Int, unit: TimeUnit): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectionTimeout = FiniteDuration(connectionTimeout, unit))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use with [[java.time.Duration]] instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectQuiesceTimeout(disconnectQuiesceTimeout: Int, unit: TimeUnit): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(disconnectQuiesceTimeout = FiniteDuration(disconnectQuiesceTimeout, unit))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @deprecated use with [[java.time.Duration]] instead[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @java.lang.Deprecated[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDisconnectTimeout(disconnectTimeout: Int, unit: TimeUnit): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(disconnectTimeout = FiniteDuration(disconnectTimeout, unit))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      broker: String = broker,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId: String = clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      persistence: org.eclipse.paho.client.mqttv3.MqttClientPersistence = persistence,[0m
[0m[[0m[0mdebug[0m] [0m[0m      auth: Option[(String, String)] = auth,[0m
[0m[[0m[0mdebug[0m] [0m[0m      socketFactory: Option[javax.net.ssl.SSLSocketFactory] = socketFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      cleanSession: Boolean = cleanSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      will: Option[MqttMessage] = will,[0m
[0m[[0m[0mdebug[0m] [0m[0m      automaticReconnect: Boolean = automaticReconnect,[0m
[0m[[0m[0mdebug[0m] [0m[0m      keepAliveInterval: FiniteDuration = keepAliveInterval,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionTimeout: FiniteDuration = connectionTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectQuiesceTimeout: FiniteDuration = disconnectQuiesceTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectTimeout: FiniteDuration = disconnectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxInFlight: Int = maxInFlight,[0m
[0m[[0m[0mdebug[0m] [0m[0m      mqttVersion: Int = mqttVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverUris: immutable.Seq[String] = serverUris,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslHostnameVerifier: Option[javax.net.ssl.HostnameVerifier] = sslHostnameVerifier,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslProperties: Map[String, java.lang.String] = sslProperties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      offlinePersistenceSettings: Option[MqttOfflinePersistenceSettings] = offlinePersistenceSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttConnectionSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      broker = broker,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId = clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      persistence = persistence,[0m
[0m[[0m[0mdebug[0m] [0m[0m      auth = auth,[0m
[0m[[0m[0mdebug[0m] [0m[0m      socketFactory = socketFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      cleanSession = cleanSession,[0m
[0m[[0m[0mdebug[0m] [0m[0m      will = will,[0m
[0m[[0m[0mdebug[0m] [0m[0m      automaticReconnect = automaticReconnect,[0m
[0m[[0m[0mdebug[0m] [0m[0m      keepAliveInterval = keepAliveInterval,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionTimeout = connectionTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectQuiesceTimeout = disconnectQuiesceTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectTimeout = disconnectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxInFlight = maxInFlight,[0m
[0m[[0m[0mdebug[0m] [0m[0m      mqttVersion = mqttVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverUris = serverUris,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslHostnameVerifier = sslHostnameVerifier,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslProperties = sslProperties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      offlinePersistenceSettings = offlinePersistenceSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""MqttConnectionSettings(broker=$broker,clientId=$clientId,persistence=$persistence,auth(username)=${auth.map([0m
[0m[[0m[0mdebug[0m] [0m[0m      _._1[0m
[0m[[0m[0mdebug[0m] [0m[0m    )},socketFactory=$socketFactory,cleanSession=$cleanSession,will=$will,automaticReconnect=$automaticReconnect,keepAliveInterval=$keepAliveInterval,connectionTimeout=$connectionTimeout,disconnectQuiesceTimeout=$disconnectQuiesceTimeout,disconnectTimeout=$disconnectTimeout,maxInFlight=$maxInFlight,mqttVersion=$mqttVersion,serverUris=$serverUris,sslHostnameVerifier=$sslHostnameVerifier,sslProperties=$sslProperties,offlinePersistenceSettings=$offlinePersistenceSettings)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory for connection settings passed to the underlying Paho client.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * See [[https://www.eclipse.org/paho/files/javadoc/org/eclipse/paho/client/mqttv3/MqttConnectOptions.html]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttConnectionSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      broker: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      persistence: MqttClientPersistence[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MqttConnectionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttConnectionSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      broker,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      persistence,[0m
[0m[[0m[0mdebug[0m] [0m[0m      auth = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      socketFactory = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      cleanSession = MqttConnectOptions.CLEAN_SESSION_DEFAULT,[0m
[0m[[0m[0mdebug[0m] [0m[0m      will = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      automaticReconnect = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m      keepAliveInterval = MqttConnectOptions.KEEP_ALIVE_INTERVAL_DEFAULT.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionTimeout = MqttConnectOptions.CONNECTION_TIMEOUT_DEFAULT.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectQuiesceTimeout = 30.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnectTimeout = 10.seconds,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxInFlight = MqttConnectOptions.MAX_INFLIGHT_DEFAULT,[0m
[0m[[0m[0mdebug[0m] [0m[0m      mqttVersion = MqttConnectOptions.MQTT_VERSION_3_1_1,[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverUris = immutable.Seq.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslHostnameVerifier = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sslProperties = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m      offlinePersistenceSettings = None[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      broker: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      persistence: org.eclipse.paho.client.mqttv3.MqttClientPersistence[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MqttConnectionSettings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    broker,[0m
[0m[[0m[0mdebug[0m] [0m[0m    clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m    persistence[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/scaladsl/MqttSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT source factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttSourceSettings, bufferSize: Int): Source[MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atMostOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int): Source[MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.maybe[0m
[0m[[0m[0mdebug[0m] [0m[0m      .viaMat([0m
[0m[[0m[0mdebug[0m] [0m[0m        MqttFlow.atMostOnce(settings, subscriptions, bufferSize, defaultQos = MqttQoS.AtLeastOnce)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atLeastOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(settings: MqttSourceSettings, bufferSize: Int): Source[MqttMessageWithAck, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnce(settings.connectionSettings, MqttSubscriptions(settings.subscriptions), bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source subscribing to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(settings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  bufferSize: Int): Source[MqttMessageWithAck, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.maybe.viaMat([0m
[0m[[0m[0mdebug[0m] [0m[0m      MqttFlow.atLeastOnce(settings, subscriptions, bufferSize, defaultQos = MqttQoS.AtLeastOnce)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/scaladsl/MqttFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.impl.MqttFlowStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT flow factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(sourceSettings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m            bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m            defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atMostOnce(sourceSettings.connectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m               MqttSubscriptions(sourceSettings.subscriptions),[0m
[0m[[0m[0mdebug[0m] [0m[0m               bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m               defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(sourceSettings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new MqttFlowStage(sourceSettings.connectionSettings, sourceSettings.subscriptions, bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.message)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages (without a commit handle).[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnce(connectionSettings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 defaultQos: MqttQoS): Flow[MqttMessage, MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new MqttFlowStage(connectionSettings, subscriptions.subscriptions, bufferSize, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.message)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use atMostOnce with MqttConnectionSettings and MqttSubscriptions instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(sourceSettings: MqttSourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  defaultQos: MqttQoS): Flow[MqttMessage, MqttMessageWithAck, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new MqttFlowStage(sourceSettings.connectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        sourceSettings.subscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        defaultQos,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        manualAcks = true)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send messages to MQTT AND subscribe to MQTT messages with a commit handle to acknowledge message reception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on successful connection to the MQTT broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bufferSize max number of messages read from MQTT before back-pressure applies[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnce(connectionSettings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  subscriptions: MqttSubscriptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  defaultQos: MqttQoS): Flow[MqttMessage, MqttMessageWithAck, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      new MqttFlowStage(connectionSettings, subscriptions.subscriptions, bufferSize, defaultQos, manualAcks = true)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/scaladsl/MqttSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT sink factory.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink sending messages to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The materialized value completes on stream completion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param defaultQos Quality of service level applied for messages not specifying a message specific value[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(connectionSettings: MqttConnectionSettings, defaultQos: MqttQoS): Sink[MqttMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MqttFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .atMostOnce(connectionSettings, MqttSubscriptions.empty, 0, defaultQos)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/scaladsl/MqttMessageWithAck.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.MqttMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * MQTT Message and a handle to acknowledge message reception to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait MqttMessageWithAck {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The message received from MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val message: MqttMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use ack() instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def messageArrivedComplete(): Future[Done] = ack()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Signals `messageArrivedComplete` to MQTT.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a future indicating, if the acknowledge reached MQTT[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ack(): Future[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/impl/MqttFlowStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Properties[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.Semaphore[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicInteger[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.scaladsl.MqttMessageWithAck[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.eclipse.paho.client.mqttv3.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  IMqttActionListener,[0m
[0m[[0m[0mdebug[0m] [0m[0m  IMqttAsyncClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m  IMqttDeliveryToken,[0m
[0m[[0m[0mdebug[0m] [0m[0m  IMqttToken,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttAsyncClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttCallbackExtended,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttConnectOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttException,[0m
[0m[[0m[0mdebug[0m] [0m[0m  MqttMessage => PahoMqttMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.mutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mqtt.MqttOfflinePersistenceSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[mqtt] final class MqttFlowStage(connectionSettings: MqttConnectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        subscriptions: Map[String, MqttQoS],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        defaultQoS: MqttQoS,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        manualAcks: Boolean = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[FlowShape[MqttMessage, MqttMessageWithAck], Future[Done]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import MqttFlowStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[MqttMessage]("MqttFlow.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[MqttMessageWithAck]("MqttFlow.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: Shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes = Attributes.name("MqttFlow")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[Done]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subscriptionPromise = Promise[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new GraphStageLogic(shape) with StageLogging with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val backpressurePahoClient = new Semaphore(bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var pendingMsg = Option.empty[MqttMessage][0m
[0m[[0m[0mdebug[0m] [0m[0m      private val queue = mutable.Queue[MqttMessageWithAck]()[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val unackedMessages = new AtomicInteger()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val onSubscribe: AsyncCallback[Try[IMqttToken]] = getAsyncCallback[Try[IMqttToken]] { conn =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriptionPromise.complete(conn.map(_ => {[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.debug("subscription established")[0m
[0m[[0m[0mdebug[0m] [0m[0m          Done[0m
[0m[[0m[0mdebug[0m] [0m[0m        }))[0m
[0m[[0m[0mdebug[0m] [0m[0m        pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val onConnect: AsyncCallback[IMqttAsyncClient] =[0m
[0m[[0m[0mdebug[0m] [0m[0m        getAsyncCallback[IMqttAsyncClient]((client: IMqttAsyncClient) => {[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.debug("connected")[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (subscriptions.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (manualAcks) client.setManualAcks(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m            val (topics, qoses) = subscriptions.unzip[0m
[0m[[0m[0mdebug[0m] [0m[0m            client.subscribe(topics.toArray, qoses.map(_.value).toArray, (), asActionListener(onSubscribe.invoke))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            subscriptionPromise.complete(SuccessfullyDone)[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val onConnectionLost: AsyncCallback[Throwable] = getAsyncCallback[Throwable](failStageWith)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val onMessageAsyncCallback: AsyncCallback[MqttMessageWithAck] =[0m
[0m[[0m[0mdebug[0m] [0m[0m        getAsyncCallback[MqttMessageWithAck] { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (isAvailable(out)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            pushDownstream(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else if (queue.size + 1 > bufferSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            failStageWith(new RuntimeException(s"Reached maximum buffer size $bufferSize"))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            queue.enqueue(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val onPublished: AsyncCallback[Try[IMqttToken]] = getAsyncCallback[Try[IMqttToken]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Success(_) => if (!hasBeenPulled(in)) pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Failure(ex) => failStageWith(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def createPahoBufferOptions(settings: MqttOfflinePersistenceSettings): DisconnectedBufferOptions = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val disconnectedBufferOptions = new DisconnectedBufferOptions()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        disconnectedBufferOptions.setBufferEnabled(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m        disconnectedBufferOptions.setBufferSize(settings.bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m        disconnectedBufferOptions.setDeleteOldestMessages(settings.deleteOldestMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m        disconnectedBufferOptions.setPersistBuffer(settings.persistBuffer)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        disconnectedBufferOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val client = new MqttAsyncClient([0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionSettings.broker,[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionSettings.clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionSettings.persistence[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def mqttClient =[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionSettings.offlinePersistenceSettings match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(bufferOpts) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            client.setBufferOpts(createPahoBufferOptions(bufferOpts))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            client[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => client[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val commitCallback: AsyncCallback[CommitCallbackArguments] =[0m
[0m[[0m[0mdebug[0m] [0m[0m        getAsyncCallback[CommitCallbackArguments]([0m
[0m[[0m[0mdebug[0m] [0m[0m          (args: CommitCallbackArguments) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              mqttClient.messageArrivedComplete(args.messageId, args.qos.value)[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (unackedMessages.decrementAndGet() == 0 && (isClosed(out) || (isClosed(in) && queue.isEmpty)))[0m
[0m[[0m[0mdebug[0m] [0m[0m                completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m              args.promise.complete(SuccessfullyDone)[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case e: Throwable => args.promise.failure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      mqttClient.setCallback(new MqttCallbackExtended {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def messageArrived(topic: String, pahoMessage: PahoMqttMessage): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m          backpressurePahoClient.acquire()[0m
[0m[[0m[0mdebug[0m] [0m[0m          val message = new MqttMessageWithAck {[0m
[0m[[0m[0mdebug[0m] [0m[0m            override val message = MqttMessage(topic, ByteString.fromArrayUnsafe(pahoMessage.getPayload))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            override def ack(): Future[Done] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val promise = Promise[Done]()[0m
[0m[[0m[0mdebug[0m] [0m[0m              val qos = pahoMessage.getQos match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case 0 => MqttQoS.AtMostOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m                case 1 => MqttQoS.AtLeastOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m                case 2 => MqttQoS.ExactlyOnce[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              commitCallback.invoke(CommitCallbackArguments(pahoMessage.getId, qos, promise))[0m
[0m[[0m[0mdebug[0m] [0m[0m              promise.future[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          onMessageAsyncCallback.invoke(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def deliveryComplete(token: IMqttDeliveryToken): Unit = ()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def connectionLost(cause: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (!connectionSettings.automaticReconnect) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            log.info("connection lost (you might want to enable `automaticReconnect` in `MqttConnectionSettings`)")[0m
[0m[[0m[0mdebug[0m] [0m[0m            onConnectionLost.invoke(cause)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            log.info("connection lost, trying to reconnect")[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def connectComplete(reconnect: Boolean, serverURI: String): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m          pendingMsg.foreach { msg =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishToMqtt(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m            pendingMsg = None[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (reconnect && !hasBeenPulled(in)) pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // InHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val msg = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          publishToMqtt(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: MqttException if connectionSettings.automaticReconnect => pendingMsg = Some(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case NonFatal(e) => throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        setKeepGoing(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (queue.isEmpty && unackedMessages.get() == 0) super.onUpstreamFinish()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFailure(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        setKeepGoing(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (queue.isEmpty && unackedMessages.get() == 0) super.onUpstreamFailure(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // OutHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (queue.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          pushDownstream(queue.dequeue())[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (unackedMessages.get() == 0 && isClosed(in)) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onDownstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        setKeepGoing(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (unackedMessages.get() == 0) super.onDownstreamFinish()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def publishToMqtt(msg: MqttMessage): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val pahoMsg = new PahoMqttMessage(msg.payload.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m        pahoMsg.setQos(msg.qos.getOrElse(defaultQoS).value)[0m
[0m[[0m[0mdebug[0m] [0m[0m        pahoMsg.setRetained(msg.retained)[0m
[0m[[0m[0mdebug[0m] [0m[0m        mqttClient.publish(msg.topic, pahoMsg, msg, asActionListener(onPublished.invoke))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def pushDownstream(message: MqttMessageWithAck): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        push(out, message)[0m
[0m[[0m[0mdebug[0m] [0m[0m        backpressurePahoClient.release()[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (manualAcks) unackedMessages.incrementAndGet()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def failStageWith(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        subscriptionPromise.tryFailure(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m        failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          mqttClient.connect([0m
[0m[[0m[0mdebug[0m] [0m[0m            asConnectOptions(connectionSettings),[0m
[0m[[0m[0mdebug[0m] [0m[0m            (),[0m
[0m[[0m[0mdebug[0m] [0m[0m            new IMqttActionListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m              override def onSuccess(v: IMqttToken): Unit = onConnect.invoke(v.getClient)[0m
[0m[[0m[0mdebug[0m] [0m[0m              override def onFailure(asyncActionToken: IMqttToken, ex: Throwable): Unit = onConnectionLost.invoke(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case e: Throwable => failStageWith(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!subscriptionPromise.isCompleted)[0m
[0m[[0m[0mdebug[0m] [0m[0m          subscriptionPromise[0m
[0m[[0m[0mdebug[0m] [0m[0m            .tryFailure([0m
[0m[[0m[0mdebug[0m] [0m[0m              new IllegalStateException("Cannot complete subscription because the stage is about to stop or fail")[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.debug("stage stopped, disconnecting")[0m
[0m[[0m[0mdebug[0m] [0m[0m          mqttClient.disconnect([0m
[0m[[0m[0mdebug[0m] [0m[0m            connectionSettings.disconnectQuiesceTimeout.toMillis,[0m
[0m[[0m[0mdebug[0m] [0m[0m            null,[0m
[0m[[0m[0mdebug[0m] [0m[0m            new IMqttActionListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m              override def onSuccess(asyncActionToken: IMqttToken): Unit = mqttClient.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m              override def onFailure(asyncActionToken: IMqttToken, exception: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m                // Use 0 quiesce timeout as we have already quiesced in `disconnect`[0m
[0m[[0m[0mdebug[0m] [0m[0m                mqttClient.disconnectForcibly(0, connectionSettings.disconnectTimeout.toMillis)[0m
[0m[[0m[0mdebug[0m] [0m[0m                // Only disconnected client can be closed[0m
[0m[[0m[0mdebug[0m] [0m[0m                mqttClient.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          // Not to worry - disconnect is best effort - don't worry if already disconnected[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: MqttException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              mqttClient.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case _: MqttException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, subscriptionPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[mqtt] object MqttFlowStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val SuccessfullyDone = Success(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final private case class CommitCallbackArguments(messageId: Int, qos: MqttQoS, promise: Promise[Done])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def asConnectOptions(connectionSettings: MqttConnectionSettings): MqttConnectOptions = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val options = new MqttConnectOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.auth.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (user, password) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        options.setUserName(user)[0m
[0m[[0m[0mdebug[0m] [0m[0m        options.setPassword(password.toCharArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.socketFactory.foreach(options.setSocketFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.will.foreach { will =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      options.setWill([0m
[0m[[0m[0mdebug[0m] [0m[0m        will.topic,[0m
[0m[[0m[0mdebug[0m] [0m[0m        will.payload.toArray,[0m
[0m[[0m[0mdebug[0m] [0m[0m        will.qos.getOrElse(MqttQoS.atLeastOnce).value,[0m
[0m[[0m[0mdebug[0m] [0m[0m        will.retained[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setCleanSession(connectionSettings.cleanSession)[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setAutomaticReconnect(connectionSettings.automaticReconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setKeepAliveInterval(connectionSettings.keepAliveInterval.toSeconds.toInt)[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setConnectionTimeout(connectionSettings.connectionTimeout.toSeconds.toInt)[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setMaxInflight(connectionSettings.maxInFlight)[0m
[0m[[0m[0mdebug[0m] [0m[0m    options.setMqttVersion(connectionSettings.mqttVersion)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.serverUris.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      options.setServerURIs(connectionSettings.serverUris.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.sslHostnameVerifier.foreach(options.setSSLHostnameVerifier)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.sslProperties.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val properties = new Properties()[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings.sslProperties.foreach { case (key, value) => properties.setProperty(key, value) }[0m
[0m[[0m[0mdebug[0m] [0m[0m      options.setSSLProperties(properties)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    options[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def asActionListener(func: Try[IMqttToken] => Unit): IMqttActionListener = new IMqttActionListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def onSuccess(token: IMqttToken): Unit = func(Success(token))[0m
[0m[[0m[0mdebug[0m] [0m[0m    def onFailure(token: IMqttToken, ex: Throwable): Unit = func(Failure(ex))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mqtt/src/main/scala/akka/stream/alpakka/mqtt/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mqtt[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MqttMessage private (val topic: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 val payload: akka.util.ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 val qos: Option[MqttQoS],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 val retained: Boolean) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTopic(value: String): MqttMessage = copy(topic = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPayload(value: akka.util.ByteString): MqttMessage = copy(payload = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPayload(value: Array[Byte]): MqttMessage = copy(payload = akka.util.ByteString(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withQos(value: MqttQoS): MqttMessage = copy(qos = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withRetained(value: Boolean): MqttMessage = if (retained == value) this else copy(retained = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(topic: String = topic,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   payload: akka.util.ByteString = payload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   qos: Option[MqttQoS] = qos,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   retained: Boolean = retained): MqttMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MqttMessage(topic = topic, payload = payload, qos = qos, retained = retained)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""MqttMessage(topic=$topic,payload=$payload,qos=$qos,retained=$retained)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: MqttMessage =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.topic, that.topic) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.payload, that.payload) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.qos, that.qos) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.retained, that.retained)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    java.util.Objects.hash(topic, payload, qos, Boolean.box(retained))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MqttMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      topic: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      payload: akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MqttMessage = new MqttMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m    topic,[0m
[0m[[0m[0mdebug[0m] [0m[0m    payload,[0m
[0m[[0m[0mdebug[0m] [0m[0m    qos = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    retained = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      topic: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      payload: akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MqttMessage = new MqttMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m    topic,[0m
[0m[[0m[0mdebug[0m] [0m[0m    payload,[0m
[0m[[0m[0mdebug[0m] [0m[0m    qos = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    retained = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
