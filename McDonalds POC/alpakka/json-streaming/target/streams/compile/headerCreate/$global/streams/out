[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/json-streaming/src/main/scala/akka/stream/alpakka/json/javadsl/JsonReader.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.json.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.json.impl.JsonStreamReader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.compiler.JsonPathCompiler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.path.JsonPath[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JsonReader {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that consumes incoming json in chunks and produces a stream of parsable json values[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to the JsonPath given.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JsonPath examples:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * - Stream all elements of the nested array `rows`: `$.rows[*]`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * - Stream the value of `doc` of each element in the array: `$.rows[*].doc`[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Supported JsonPath syntax: https://github.com/jsurfer/JsonSurfer#what-is-jsonpath[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def select(path: JsonPath): Flow[ByteString, ByteString, NotUsed] = Flow.fromGraph(new JsonStreamReader(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that consumes incoming json in chunks and produces a stream of parsable json values[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to the JsonPath given. The passed String will need to be parsed first.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see [[#select]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def select(path: String): Flow[ByteString, ByteString, NotUsed] = select(JsonPathCompiler.compile(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/json-streaming/src/main/scala/akka/stream/alpakka/json/scaladsl/JsonReader.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.json.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.json.impl.JsonStreamReader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.compiler.JsonPathCompiler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.path.JsonPath[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JsonReader {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that consumes incoming json in chunks and produces a stream of parsable json values[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to the JsonPath given.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JsonPath examples:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * - Stream all elements of the nested array `rows`: `$.rows[*]`[0m
[0m[[0m[0mdebug[0m] [0m[0m   * - Stream the value of `doc` of each element in the array: `$.rows[*].doc`[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Supported JsonPath syntax: https://github.com/jsurfer/JsonSurfer#what-is-jsonpath[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def select(path: JsonPath): Flow[ByteString, ByteString, NotUsed] = Flow.fromGraph(new JsonStreamReader(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that consumes incoming json in chunks and produces a stream of parsable json values[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to the JsonPath given. The passed String will need to be parsed first.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see [[#select]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def select(path: String): Flow[ByteString, ByteString, NotUsed] = select(JsonPathCompiler.compile(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/json-streaming/src/main/scala/akka/stream/alpakka/json/impl/JsonStreamReader.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.json.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.exception.JsonSurfingException[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.path.JsonPath[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.jsfr.json.{JsonPathListener, JsonSurferJackson, ParsingContext}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Queue[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[akka] final class JsonStreamReader(path: JsonPath) extends GraphStage[FlowShape[ByteString, ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[ByteString]("Json.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[ByteString]("Json.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes = Attributes.name(s"jsonReader($path)")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val in = shape.in[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val out = shape.out[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var buffer = Queue.empty[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val surfer = JsonSurferJackson.INSTANCE[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val config = surfer.configBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m        .bind(path, new JsonPathListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onValue(value: Any, context: ParsingContext): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m            buffer = buffer.enqueue(ByteString(value.toString))[0m
[0m[[0m[0mdebug[0m] [0m[0m        })[0m
[0m[[0m[0mdebug[0m] [0m[0m        .build[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val parser = surfer.createNonBlockingParser(config)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = tryPull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val input = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val array = input.toArray[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        // Feeding the parser will fail in situations like invalid JSON being provided.[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          parser.feed(array, 0, array.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case e: JsonSurfingException => failStage(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (buffer.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          emitMultiple(out, buffer)[0m
[0m[[0m[0mdebug[0m] [0m[0m          buffer = Queue.empty[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          // Iff the buffer is empty, we haven't consumed any values yet[0m
[0m[[0m[0mdebug[0m] [0m[0m          // and thus we still need to fulfill downstream need.[0m
[0m[[0m[0mdebug[0m] [0m[0m          tryPull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        // Ending the parser will fail when the JSON structure is incomplete.[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          parser.endOfInput()[0m
[0m[[0m[0mdebug[0m] [0m[0m          completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case e: JsonSurfingException => failStage(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
