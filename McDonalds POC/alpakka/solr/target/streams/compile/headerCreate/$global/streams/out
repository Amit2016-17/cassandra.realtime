[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/javadsl/SolrSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.function.Function[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.{SolrUpdateSettings, WriteMessage, WriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Sink[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.common.SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.{List => JavaList}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documents([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Sink[JavaList[WriteMessage[SolrInputDocument, NotUsed]], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .documents(collection, settings, client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(javadsl.Sink.ignore[java.util.List[WriteResult[SolrInputDocument, NotUsed]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m             javadsl.Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beans[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[JavaList[WriteMessage[T, NotUsed]], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .beans[T](collection, settings, client, clazz)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(javadsl.Sink.ignore[java.util.List[WriteResult[T, NotUsed]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m             javadsl.Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typeds[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: Function[T, SolrInputDocument],[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Sink[JavaList[WriteMessage[T, NotUsed]], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .typeds[T](collection, settings, binder, client, clazz)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(javadsl.Sink.ignore[java.util.List[WriteResult[T, NotUsed]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m             javadsl.Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/javadsl/SolrFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.function.Function[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.{scaladsl, SolrUpdateSettings, WriteMessage, WriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.common.SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documents([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[SolrInputDocument, NotUsed]], java.util.List[[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteResult[SolrInputDocument, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  ], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[SolrInputDocument, NotUsed]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    immutable.Seq[WriteMessage[SolrInputDocument, NotUsed]]]([0m
[0m[[0m[0mdebug[0m] [0m[0m        _.asScala.toIndexedSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .documents(collection, settings)(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beans[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[T, NotUsed]], java.util.List[WriteResult[T, NotUsed]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[T, NotUsed]], immutable.Seq[WriteMessage[T, NotUsed]]]([0m
[0m[[0m[0mdebug[0m] [0m[0m        _.asScala.toIndexedSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .beans[T](collection, settings)(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typeds[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: Function[T, SolrInputDocument],[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[T, NotUsed]], java.util.List[WriteResult[T, NotUsed]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[T, NotUsed]], immutable.Seq[WriteMessage[T, NotUsed]]]([0m
[0m[[0m[0mdebug[0m] [0m[0m        _.asScala.toIndexedSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .typeds[T](collection, settings, i => binder.apply(i))(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documentsWithPassThrough[PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[SolrInputDocument, PT]], java.util.List[WriteResult[SolrInputDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                                  PT]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[SolrInputDocument, PT]], immutable.Seq[WriteMessage[SolrInputDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                                    PT]]]([0m
[0m[[0m[0mdebug[0m] [0m[0m        _.asScala.toIndexedSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .documentsWithPassThrough(collection, settings)(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beansWithPassThrough[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[T, PT]], java.util.List[WriteResult[T, PT]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[T, PT]], immutable.Seq[WriteMessage[T, PT]]](_.asScala.toIndexedSeq)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .beansWithPassThrough[T, PT](collection, settings)(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typedsWithPassThrough[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: Function[T, SolrInputDocument],[0m
[0m[[0m[0mdebug[0m] [0m[0m      client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m      clazz: Class[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): javadsl.Flow[java.util.List[WriteMessage[T, PT]], java.util.List[WriteResult[T, PT]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction[java.util.List[WriteMessage[T, PT]], immutable.Seq[WriteMessage[T, PT]]](_.asScala.toIndexedSeq)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via([0m
[0m[[0m[0mdebug[0m] [0m[0m        scaladsl.SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .typedsWithPassThrough[T, PT](collection, settings, i => binder.apply(i))(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/javadsl/SolrSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.impl.SolrSourceStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.Tuple[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.stream.TupleStream[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Use a Solr [[org.apache.solr.client.solrj.io.stream.TupleStream]] as source.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromTupleStream(ts: TupleStream): Source[Tuple, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new SolrSourceStage(ts))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/SolrMessages.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject WriteMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createUpsertMessage[T](source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(Upsert, source = Option(source))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createDeleteMessage[T](id: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(DeleteByIds, idFieldValue = Option(id))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createDeleteByQueryMessage[T](query: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(DeleteByQuery, query = Option(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createUpdateMessage[T](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             updates: Map[String, Map[String, Any]]): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(AtomicUpdate,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     idField = Option(idField),[0m
[0m[[0m[0mdebug[0m] [0m[0m                     idFieldValue = Option(idValue),[0m
[0m[[0m[0mdebug[0m] [0m[0m                     routingFieldValue = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     updates = updates)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createUpdateMessage[T](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             updates: java.util.Map[String, java.util.Map[String, Object]]): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpdateMessage(idField, idValue, asScalaUpdates(updates))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[solr] def asScalaUpdates([0m
[0m[[0m[0mdebug[0m] [0m[0m      jupdates: java.util.Map[String, java.util.Map[String, Object]][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Map[String, Map[String, Any]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    jupdates.asScala.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (k, v: java.util.Map[String, Object]) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        (k, v.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.toMap[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createPassThrough[C](passThrough: C): WriteMessage[NotUsed, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(PassThrough).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// Left for backwards compatibility, might become deprecated after 1.0[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IncomingUpsertMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T](source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpsertMessage(source)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T, C](source: T, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpsertMessage(source).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](source: T): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpsertMessage(source)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](source: T, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpsertMessage(source).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// Left for backwards compatibility, might become deprecated after 1.0[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IncomingDeleteMessageByIds {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T](id: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteMessage(id)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T, C](id: String, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteMessage(id).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](id: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteMessage(id)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](id: String, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteMessage(id).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// Left for backwards compatibility, might become deprecated after 1.0[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IncomingDeleteMessageByQuery {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T](query: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteByQueryMessage(query)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T, C](query: String, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteByQueryMessage(query).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](query: String): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteByQueryMessage(query)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](query: String, passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createDeleteByQueryMessage(query).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// Left for backwards compatibility, might become deprecated after 1.0[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IncomingAtomicUpdateMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               routingFieldValue: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m               updates: Map[String, Map[String, Any]]): WriteMessage[T, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val msg = WriteMessage.createUpdateMessage[T](idField, idValue, updates)[0m
[0m[[0m[0mdebug[0m] [0m[0m    routingFieldValue match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(r) => msg.withRoutingFieldValue(r)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => msg[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T, C](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  routingFieldValue: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                  updates: Map[String, Map[String, Any]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                  passThrough: C): WriteMessage[T, C] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val msg = WriteMessage.createUpdateMessage[T](idField, idValue, updates).withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    routingFieldValue match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(r) => msg.withRoutingFieldValue(r)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => msg[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                updates: java.util.Map[String, java.util.Map[String, Object]]): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createUpdateMessage(idField, idValue, WriteMessage.asScalaUpdates(updates))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                routingFieldValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                updates: java.util.Map[String, java.util.Map[String, Object]]): WriteMessage[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(idField, idValue, Option(routingFieldValue), WriteMessage.asScalaUpdates(updates))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   updates: java.util.Map[String, java.util.Map[String, Object]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m      .createUpdateMessage(idField, idValue, WriteMessage.asScalaUpdates(updates))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](idField: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   idValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   routingFieldValue: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   updates: java.util.Map[String, java.util.Map[String, Object]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   passThrough: C): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(idField, idValue, Option(routingFieldValue), WriteMessage.asScalaUpdates(updates))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T, C](passThrough: C): WriteMessage[NotUsed, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    WriteMessage.createPassThrough(passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class WriteMessage[T, C] private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val operation: Operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val idField: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val idFieldValue: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val routingFieldValue: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val query: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val source: Option[T] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val updates: Map[String, Map[String, Any]] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val passThrough: C = NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withIdFieldValue(idField: String, idFieldValue: String): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(idField = Option(idField), idFieldValue = Some(idFieldValue))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withIdFieldValue(value: String): WriteMessage[T, C] = copy(idFieldValue = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withRoutingFieldValue(value: String): WriteMessage[T, C] = copy(routingFieldValue = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withQuery(value: String): WriteMessage[T, C] = copy(query = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSource[T2](value: T2): WriteMessage[T2, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(operation, idField, idFieldValue, routingFieldValue, query, Option(value), updates, passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUpdates(value: Map[java.lang.String, Map[String, Any]]): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(updates = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUpdates(value: java.util.Map[String, java.util.Map[String, Object]]): WriteMessage[T, C] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(updates = WriteMessage.asScalaUpdates(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PT2](value: PT2): WriteMessage[T, PT2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new WriteMessage(operation, idField, idFieldValue, routingFieldValue, query, source, updates, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      operation: Operation = operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m      idField: Option[String] = idField,[0m
[0m[[0m[0mdebug[0m] [0m[0m      idFieldValue: Option[String] = idFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m      routingFieldValue: Option[String] = routingFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m      query: Option[String] = query,[0m
[0m[[0m[0mdebug[0m] [0m[0m      source: Option[T] = source,[0m
[0m[[0m[0mdebug[0m] [0m[0m      updates: Map[String, Map[String, Any]] = updates,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough: C = passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): WriteMessage[T, C] = new WriteMessage[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m    operation = operation,[0m
[0m[[0m[0mdebug[0m] [0m[0m    idField = idField,[0m
[0m[[0m[0mdebug[0m] [0m[0m    idFieldValue = idFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m    routingFieldValue = routingFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m    query = query,[0m
[0m[[0m[0mdebug[0m] [0m[0m    source = source,[0m
[0m[[0m[0mdebug[0m] [0m[0m    updates = updates,[0m
[0m[[0m[0mdebug[0m] [0m[0m    passThrough = passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "WriteMessage(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"operation=$operation," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"idField=$idField," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"idFieldValue=$idFieldValue," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"routingFieldValue=$routingFieldValue," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"query=$query," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"source=$source," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"updates=$updates," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"passThrough=$passThrough" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class WriteResult[T, C](idField: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   idFieldValue: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   routingFieldValue: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   query: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   source: Option[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   updates: Map[String, Map[String, Any]],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   passThrough: C,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   status: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Upsert extends Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mobject DeleteByIds extends Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mobject DeleteByQuery extends Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mobject AtomicUpdate extends Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mobject PassThrough extends Operation[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/scaladsl/SolrSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.{SolrUpdateSettings, WriteMessage}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.common.SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documents[T](collection: String, settings: SolrUpdateSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[immutable.Seq[WriteMessage[SolrInputDocument, NotUsed]], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .documents(collection, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beans[T](collection: String, settings: SolrUpdateSettings)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[immutable.Seq[WriteMessage[T, NotUsed]], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .beans[T](collection, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typeds[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: T => SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit client: SolrClient): Sink[immutable.Seq[WriteMessage[T, NotUsed]], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SolrFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .typeds[T](collection, settings, binder)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/scaladsl/SolrFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.impl.SolrFlowStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.{SolrUpdateSettings, WriteMessage, WriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.common.SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documents([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[immutable.Seq[WriteMessage[SolrInputDocument, NotUsed]], immutable.Seq[WriteResult[SolrInputDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                             NotUsed]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[SolrInputDocument, NotUsed]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          identity[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beans[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[immutable.Seq[WriteMessage[T, NotUsed]], immutable.Seq[WriteResult[T, NotUsed]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[T, NotUsed]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new DefaultSolrObjectBinder(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typeds[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: T => SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m  )([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[immutable.Seq[WriteMessage[T, NotUsed]], immutable.Seq[WriteResult[T, NotUsed]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[T, NotUsed]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          binder[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write `SolrInputDocument`s to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def documentsWithPassThrough[PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit client: SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[immutable.Seq[WriteMessage[SolrInputDocument, PT]],[0m
[0m[[0m[0mdebug[0m] [0m[0m          immutable.Seq[WriteResult[SolrInputDocument, PT]],[0m
[0m[[0m[0mdebug[0m] [0m[0m          NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[SolrInputDocument, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          identity[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write Java bean stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The stream element classes must be annotated for use with [[org.apache.solr.client.solrj.beans.DocumentObjectBinder]] for conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def beansWithPassThrough[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit client: SolrClient): Flow[immutable.Seq[WriteMessage[T, PT]], immutable.Seq[WriteResult[T, PT]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new DefaultSolrObjectBinder(client)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Write stream elements to Solr in a flow emitting `WriteResult`s containing the status.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param binder a conversion function to create `SolrInputDocument`s of the stream elements[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @tparam PT pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def typedsWithPassThrough[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binder: T => SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit client: SolrClient): Flow[immutable.Seq[WriteMessage[T, PT]], immutable.Seq[WriteResult[T, PT]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        new SolrFlowStage[T, PT]([0m
[0m[[0m[0mdebug[0m] [0m[0m          collection,[0m
[0m[[0m[0mdebug[0m] [0m[0m          client,[0m
[0m[[0m[0mdebug[0m] [0m[0m          settings,[0m
[0m[[0m[0mdebug[0m] [0m[0m          binder[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private class DefaultSolrObjectBinder(solrClient: SolrClient) extends (Any => SolrInputDocument) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def apply(v1: Any): SolrInputDocument =[0m
[0m[[0m[0mdebug[0m] [0m[0m      solrClient.getBinder.toSolrInputDocument(v1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/scaladsl/SolrSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr.impl.SolrSourceStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.Tuple[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.stream.TupleStream[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Use a Solr [[org.apache.solr.client.solrj.io.stream.TupleStream]] as source.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromTupleStream(ts: TupleStream): Source[Tuple, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new SolrSourceStage(ts))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/SolrUpdateSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class SolrUpdateSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val commitWithin: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Set max time (in ms) before a commit will happen[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCommitWithin(value: Int): SolrUpdateSettings = copy(commitWithin = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      commitWithin: Int = commitWithin[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SolrUpdateSettings = new SolrUpdateSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    commitWithin = commitWithin[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "SolrUpdateSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"commitWithin=$commitWithin" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SolrUpdateSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Defaults = new SolrUpdateSettings(-1)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): SolrUpdateSettings = Defaults[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): SolrUpdateSettings = Defaults[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/impl/SolrSourceStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.Tuple[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.io.stream.TupleStream[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[solr] final class SolrSourceStage(tupleStream: TupleStream) extends GraphStage[SourceShape[Tuple]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[Tuple] = Outlet("SolrSource.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: SourceShape[Tuple] = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          tupleStream.open()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case NonFatal(exc) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            failStage(exc)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          tupleStream.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case NonFatal(exc) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            failStage(exc)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = fetchFromSolr()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def fetchFromSolr(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val tuple = tupleStream.read()[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (tuple.EOF) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (tuple.EXCEPTION) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          failStage(new IllegalStateException(tuple.getException))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          emit(out, tuple)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/solr/src/main/scala/akka/stream/alpakka/solr/impl/SolrFlowStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.solr.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.ActorAttributes.SupervisionStrategy[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.solr._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.SolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.impl.CloudSolrClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.client.solrj.response.UpdateResponse[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.solr.common.SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam T[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam C pass-through type[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[solr] final class SolrFlowStage[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m    collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m    settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    messageBinder: T => SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStage[FlowShape[immutable.Seq[WriteMessage[T, C]], immutable.Seq[WriteResult[T, C]]]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[immutable.Seq[WriteMessage[T, C]]]("messages")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[immutable.Seq[WriteResult[T, C]]]("result")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes(ActorAttributes.IODispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def decider = inheritedAttributes.mandatoryAttribute[SupervisionStrategy].decider[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SolrFlowLogic[T, C](decider, collection, client, in, out, shape, settings, messageBinder)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SolrFlowLogic[T, C]([0m
[0m[[0m[0mdebug[0m] [0m[0m    decider: Supervision.Decider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    collection: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    client: SolrClient,[0m
[0m[[0m[0mdebug[0m] [0m[0m    in: Inlet[immutable.Seq[WriteMessage[T, C]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m    out: Outlet[immutable.Seq[WriteResult[T, C]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m    shape: FlowShape[immutable.Seq[WriteMessage[T, C]], immutable.Seq[WriteResult[T, C]]],[0m
[0m[[0m[0mdebug[0m] [0m[0m    settings: SolrUpdateSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    messageBinder: T => SolrInputDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStageLogic(shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with OutHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m    with InHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m    with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val messagesIn = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m    try {[0m
[0m[[0m[0mdebug[0m] [0m[0m      sendBulkToSolr(messagesIn)[0m
[0m[[0m[0mdebug[0m] [0m[0m      tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NonFatal(ex) ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m        decider(ex) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Supervision.Stop ⇒ failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ ⇒ tryPull() // for resume and restart strategies tryPull[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def tryPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (!isClosed(in) && !hasBeenPulled(in)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def updateBulkToSolr(messages: immutable.Seq[WriteMessage[T, C]]): UpdateResponse = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val docs = messages.flatMap(_.source.map(messageBinder))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (log.isDebugEnabled) log.debug("Upsert {}", docs)[0m
[0m[[0m[0mdebug[0m] [0m[0m    client.add(collection, docs.asJava, settings.commitWithin)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def atomicUpdateBulkToSolr(messages: immutable.Seq[WriteMessage[T, C]]): UpdateResponse = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val docs = messages.map { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val doc = new SolrInputDocument()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      message.idField.foreach { idField =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        message.idFieldValue.foreach { idFieldValue =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          doc.addField(idField, idFieldValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      message.routingFieldValue.foreach { routingFieldValue =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val routingField = client match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case csc: CloudSolrClient =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Option(csc.getIdField)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => None[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        routingField.foreach { routingField =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          message.idField.foreach { idField =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (routingField != idField)[0m
[0m[[0m[0mdebug[0m] [0m[0m              doc.addField(routingField, routingFieldValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      message.updates.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (field, updates) => {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val jMap = updates.asInstanceOf[Map[String, Any]].asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m          doc.addField(field, jMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      doc[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (log.isDebugEnabled) log.debug(s"Update atomically $docs")[0m
[0m[[0m[0mdebug[0m] [0m[0m    client.add(collection, docs.asJava, settings.commitWithin)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def deleteBulkToSolrByIds(messages: immutable.Seq[WriteMessage[T, C]]): UpdateResponse = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val docsIds = messages[0m
[0m[[0m[0mdebug[0m] [0m[0m      .filter { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        message.operation == DeleteByIds && message.idFieldValue.isDefined[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        message.idFieldValue.get[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (log.isDebugEnabled) log.debug(s"Delete the ids $docsIds")[0m
[0m[[0m[0mdebug[0m] [0m[0m    client.deleteById(collection, docsIds.asJava, settings.commitWithin)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def deleteEachByQuery(messages: immutable.Seq[WriteMessage[T, C]]): UpdateResponse = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val responses = messages.map { message =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val query = message.query.get[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (log.isDebugEnabled) log.debug(s"Delete by the query $query")[0m
[0m[[0m[0mdebug[0m] [0m[0m      client.deleteByQuery(collection, query, settings.commitWithin)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    responses.find(_.getStatus != 0).getOrElse(responses.head)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def sendBulkToSolr(messages: immutable.Seq[WriteMessage[T, C]]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m    def send(toSend: immutable.Seq[WriteMessage[T, C]]): Option[UpdateResponse] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val operation = toSend.head.operation[0m
[0m[[0m[0mdebug[0m] [0m[0m      //Just take a subset of this operation[0m
[0m[[0m[0mdebug[0m] [0m[0m      val (current, remaining) = toSend.span { m =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        m.operation == operation[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      //send this subset[0m
[0m[[0m[0mdebug[0m] [0m[0m      val response = operation match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Upsert => Option(updateBulkToSolr(current))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case AtomicUpdate => Option(atomicUpdateBulkToSolr(current))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case DeleteByIds => Option(deleteBulkToSolrByIds(current))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case DeleteByQuery => Option(deleteEachByQuery(current))[0m
[0m[[0m[0mdebug[0m] [0m[0m        case PassThrough => None[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (remaining.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        send(remaining)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        response[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val response = if (messages.nonEmpty) send(messages).fold(0) { _.getStatus } else 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    log.debug("Handle the response with {}", response)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val results = messages.map([0m
[0m[[0m[0mdebug[0m] [0m[0m      m =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        WriteResult(m.idField,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.idFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.routingFieldValue,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.query,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.source,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.updates,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    m.passThrough,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    response)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    emit(out, results)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
