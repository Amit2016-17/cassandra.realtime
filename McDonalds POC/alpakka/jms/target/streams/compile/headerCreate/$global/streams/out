[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/Envelopes.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicBoolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl.{JmsAckSession, JmsSession}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class AckEnvelope private[jms] (message: jms.Message, private val jmsSession: JmsAckSession) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val processed = new AtomicBoolean(false)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def acknowledge(): Unit = if (processed.compareAndSet(false, true)) jmsSession.ack(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class TxEnvelope private[jms] (message: jms.Message, private val jmsSession: JmsSession) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] val commitPromise = Promise[() => Unit][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] val commitFuture: Future[() => Unit] = commitPromise.future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def commit(): Unit = commitPromise.success(jmsSession.session.commit _)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def rollback(): Unit = commitPromise.success(jmsSession.session.rollback _)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/javadsl/JmsProducer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.{scaladsl, JmsEnvelope, JmsMessage, JmsProducerSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory methods to create JMS producers.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsProducer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send [[akka.stream.alpakka.jms.JmsMessage JmsMessage]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow[R <: JmsMessage]([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Flow[R, R, JmsProducerStatus] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer.flow(settings).mapMaterializedValue(toProducerStatus).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send [[akka.stream.alpakka.jms.JmsEnvelope JmsEnvelope]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker to support pass-through of data.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flexiFlow[PassThrough]([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Flow[JmsEnvelope[PassThrough], JmsEnvelope[PassThrough], JmsProducerStatus] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flexiFlow[PassThrough](settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(toProducerStatus)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send [[akka.stream.alpakka.jms.JmsMessage JmsMessage]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink[R <: JmsMessage]([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Sink[R, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .sink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send Strings as text messages to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def textSink(settings: JmsProducerSettings): akka.stream.javadsl.Sink[String, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .textSink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send byte arrays to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def bytesSink(settings: JmsProducerSettings): akka.stream.javadsl.Sink[Array[Byte], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .bytesSink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send [[akka.util.ByteString ByteString]]s to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def byteStringSink(settings: JmsProducerSettings): akka.stream.javadsl.Sink[ByteString, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .byteStringSink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send map structures to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def mapSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Sink[java.util.Map[String, Any], CompletionStage[Done]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scalaSink =[0m
[0m[[0m[0mdebug[0m] [0m[0m      akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mapSink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val javaToScalaConversion =[0m
[0m[[0m[0mdebug[0m] [0m[0m      Flow.fromFunction((javaMap: java.util.Map[String, Any]) => javaMap.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m    javaToScalaConversion.toMat(scalaSink)(Keep.right).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send serialized objects to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def objectSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Sink[java.io.Serializable, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .objectSink(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(FutureConverters.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def toProducerStatus(scalaStatus: scaladsl.JmsProducerStatus) = new JmsProducerStatus {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connectorState: Source[JmsConnectorState, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      scalaStatus.connectorState.map(_.asJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/javadsl/JmsConsumer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms.Message[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory methods to create JMS consumers.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsConsumer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[javax.jms.Message]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(settings: JmsConsumerSettings): akka.stream.javadsl.Source[Message, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.apply(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting Strings, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def textSource(settings: JmsConsumerSettings): akka.stream.javadsl.Source[String, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.textSource(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting byte arrays, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def bytesSource(settings: JmsConsumerSettings): akka.stream.javadsl.Source[Array[Byte], JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.bytesSource(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting maps, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def mapSource([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsConsumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Source[java.util.Map[String, Any], JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapSource(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(toConsumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting de-serialized objects, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def objectSource([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsConsumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): akka.stream.javadsl.Source[java.io.Serializable, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.objectSource(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[akka.stream.alpakka.jms.AckEnvelope AckEnvelope]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It requires explicit acknowledgements on the envelopes. The acknowledgements must be called on the envelope and not on the message inside.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ackSource(settings: JmsConsumerSettings): akka.stream.javadsl.Source[AckEnvelope, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.ackSource(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[akka.stream.alpakka.jms.TxEnvelope TxEnvelope]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It requires explicit committing or rollback on the envelopes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def txSource(settings: JmsConsumerSettings): akka.stream.javadsl.Source[TxEnvelope, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.txSource(settings).mapMaterializedValue(toConsumerControl).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source browsing a JMS destination (which does not consume the messages)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and emitting [[javax.jms.Message]] instances.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def browse(settings: JmsBrowseSettings): akka.stream.javadsl.Source[Message, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.alpakka.jms.scaladsl.JmsConsumer.browse(settings).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def toConsumerControl(scalaControl: scaladsl.JmsConsumerControl) = new JmsConsumerControl {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connectorState(): Source[JmsConnectorState, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      scalaControl.connectorState.map(_.asJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def shutdown(): Unit = scalaControl.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def abort(ex: Throwable): Unit = scalaControl.abort(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/Credentials.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class Credentials private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val password: String[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUsername(value: String): Credentials = copy(username = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassword(value: String): Credentials = copy(password = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String = username,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String = password[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Credentials = new Credentials([0m
[0m[[0m[0mdebug[0m] [0m[0m    username = username,[0m
[0m[[0m[0mdebug[0m] [0m[0m    password = password[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "Credentials(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"username=$username," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"password=${"*" * password.length}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: Credentials =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.username, that.username) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.password, that.password)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int = java.util.Objects.hash(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Credentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config): Credentials = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val username = c.getString("username")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val password = c.getString("password")[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Credentials([0m
[0m[[0m[0mdebug[0m] [0m[0m      username,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config): Credentials = apply(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Credentials = new Credentials([0m
[0m[[0m[0mdebug[0m] [0m[0m    username,[0m
[0m[[0m[0mdebug[0m] [0m[0m    password[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Credentials = new Credentials([0m
[0m[[0m[0mdebug[0m] [0m[0m    username,[0m
[0m[[0m[0mdebug[0m] [0m[0m    password[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/Destinations.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FunctionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * A destination to send to/receive from.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait Destination {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val name: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  val create: jms.Session => jms.Destination[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Specify a topic as destination to send to/receive from.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Topic(override val name: String) extends Destination {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val create: jms.Session => jms.Destination = session => session.createTopic(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Specify a durable topic destination to send to/receive from.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class DurableTopic(name: String, subscriberName: String) extends Destination {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val create: jms.Session => jms.Destination = session => session.createTopic(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Specify a queue as destination to send to/receive from.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Queue(override val name: String) extends Destination {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val create: jms.Session => jms.Destination = session => session.createQueue(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Destination factory to create specific destinations to send to/receive from.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CustomDestination(override val name: String, override val create: jms.Session => jms.Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Destination {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(name: String, create: java.util.function.Function[jms.Session, jms.Destination]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this(name, create.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.DoNotInherit[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Shared settings for all JMS stages.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Used for internal standardization, and not meant to be used by user code.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@DoNotInherit[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait JmsSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectionFactory: jms.ConnectionFactory[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectionRetrySettings: ConnectionRetrySettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  def destination: Option[Destination][0m
[0m[[0m[0mdebug[0m] [0m[0m  def credentials: Option[Credentials][0m
[0m[[0m[0mdebug[0m] [0m[0m  def sessionCount: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/AcknowledgeMode.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * JMS acknowledge modes.[0m
[0m[[0m[0mdebug[0m] [0m[0m * See [[javax.jms.Connection#createSession-boolean-int-]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class AcknowledgeMode(val mode: Int) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: AcknowledgeMode => this.mode == that.mode[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode: Int = mode[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String = s"AcknowledgeMode(${AcknowledgeMode.asString(this)})"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject AcknowledgeMode {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val AutoAcknowledge: AcknowledgeMode = new AcknowledgeMode(jms.Session.AUTO_ACKNOWLEDGE)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ClientAcknowledge: AcknowledgeMode = new AcknowledgeMode(jms.Session.CLIENT_ACKNOWLEDGE)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val DupsOkAcknowledge: AcknowledgeMode = new AcknowledgeMode(jms.Session.DUPS_OK_ACKNOWLEDGE)[0m
[0m[[0m[0mdebug[0m] [0m[0m  val SessionTransacted: AcknowledgeMode = new AcknowledgeMode(jms.Session.SESSION_TRANSACTED)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Interpret string to corresponding acknowledge mode.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def from(s: String): AcknowledgeMode = s match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case "auto" => AutoAcknowledge[0m
[0m[[0m[0mdebug[0m] [0m[0m    case "client" => ClientAcknowledge[0m
[0m[[0m[0mdebug[0m] [0m[0m    case "duplicates-ok" => DupsOkAcknowledge[0m
[0m[[0m[0mdebug[0m] [0m[0m    case "session" => SessionTransacted[0m
[0m[[0m[0mdebug[0m] [0m[0m    case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val mode = other.toInt[0m
[0m[[0m[0mdebug[0m] [0m[0m        new AcknowledgeMode(mode)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: NumberFormatException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw new IllegalArgumentException([0m
[0m[[0m[0mdebug[0m] [0m[0m            s"can't read AcknowledgeMode '$other', (known are auto, client, duplicates-ok, session, or an integer value)"[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Convert to a string presentation.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def asString(mode: AcknowledgeMode): String = mode match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case AutoAcknowledge => "auto"[0m
[0m[[0m[0mdebug[0m] [0m[0m    case ClientAcknowledge => "client"[0m
[0m[[0m[0mdebug[0m] [0m[0m    case DupsOkAcknowledge => "duplicates-ok"[0m
[0m[[0m[0mdebug[0m] [0m[0m    case SessionTransacted => "session"[0m
[0m[[0m[0mdebug[0m] [0m[0m    case other => other.mode.toString[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsMessages.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Base interface for messages handled by JmsProducers. Sub-classes support pass-through or use [[akka.NotUsed]] as type for pass-through.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait JmsEnvelope[+PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def headers: Set[JmsHeader][0m
[0m[[0m[0mdebug[0m] [0m[0m  def properties: Map[String, Any][0m
[0m[[0m[0mdebug[0m] [0m[0m  def destination: Option[Destination][0m
[0m[[0m[0mdebug[0m] [0m[0m  def passThrough: PassThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * A stream element that does not produce a JMS message, but merely passes data through a `flexiFlow`.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param passThrough the data to pass through[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsPassThrough[+PassThrough](val passThrough: PassThrough) extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val properties: Map[String, Any] = Map.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m  val headers: Set[JmsHeader] = Set.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m  val destination: Option[Destination] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * A stream element that does not produce a JMS message, but merely passes data through a `flexiFlow`.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsPassThrough {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](passThrough: PassThrough): JmsEnvelope[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsPassThrough[PassThrough](passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](passThrough: PassThrough): JmsEnvelope[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsPassThrough[PassThrough](passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Marker trait for stream elements that do not contain pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait JmsMessage extends JmsEnvelope[NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte arrays to JMS, supports pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class JmsByteMessagePassThrough[+PassThrough] protected[jms] (val bytes: Array[Byte],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val destination: Option[Destination] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val passThrough: PassThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHeader(jmsHeader: JmsHeader): JmsByteMessagePassThrough[PassThrough] = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProperty(name: String, value: Any): JmsByteMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toQueue(name: String): JmsByteMessagePassThrough[PassThrough] = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toTopic(name: String): JmsByteMessagePassThrough[PassThrough] = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def to(destination: Destination): JmsByteMessagePassThrough[PassThrough] = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withoutDestination: JmsByteMessagePassThrough[PassThrough] = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PassThrough2](passThrough: PassThrough2): JmsByteMessagePassThrough[PassThrough2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bytes: Array[Byte] = bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsByteMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteMessagePassThrough[PassThrough]([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte arrays to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsByteMessage private (bytes: Array[Byte],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    destination: Option[Destination] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsByteMessagePassThrough[NotUsed](bytes, headers, properties, destination, NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withHeader(jmsHeader: JmsHeader): JmsByteMessage = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withProperty(name: String, value: Any): JmsByteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toQueue(name: String): JmsByteMessage = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toTopic(name: String): JmsByteMessage = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def to(destination: Destination): JmsByteMessage = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withoutDestination: JmsByteMessage = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bytes: Array[Byte] = bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsByteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte arrays to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsByteMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create a byte message with pass-through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](bytes: Array[Byte], passThrough: PassThrough): JmsByteMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteMessagePassThrough[PassThrough](bytes = bytes, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create a byte message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(bytes: Array[Byte]) = new JmsByteMessage(bytes = bytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create a byte message with pass-through[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](bytes: Array[Byte], passThrough: PassThrough): JmsByteMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteMessagePassThrough[PassThrough](bytes = bytes, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsByteMessage]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(bytes: Array[Byte]) = new JmsByteMessage(bytes = bytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte array messages to JMS from the incoming `ByteString`, supports pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class JmsByteStringMessagePassThrough[+PassThrough] protected[jms] (val bytes: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                           val headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                           val properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                           val destination: Option[Destination] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                           val passThrough: PassThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHeader(jmsHeader: JmsHeader): JmsByteStringMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProperty(name: String, value: Any): JmsByteStringMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toQueue(name: String): JmsByteStringMessagePassThrough[PassThrough] = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toTopic(name: String): JmsByteStringMessagePassThrough[PassThrough] = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def to(destination: Destination): JmsByteStringMessagePassThrough[PassThrough] = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withoutDestination: JmsByteStringMessagePassThrough[PassThrough] = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PassThrough2](passThrough: PassThrough2): JmsByteStringMessagePassThrough[PassThrough2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteStringMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bytes: ByteString = bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsByteStringMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteStringMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte array messages to JMS from the incoming `ByteString`.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsByteStringMessage private (bytes: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                          destination: Option[Destination] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsByteStringMessagePassThrough[NotUsed](bytes, headers, properties, destination, NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withHeader(jmsHeader: JmsHeader): JmsByteStringMessage = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withProperty(name: String, value: Any): JmsByteStringMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toQueue(name: String): JmsByteStringMessage = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toTopic(name: String): JmsByteStringMessage = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def to(destination: Destination): JmsByteStringMessage = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withoutDestination: JmsByteStringMessage = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(bytes: ByteString = bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsByteStringMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteStringMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m      bytes,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces byte array messages to JMS from the incoming `ByteString`.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsByteStringMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a byte message from a ByteString with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](byteString: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         passThrough: PassThrough): JmsByteStringMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteStringMessagePassThrough[PassThrough](byteString, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a byte message from a ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(byteString: ByteString) = new JmsByteStringMessage(byteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Create a byte message from a ByteString with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](byteString: ByteString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          passThrough: PassThrough): JmsByteStringMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsByteStringMessagePassThrough[PassThrough](byteString, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Create a byte message from a ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(byteString: ByteString) = apply(byteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces map messages to JMS, supports pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class JmsMapMessagePassThrough[+PassThrough] protected[jms] (val body: Map[String, Any],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                    val headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                    val properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                    val destination: Option[Destination] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                    val passThrough: PassThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHeader(jmsHeader: JmsHeader): JmsMapMessagePassThrough[PassThrough] = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProperty(name: String, value: Any): JmsMapMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toQueue(name: String): JmsMapMessagePassThrough[PassThrough] = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toTopic(name: String): JmsMapMessagePassThrough[PassThrough] = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def to(destination: Destination): JmsMapMessagePassThrough[PassThrough] = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withoutDestination: JmsMapMessagePassThrough[PassThrough] = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PassThrough2](passThrough: PassThrough2): JmsMapMessagePassThrough[PassThrough2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMapMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      body,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(body: Map[String, Any] = body,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsMapMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMapMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      body,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces map messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsMapMessage(body: Map[String, Any],[0m
[0m[[0m[0mdebug[0m] [0m[0m                          headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          destination: Option[Destination] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsMapMessagePassThrough[NotUsed](body, headers, properties, destination, NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withHeader(jmsHeader: JmsHeader): JmsMapMessage = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withProperty(name: String, value: Any): JmsMapMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toQueue(name: String): JmsMapMessage = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toTopic(name: String): JmsMapMessage = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def to(destination: Destination): JmsMapMessage = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withoutDestination: JmsMapMessage = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(body: Map[String, Any] = body,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsMapMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMapMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m      body,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces map messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsMapMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create a map message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](map: Map[String, Any], passThrough: PassThrough): JmsMapMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMapMessagePassThrough[PassThrough](body = map, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create a map message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(map: Map[String, Any]) = new JmsMapMessage(body = map)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create a map message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](map: java.util.Map[String, Any],[0m
[0m[[0m[0mdebug[0m] [0m[0m                          passThrough: PassThrough): JmsMapMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMapMessagePassThrough[PassThrough](body = map.asScala.toMap, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create map message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(map: util.Map[String, Any]) = new JmsMapMessage(body = map.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces text messages to JMS, supports pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class JmsTextMessagePassThrough[+PassThrough] protected[jms] (val body: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val destination: Option[Destination] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                     val passThrough: PassThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHeader(jmsHeader: JmsHeader): JmsTextMessagePassThrough[PassThrough] = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProperty(name: String, value: Any): JmsTextMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toQueue(name: String): JmsTextMessagePassThrough[PassThrough] = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toTopic(name: String): JmsTextMessagePassThrough[PassThrough] = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def to(destination: Destination): JmsTextMessagePassThrough[PassThrough] = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withoutDestination: JmsTextMessagePassThrough[PassThrough] = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PassThrough2](passThrough: PassThrough2): JmsTextMessagePassThrough[PassThrough2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsTextMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      body,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(body: String = body,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsTextMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsTextMessagePassThrough[PassThrough]([0m
[0m[[0m[0mdebug[0m] [0m[0m      body,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces text messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsTextMessage private (body: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    destination: Option[Destination] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsTextMessagePassThrough[NotUsed](body, headers, properties, destination, NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withHeader(jmsHeader: JmsHeader): JmsTextMessage = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withProperty(name: String, value: Any): JmsTextMessage = copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toQueue(name: String): JmsTextMessage = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toTopic(name: String): JmsTextMessage = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def to(destination: Destination): JmsTextMessage = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withoutDestination: JmsTextMessage = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(body: String = body,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsTextMessage = new JmsTextMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m    body,[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m    properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m    destination[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces text messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsTextMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a text message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](body: String, passThrough: PassThrough): JmsTextMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsTextMessagePassThrough(body = body, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a text message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(body: String): JmsTextMessage = new JmsTextMessage(body = body)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Create a text message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](body: String, passThrough: PassThrough): JmsTextMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsTextMessagePassThrough(body = body, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create a text message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(body: String): JmsTextMessage = new JmsTextMessage(body = body)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces object messages to JMS, supports pass-through data.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @tparam PassThrough the type of data passed through the `flexiFlow`[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class JmsObjectMessagePassThrough[+PassThrough] protected[jms] (val serializable: java.io.Serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       val headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       val properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       val destination: Option[Destination] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                       val passThrough: PassThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsEnvelope[PassThrough] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHeader(jmsHeader: JmsHeader): JmsObjectMessagePassThrough[PassThrough] = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProperty(name: String, value: Any): JmsObjectMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toQueue(name: String): JmsObjectMessagePassThrough[PassThrough] = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toTopic(name: String): JmsObjectMessagePassThrough[PassThrough] = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def to(destination: Destination): JmsObjectMessagePassThrough[PassThrough] = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withoutDestination: JmsObjectMessagePassThrough[PassThrough] = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassThrough[PassThrough2](passThrough: PassThrough2): JmsObjectMessagePassThrough[PassThrough2] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsObjectMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(serializable: java.io.Serializable = serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsObjectMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsObjectMessagePassThrough([0m
[0m[[0m[0mdebug[0m] [0m[0m      serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passThrough[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces object messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsObjectMessage private (serializable: java.io.Serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      headers: Set[JmsHeader] = Set.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      properties: Map[String, Any] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      destination: Option[Destination] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsObjectMessagePassThrough[NotUsed](serializable, headers, properties, destination, NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a Jms header e.g. JMSType[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withHeader(jmsHeader: JmsHeader): JmsObjectMessage = copy(headers = headers + jmsHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Add a property[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withProperty(name: String, value: Any): JmsObjectMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(properties = properties + (name -> value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toQueue(name: String): JmsObjectMessage = to(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toTopic(name: String): JmsObjectMessage = to(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def to(destination: Destination): JmsObjectMessage = copy(destination = Some(destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def withoutDestination: JmsObjectMessage = copy(destination = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(serializable: java.io.Serializable = serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   headers: Set[JmsHeader] = headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   properties: Map[String, Any] = properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   destination: Option[Destination] = destination): JmsObjectMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsObjectMessage([0m
[0m[[0m[0mdebug[0m] [0m[0m      serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      properties,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Produces object messages to JMS.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsObjectMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create an object message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[PassThrough](serializable: java.io.Serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         passThrough: PassThrough): JmsObjectMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsObjectMessagePassThrough[PassThrough](serializable, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create an object message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(serializable: java.io.Serializable) = new JmsObjectMessage(serializable)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create an object message with a pass-through attached[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[PassThrough](serializable: java.io.Serializable,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          passThrough: PassThrough): JmsObjectMessagePassThrough[PassThrough] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsObjectMessagePassThrough[PassThrough](serializable, passThrough = passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create an object message[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(serializable: Serializable) = new JmsObjectMessage(serializable)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/Headers.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Indicates if this header must be set during the send() operation according to the JMS specification or as attribute of the jms message before.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def usedDuringSend: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsCorrelationId(jmsCorrelationId: String) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = false[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsCorrelationId {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsCorrelationId]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(correlationId: String) = JmsCorrelationId(correlationId)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsReplyTo(jmsDestination: Destination) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = false[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsReplyTo {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reply to a queue with given name.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def queue(name: String) = JmsReplyTo(Queue(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reply to a topic with given name.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def topic(name: String) = JmsReplyTo(Topic(name))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsType(jmsType: String) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = false[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsType {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(jmsType: String) = JmsType(jmsType)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsTimeToLive(timeInMillis: Long) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = true[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsTimeToLive {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: create [[JmsTimeToLive]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(timeToLive: Duration): JmsTimeToLive = JmsTimeToLive(timeToLive.toMillis)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsTimeToLive]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(timeToLive: Long, unit: TimeUnit) = JmsTimeToLive(unit.toMillis(timeToLive))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Priority of a message can be between 0 (lowest) and 9 (highest). The default priority is 4.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsPriority(priority: Int) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = true[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsPriority {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsPriority]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(priority: Int) = JmsPriority(priority)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Delivery mode can be [[javax.jms.DeliveryMode.NON_PERSISTENT]] or [[javax.jms.DeliveryMode.PERSISTENT]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class JmsDeliveryMode(deliveryMode: Int) extends JmsHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val usedDuringSend = true[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsDeliveryMode {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: create [[JmsDeliveryMode]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(deliveryMode: Int) = JmsDeliveryMode(deliveryMode)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/SendRetrySettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * When a connection to a broker starts failing, sending JMS messages will also fail.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Those failed messages can be retried at the cost of potentially duplicating the failed messages.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class SendRetrySettings private (val initialRetry: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       val backoffFactor: Double,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       val maxBackoff: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       val maxRetries: Int) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Wait time before retrying the first time. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInitialRetry(value: scala.concurrent.duration.FiniteDuration): SendRetrySettings = copy(initialRetry = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Wait time before retrying the first time. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInitialRetry(value: java.time.Duration): SendRetrySettings = copy(initialRetry = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Back-off factor for subsequent retries */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBackoffFactor(value: Double): SendRetrySettings = copy(backoffFactor = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Maximum back-off time allowed, after which all retries will happen after this delay. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxBackoff(value: scala.concurrent.duration.FiniteDuration): SendRetrySettings = copy(maxBackoff = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Maximum back-off time allowed, after which all retries will happen after this delay. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxBackoff(value: java.time.Duration): SendRetrySettings = copy(maxBackoff = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Maximum number of retries allowed. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxRetries(value: Int): SendRetrySettings = copy(maxRetries = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Do not limit the number of retries. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInfiniteRetries(): SendRetrySettings = withMaxRetries(SendRetrySettings.infiniteRetries)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The wait time before the next attempt may be made. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def waitTime(retryNumber: Int): FiniteDuration =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (initialRetry * Math.pow(retryNumber, backoffFactor)).asInstanceOf[FiniteDuration].min(maxBackoff)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      initialRetry: scala.concurrent.duration.FiniteDuration = initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m      backoffFactor: Double = backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxBackoff: scala.concurrent.duration.FiniteDuration = maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxRetries: Int = maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SendRetrySettings = new SendRetrySettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    initialRetry = initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m    backoffFactor = backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m    maxBackoff = maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m    maxRetries = maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "SendRetrySettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"initialRetry=${initialRetry.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"backoffFactor=$backoffFactor," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"maxBackoff=${maxBackoff.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"maxRetries=${if (maxRetries == SendRetrySettings.infiniteRetries) "infinite" else maxRetries}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SendRetrySettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.jms.send-retry"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val infiniteRetries: Int = -1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config): SendRetrySettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val initialRetry = c.getDuration("initial-retry").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    val backoffFactor = c.getDouble("backoff-factor")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxBackoff = c.getDuration("max-backoff").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxRetries = if (c.getString("max-retries") == "infinite") infiniteRetries else c.getInt("max-retries")[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SendRetrySettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m      backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config): SendRetrySettings = apply(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the default config provided by the actor system at `alpakka.jms.send-retry`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(actorSystem: ActorSystem): SendRetrySettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config.getConfig(configPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the default config provided by the actor system at `alpakka.jms.send-retry`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(actorSystem: ActorSystem): SendRetrySettings = apply(actorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsExceptions.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.TimeoutException[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Marker trait indicating that the exception thrown is persistent. The operation will always fail when retried.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait NonRetriableJmsException extends Exception[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class UnsupportedMessagePropertyType(propertyName: String, propertyValue: Any, message: JmsEnvelope[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception([0m
[0m[[0m[0mdebug[0m] [0m[0m      s"Jms property '$propertyName' has unknown type '${propertyValue.getClass.getName}'. " +[0m
[0m[[0m[0mdebug[0m] [0m[0m      "Only primitive types and String are supported as property values."[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    with NonRetriableJmsException[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class NullMessageProperty(propertyName: String, message: JmsEnvelope[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception([0m
[0m[[0m[0mdebug[0m] [0m[0m      s"null value was given for Jms property '$propertyName'."[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    with NonRetriableJmsException[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class UnsupportedMapMessageEntryType(entryName: String, entryValue: Any, message: JmsMapMessagePassThrough[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception([0m
[0m[[0m[0mdebug[0m] [0m[0m      s"Jms MapMessage entry '$entryName' has unknown type '${entryValue.getClass.getName}'. " +[0m
[0m[[0m[0mdebug[0m] [0m[0m      "Only primitive types, String, and Byte array are supported as entry values."[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    with NonRetriableJmsException[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class NullMapMessageEntry(entryName: String, message: JmsMapMessagePassThrough[_])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception([0m
[0m[[0m[0mdebug[0m] [0m[0m      s"null value was given for Jms MapMessage entry '$entryName'."[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    with NonRetriableJmsException[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class ConnectionRetryException(message: String, cause: Throwable) extends Exception(message, cause)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object RetrySkippedOnMissingConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception("JmsProducer is not connected, send attempt skipped")[0m
[0m[[0m[0mdebug[0m] [0m[0m    with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class StopMessageListenerException() extends Exception("Stopping MessageListener.")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object JmsNotConnected extends Exception("JmsConnector is not connected") with NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class JmsConnectTimedOut(message: String) extends TimeoutException(message)[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/scaladsl/package.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl.InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage object scaladsl {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[scaladsl] def transformConnectorState(source: Source[InternalConnectionState, NotUsed]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import InternalConnectionState._[0m
[0m[[0m[0mdebug[0m] [0m[0m    source.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorDisconnected => JmsConnectorState.Disconnected[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _: JmsConnectorConnected => JmsConnectorState.Connected[0m
[0m[[0m[0mdebug[0m] [0m[0m      case i: JmsConnectorInitializing => JmsConnectorState.Connecting(i.attempt + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorStopping(Success(Done)) => JmsConnectorState.Completing[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorStopping(Failure(t)) => JmsConnectorState.Failing(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorStopped(Success(Done)) => JmsConnectorState.Completed[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorStopped(Failure(t)) => JmsConnectorState.Failed(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/scaladsl/JmsProducer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl.{JmsProducerMatValue, JmsProducerStage}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory methods to create JMS producers.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsProducer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send [[akka.stream.alpakka.jms.JmsMessage JmsMessage]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow[T <: JmsMessage](settings: JmsProducerSettings): Flow[T, T, JmsProducerStatus] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => throw new IllegalArgumentException(noProducerDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(destination) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[T][0m
[0m[[0m[0mdebug[0m] [0m[0m          .viaMat(Flow.fromGraph(new JmsProducerStage[T, NotUsed](settings, destination)))(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapMaterializedValue(toProducerStatus)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to send [[akka.stream.alpakka.jms.JmsEnvelope JmsEnvelope]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker to support pass-through of data.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flexiFlow[PassThrough]([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: JmsProducerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[JmsEnvelope[PassThrough], JmsEnvelope[PassThrough], JmsProducerStatus] = settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case None => throw new IllegalArgumentException(noProducerDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Some(destination) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m        .fromGraph(new JmsProducerStage[JmsEnvelope[PassThrough], PassThrough](settings, destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mapMaterializedValue(toProducerStatus)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send [[akka.stream.alpakka.jms.JmsMessage JmsMessage]] sub-classes to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink(settings: JmsProducerSettings): Sink[JmsMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    flow(settings).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send Strings as text messages to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def textSink(settings: JmsProducerSettings): Sink[String, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromFunction((s: String) => JmsTextMessage(s)).via(flow(settings)).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send byte arrays to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def bytesSink(settings: JmsProducerSettings): Sink[Array[Byte], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromFunction((s: Array[Byte]) => JmsByteMessage(s)).via(flow(settings)).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send [[akka.util.ByteString ByteString]]s to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def byteStringSink(settings: JmsProducerSettings): Sink[ByteString, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromFunction((s: ByteString) => JmsByteStringMessage(s)).via(flow(settings)).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send map structures to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def mapSink(settings: JmsProducerSettings): Sink[Map[String, Any], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromFunction((s: Map[String, Any]) => JmsMapMessage(s)).via(flow(settings)).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to send serialized objects to a JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def objectSink(settings: JmsProducerSettings): Sink[java.io.Serializable, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFunction((s: java.io.Serializable) => JmsObjectMessage(s))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(flow(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def toProducerStatus(internal: JmsProducerMatValue) = new JmsProducerStatus {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connectorState: Source[JmsConnectorState, NotUsed] = transformConnectorState(internal.connected)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def noProducerDestination(settings: JmsProducerSettings) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""Unable to create JmsProducer: it needs a default destination to send messages to, but none was provided in[0m
[0m[[0m[0mdebug[0m] [0m[0m      |$settings[0m
[0m[[0m[0mdebug[0m] [0m[0m      |Please use withQueue, withTopic or withDestination to specify a destination.""".stripMargin[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/scaladsl/JmsConnectorState.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.KillSwitch[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.scaladsl.JmsConnectorState._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait JmsProducerStatus {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * source that provides connector status change information.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Only the most recent connector state is buffered if the source is not consumed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectorState: Source[JmsConnectorState, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Handle to shut down consumers and to inspect the connectivity to the JMS broker.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait JmsConsumerControl extends KillSwitch {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * source that provides connector status change information.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Only the most recent connector state is buffered if the source is not consumed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectorState: Source[JmsConnectorState, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait JmsConnectorState {[0m
[0m[[0m[0mdebug[0m] [0m[0m  final def asJava: javadsl.JmsConnectorState = this match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Disconnected => javadsl.JmsConnectorState.Disconnected[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Connecting(_) => javadsl.JmsConnectorState.Connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Connected => javadsl.JmsConnectorState.Connected[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Completing => javadsl.JmsConnectorState.Completing[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Completed => javadsl.JmsConnectorState.Completed[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Failing(_) => javadsl.JmsConnectorState.Failing[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Failed(_) => javadsl.JmsConnectorState.Failed[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsConnectorState {[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Disconnected extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Connecting(attempt: Int) extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Connected extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Completing extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Completed extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Failing(exception: Throwable) extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Failed(exception: Throwable) extends JmsConnectorState[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/scaladsl/JmsConsumer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory methods to create JMS consumers.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsConsumer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[javax.jms.Message]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: JmsConsumerSettings): Source[javax.jms.Message, JmsConsumerControl] = settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case None => throw new IllegalArgumentException(noConsumerDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Some(destination) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Source.fromGraph(new JmsConsumerStage(settings, destination)).mapMaterializedValue(toConsumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting Strings, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def textSource(settings: JmsConsumerSettings): Source[String, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(settings).map(msg => msg.asInstanceOf[jms.TextMessage].getText)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting maps, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def mapSource(settings: JmsConsumerSettings): Source[Map[String, Any], JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(settings).map { msg =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mapMessage = msg.asInstanceOf[jms.MapMessage][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      mapMessage.getMapNames.asScala.foldLeft(Map[String, Any]()) { (result, key) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val keyAsString = key.toString[0m
[0m[[0m[0mdebug[0m] [0m[0m        val value = mapMessage.getObject(keyAsString)[0m
[0m[[0m[0mdebug[0m] [0m[0m        result.+(keyAsString -> value)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting byte arrays, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def bytesSource(settings: JmsConsumerSettings): Source[Array[Byte], JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(settings).map { msg =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val byteMessage = msg.asInstanceOf[jms.BytesMessage][0m
[0m[[0m[0mdebug[0m] [0m[0m      val byteArray = new Array[Byte](byteMessage.getBodyLength.toInt)[0m
[0m[[0m[0mdebug[0m] [0m[0m      byteMessage.readBytes(byteArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m      byteArray[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting de-serialized objects, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def objectSource(settings: JmsConsumerSettings): Source[java.io.Serializable, JmsConsumerControl] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(settings).map(msg => msg.asInstanceOf[jms.ObjectMessage].getObject)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[akka.stream.alpakka.jms.AckEnvelope AckEnvelope]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It requires explicit acknowledgements on the envelopes. The acknowledgements must be called on the envelope and not on the message inside.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ackSource(settings: JmsConsumerSettings): Source[AckEnvelope, JmsConsumerControl] = settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case None => throw new IllegalArgumentException(noConsumerDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Some(destination) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Source.fromGraph(new JmsAckSourceStage(settings, destination)).mapMaterializedValue(toConsumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source emitting [[akka.stream.alpakka.jms.TxEnvelope TxEnvelope]] instances, and materializes a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * control instance to shut down the consumer.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It requires explicit committing or rollback on the envelopes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def txSource(settings: JmsConsumerSettings): Source[TxEnvelope, JmsConsumerControl] = settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case None => throw new IllegalArgumentException(noConsumerDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Some(destination) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Source.fromGraph(new JmsTxSourceStage(settings, destination)).mapMaterializedValue(toConsumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Creates a source browsing a JMS destination (which does not consume the messages)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and emitting [[javax.jms.Message]] instances.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Completes: when all messages have been read[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def browse(settings: JmsBrowseSettings): Source[javax.jms.Message, NotUsed] = settings.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case None => throw new IllegalArgumentException(noBrowseDestination(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Some(destination) => Source.fromGraph(new JmsBrowseStage(settings, destination))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def noConsumerDestination(settings: JmsConsumerSettings) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""Unable to create JmsConsumer: its needs a destination to read messages from, but none was provided in[0m
[0m[[0m[0mdebug[0m] [0m[0m       |$settings[0m
[0m[[0m[0mdebug[0m] [0m[0m       |Please use withQueue, withTopic or withDestination to specify a destination.""".stripMargin[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def noBrowseDestination(settings: JmsBrowseSettings) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""Unable to create JmsConsumer browser: its needs a destination to read messages from, but none was provided in[0m
[0m[[0m[0mdebug[0m] [0m[0m       |$settings[0m
[0m[[0m[0mdebug[0m] [0m[0m       |Please use withQueue or withDestination to specify a destination.""".stripMargin[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def toConsumerControl(internal: JmsConsumerMatValue) = new JmsConsumerControl {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def shutdown(): Unit = internal.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def abort(ex: Throwable): Unit = internal.abort(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connectorState: Source[JmsConnectorState, NotUsed] = transformConnectorState(internal.connected)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsConsumerSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.{Config, ConfigValueType}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Settings for [[akka.stream.alpakka.jms.scaladsl.JmsConsumer]] and [[akka.stream.alpakka.jms.javadsl.JmsConsumer]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsConsumerSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionFactory: javax.jms.ConnectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings: ConnectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination: Option[Destination],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: Option[Credentials],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sessionCount: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bufferSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val selector: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val acknowledgeMode: Option[AcknowledgeMode],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ackTimeout: scala.concurrent.duration.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends akka.stream.alpakka.jms.JmsSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Factory to use for creating JMS connections. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionFactory(value: javax.jms.ConnectionFactory): JmsConsumerSettings = copy(connectionFactory = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Configure connection retrying. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionRetrySettings(value: ConnectionRetrySettings): JmsConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectionRetrySettings = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a queue name to read from. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withQueue(name: String): JmsConsumerSettings = copy(destination = Some(Queue(name)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a topic name to listen to. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTopic(name: String): JmsConsumerSettings = copy(destination = Some(Topic(name)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a durable topic name to listen to, with a unique subscriber name. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDurableTopic(name: String, subscriberName: String): JmsConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(destination = Some(DurableTopic(name, subscriberName)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a JMS to subscribe to. Allows for custom handling with [[akka.stream.alpakka.jms.CustomDestination CustomDestination]]. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDestination(value: Destination): JmsConsumerSettings = copy(destination = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use withCredentials instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredential(value: Credentials): JmsConsumerSettings = copy(credentials = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set JMS broker credentials. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: Credentials): JmsConsumerSettings = copy(credentials = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Number of parallel sessions to use for receiving JMS messages.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSessionCount(value: Int): JmsConsumerSettings = copy(sessionCount = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Buffer size for maximum number for messages read from JMS when there is no demand (or acks are pending for acknowledged consumers). */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBufferSize(value: Int): JmsConsumerSettings = copy(bufferSize = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JMS selector expression.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.oracle.com/cd/E19798-01/821-1841/bncer/index.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSelector(value: String): JmsConsumerSettings = copy(selector = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set an explicit acknowledge mode. (Consumers have specific defaults.) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAcknowledgeMode(value: AcknowledgeMode): JmsConsumerSettings = copy(acknowledgeMode = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Timeout for acknowledge. (Used by TX consumers.) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAckTimeout(value: scala.concurrent.duration.Duration): JmsConsumerSettings = copy(ackTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Timeout for acknowledge. (Used by TX consumers.) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAckTimeout(value: java.time.Duration): JmsConsumerSettings = copy(ackTimeout = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory: javax.jms.ConnectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings: ConnectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination: Option[Destination] = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: Option[Credentials] = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sessionCount: Int = sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferSize: Int = bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      selector: Option[String] = selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m      acknowledgeMode: Option[AcknowledgeMode] = acknowledgeMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m      ackTimeout: scala.concurrent.duration.Duration = ackTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): JmsConsumerSettings = new JmsConsumerSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    destination = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    sessionCount = sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferSize = bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m    selector = selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m    acknowledgeMode = acknowledgeMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m    ackTimeout = ackTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "JmsConsumerSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionFactory=$connectionFactory," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionRetrySettings=$connectionRetrySettings," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"destination=$destination," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"credentials=$credentials," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"sessionCount=$sessionCount," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"bufferSize=$bufferSize," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"selector=$selector," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"acknowledgeMode=${acknowledgeMode.map(m => AcknowledgeMode.asString(m))}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"ackTimeout=${ackTimeout.toCoarsest}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsConsumerSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.jms.consumer"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsConsumerSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getOption[A](path: String, read: Config => A): Option[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(path) && (c.getValue(path).valueType() != ConfigValueType.STRING || c.getString(path) != "off"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        Some(read(c))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else None[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getStringOption(path: String): Option[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(path) && c.getString(path).nonEmpty) Some(c.getString(path)) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings = ConnectionRetrySettings(c.getConfig("connection-retry"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination = None[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials = getOption("credentials", c => Credentials(c.getConfig("credentials")))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sessionCount = c.getInt("session-count")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bufferSize = c.getInt("buffer-size")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val selector = getStringOption("selector")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val acknowledgeMode =[0m
[0m[[0m[0mdebug[0m] [0m[0m      getOption("acknowledge-mode", c => AcknowledgeMode.from(c.getString("acknowledge-mode")))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ackTimeout = c.getDuration("ack-timeout").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsConsumerSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m      acknowledgeMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m      ackTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the default config provided by the actor system at `alpakka.jms.consumer`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config.getConfig(configPath), connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(c, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the default config provided by the actor system at `alpakka.jms.consumer`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsProducerSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.{Config, ConfigValueType}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Settings for [[akka.stream.alpakka.jms.scaladsl.JmsProducer]] and [[akka.stream.alpakka.jms.javadsl.JmsProducer]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsProducerSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionFactory: javax.jms.ConnectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings: ConnectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sendRetrySettings: SendRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination: Option[Destination],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: Option[Credentials],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sessionCount: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val timeToLive: Option[scala.concurrent.duration.Duration][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends akka.stream.alpakka.jms.JmsSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Factory to use for creating JMS connections. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionFactory(value: javax.jms.ConnectionFactory): JmsProducerSettings = copy(connectionFactory = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Configure connection retrying. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionRetrySettings(value: ConnectionRetrySettings): JmsProducerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectionRetrySettings = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Configure re-sending. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSendRetrySettings(value: SendRetrySettings): JmsProducerSettings = copy(sendRetrySettings = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a queue name as JMS destination. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withQueue(name: String): JmsProducerSettings = copy(destination = Some(Queue(name)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a topic name as JMS destination. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTopic(name: String): JmsProducerSettings = copy(destination = Some(Topic(name)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a JMS destination. Allows for custom handling with [[akka.stream.alpakka.jms.CustomDestination CustomDestination]]. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDestination(value: Destination): JmsProducerSettings = copy(destination = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("use withCredentials instead", "1.0-M1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredential(value: Credentials): JmsProducerSettings = copy(credentials = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set JMS broker credentials. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: Credentials): JmsProducerSettings = copy(credentials = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Number of parallel sessions to use for sending JMS messages.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Increasing the number of parallel sessions increases throughput at the cost of message ordering.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * While the messages may arrive out of order on the JMS broker, the producer flow outputs messages[0m
[0m[[0m[0mdebug[0m] [0m[0m   * in the order they are received.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSessionCount(value: Int): JmsProducerSettings = copy(sessionCount = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Time messages should be kept on the JMS broker. This setting can be overridden on[0m
[0m[[0m[0mdebug[0m] [0m[0m   * individual messages. If not set, messages will never expire.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTimeToLive(value: scala.concurrent.duration.Duration): JmsProducerSettings = copy(timeToLive = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Time messages should be kept on the JMS broker. This setting can be overridden on[0m
[0m[[0m[0mdebug[0m] [0m[0m   * individual messages. If not set, messages will never expire.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTimeToLive(value: java.time.Duration): JmsProducerSettings = copy(timeToLive = Option(value).map(_.asScala))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory: javax.jms.ConnectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings: ConnectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sendRetrySettings: SendRetrySettings = sendRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination: Option[Destination] = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: Option[Credentials] = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sessionCount: Int = sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m      timeToLive: Option[scala.concurrent.duration.Duration] = timeToLive[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): JmsProducerSettings = new JmsProducerSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    sendRetrySettings = sendRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    destination = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    sessionCount = sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m    timeToLive = timeToLive[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "JmsProducerSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionFactory=$connectionFactory," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionRetrySettings=$connectionRetrySettings," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"sendRetrySettings=$sendRetrySettings," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"destination=$destination," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"credentials=$credentials," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"sessionCount=$sessionCount," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"timeToLive=${timeToLive.map(_.toCoarsest)}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsProducerSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.jms.producer"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsProducerSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getOption[A](path: String, read: Config => A): Option[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(path) && (c.getValue(path).valueType() != ConfigValueType.STRING || c.getString(path) != "off"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        Some(read(c))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings = ConnectionRetrySettings(c.getConfig("connection-retry"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sendRetrySettings = SendRetrySettings(c.getConfig("send-retry"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials = getOption("credentials", c => Credentials(c.getConfig("credentials")))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sessionCount = c.getInt("session-count")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val timeToLive = getOption("time-to-live", _.getDuration("time-to-live").asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsProducerSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sendRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sessionCount,[0m
[0m[[0m[0mdebug[0m] [0m[0m      timeToLive[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the default config provided by the actor system at `alpakka.jms.producer`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsProducerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config.getConfig(configPath), connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsProducerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(c, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the default config provided by the actor system at `alpakka.jms.producer`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsProducerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsProducerStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.ActorAttributes.SupervisionStrategy[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.impl.Buffer[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.OptionVal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NoStackTrace[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate trait JmsProducerConnector extends JmsConnector[JmsProducerSession] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  this: TimerGraphStageLogic with StageLogging =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final def createSession(connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                    createDestination: jms.Session => jms.Destination): JmsProducerSession = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val session = connection.createSession(false, AcknowledgeMode.AutoAcknowledge.mode)[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsProducerSession(connection, session, createDestination(session))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val startConnection = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val status: JmsProducerMatValue = new JmsProducerMatValue {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connected: Source[InternalConnectionState, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      Source.fromFuture(connectionStateSource).flatMapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsProducerStage[E <: JmsEnvelope[PassThrough], PassThrough](settings: JmsProducerSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                                      destination: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[FlowShape[E, E], JmsProducerMatValue] { stage =>[0m
[0m[[0m[0mdebug[0m] [0m[0m  import JmsProducerStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[E]("JmsProducer.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[E]("JmsProducer.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: FlowShape[E, E] = FlowShape.of(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes.name("JmsProducer") and ActorAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue([0m
[0m[[0m[0mdebug[0m] [0m[0m      inheritedAttributes: Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): (GraphStageLogic, JmsProducerMatValue) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic: TimerGraphStageLogic with JmsProducerConnector = producerLogic(inheritedAttributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, logic.status)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def producerLogic(inheritedAttributes: Attributes) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new TimerGraphStageLogic(shape) with JmsProducerConnector with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      /*[0m
[0m[[0m[0mdebug[0m] [0m[0m       * NOTE: the following code is heavily inspired by akka.stream.impl.fusing.MapAsync[0m
[0m[[0m[0mdebug[0m] [0m[0m       *[0m
[0m[[0m[0mdebug[0m] [0m[0m       * To get a condensed view of what the buffers and handler behavior is about, have a look there too.[0m
[0m[[0m[0mdebug[0m] [0m[0m       */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private lazy val decider = inheritedAttributes.mandatoryAttribute[SupervisionStrategy].decider[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // the current connection epoch. Reconnects increment this epoch by 1.[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var currentJmsProducerEpoch = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // available producers for sending messages. Initially full, but might contain less elements if[0m
[0m[[0m[0mdebug[0m] [0m[0m      // messages are currently in-flight.[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val jmsProducers: Buffer[JmsMessageProducer] = Buffer(settings.sessionCount, settings.sessionCount)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // in-flight messages with the producers that were used to send them.[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val inFlightMessages: Buffer[Holder[E]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m        Buffer(settings.sessionCount, settings.sessionCount)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected val destination: Destination = stage.destination[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected val jmsSettings: JmsProducerSettings = settings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        super.preStart()[0m
[0m[[0m[0mdebug[0m] [0m[0m        ec = executionContext(inheritedAttributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m        initSessionAsync()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def onSessionOpened(jmsSession: JmsProducerSession): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        sessionOpened(Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          jmsProducers.enqueue(JmsMessageProducer(jmsSession, settings, currentJmsProducerEpoch))[0m
[0m[[0m[0mdebug[0m] [0m[0m          // startup situation: while producer pool was empty, the out port might have pulled. If so, pull from in port.[0m
[0m[[0m[0mdebug[0m] [0m[0m          // Note that a message might be already in-flight; that's fine since this stage pre-fetches message from[0m
[0m[[0m[0mdebug[0m] [0m[0m          // upstream anyway to increase throughput once the stream is started.[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (isAvailable(out)) pullIfNeeded()[0m
[0m[[0m[0mdebug[0m] [0m[0m        })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def connectionFailed(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsProducers.clear()[0m
[0m[[0m[0mdebug[0m] [0m[0m        currentJmsProducerEpoch += 1[0m
[0m[[0m[0mdebug[0m] [0m[0m        super.connectionFailed(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPull(): Unit = pushNextIfPossible()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onDownstreamFinish(): Unit = publishAndCompleteStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        in,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onUpstreamFinish(): Unit = if (inFlightMessages.isEmpty) publishAndCompleteStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onUpstreamFailure(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            jmsSessions.foreach(s => Try(s.closeSession()))[0m
[0m[[0m[0mdebug[0m] [0m[0m            publishAndFailStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val elem: E = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            elem match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case _: JmsPassThrough[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val holder = new Holder[E](NotYetThere)[0m
[0m[[0m[0mdebug[0m] [0m[0m                inFlightMessages.enqueue(holder)[0m
[0m[[0m[0mdebug[0m] [0m[0m                holder(Success(elem))[0m
[0m[[0m[0mdebug[0m] [0m[0m                pushNextIfPossible()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case m: JmsEnvelope[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                // create a holder object to capture the in-flight message, and enqueue it to preserve message order[0m
[0m[[0m[0mdebug[0m] [0m[0m                val holder = new Holder[E](NotYetThere)[0m
[0m[[0m[0mdebug[0m] [0m[0m                inFlightMessages.enqueue(holder)[0m
[0m[[0m[0mdebug[0m] [0m[0m                sendWithRetries(SendAttempt(m.asInstanceOf[E], holder))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            // immediately ask for the next element if producers are available.[0m
[0m[[0m[0mdebug[0m] [0m[0m            pullIfNeeded()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def publishAndCompleteStage(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val previous = updateState(InternalConnectionState.JmsConnectorStopping(Success(Done)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsSessions.foreach(_.closeSession())[0m
[0m[[0m[0mdebug[0m] [0m[0m        JmsConnector.connection(previous).foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m        completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onTimer(timerKey: Any): Unit = timerKey match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case s: SendAttempt[E @unchecked] => sendWithRetries(s)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ => super.onTimer(timerKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def sendWithRetries(send: SendAttempt[E]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        import send._[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (jmsProducers.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val jmsProducer: JmsMessageProducer = jmsProducers.dequeue()[0m
[0m[[0m[0mdebug[0m] [0m[0m          Future(jmsProducer.send(envelope)).andThen {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case tried => sendCompletedCB.invoke((send, tried, jmsProducer))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          nextTryOrFail(send, RetrySkippedOnMissingConnection)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def nextTryOrFail(send: SendAttempt[E], ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        import send._[0m
[0m[[0m[0mdebug[0m] [0m[0m        import settings.sendRetrySettings._[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (maxRetries < 0 || attempt + 1 <= maxRetries) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val nextAttempt = attempt + 1[0m
[0m[[0m[0mdebug[0m] [0m[0m          val delay = if (backoffMaxed) maxBackoff else waitTime(nextAttempt)[0m
[0m[[0m[0mdebug[0m] [0m[0m          val backoffNowMaxed = backoffMaxed || delay == maxBackoff[0m
[0m[[0m[0mdebug[0m] [0m[0m          scheduleOnce(send.copy(attempt = nextAttempt, backoffMaxed = backoffNowMaxed), delay)[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          holder(Failure(ex))[0m
[0m[[0m[0mdebug[0m] [0m[0m          handleFailure(ex, holder)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val sendCompletedCB = getAsyncCallback[(SendAttempt[E], Try[Unit], JmsMessageProducer)] {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (send, outcome, jmsProducer) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          // same epoch indicates that the producer belongs to the current alive connection.[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (jmsProducer.epoch == currentJmsProducerEpoch) jmsProducers.enqueue(jmsProducer)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          import send._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          outcome match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Success(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              holder(Success(send.envelope))[0m
[0m[[0m[0mdebug[0m] [0m[0m              pushNextIfPossible()[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Failure(t: jms.JMSException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              nextTryOrFail(send, t)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Failure(t) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              holder(Failure(t))[0m
[0m[[0m[0mdebug[0m] [0m[0m              handleFailure(t, holder)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit = finishStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def pullIfNeeded(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (jmsProducers.nonEmpty // only pull if a producer is available in the pool.[0m
[0m[[0m[0mdebug[0m] [0m[0m            && !inFlightMessages.isFull // and a place is available in the in-flight queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m            && !hasBeenPulled(in))[0m
[0m[[0m[0mdebug[0m] [0m[0m          tryPull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def pushNextIfPossible(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (inFlightMessages.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          // no messages in flight, are we about to complete?[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (isClosed(in)) publishAndCompleteStage() else pullIfNeeded()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (inFlightMessages.peek().elem eq NotYetThere) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          // next message to be produced is still not there, we need to wait.[0m
[0m[[0m[0mdebug[0m] [0m[0m          pullIfNeeded()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (isAvailable(out)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val holder = inFlightMessages.dequeue()[0m
[0m[[0m[0mdebug[0m] [0m[0m          holder.elem match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Success(elem) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, elem)[0m
[0m[[0m[0mdebug[0m] [0m[0m              pullIfNeeded() // Ask for the next element.[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Failure(ex) => handleFailure(ex, holder)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def handleFailure(ex: Throwable, holder: Holder[E]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        holder.supervisionDirectiveFor(decider, ex) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Supervision.Stop => failStage(ex) // fail only if supervision asks for it.[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => pushNextIfPossible()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] object JmsProducerStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val NotYetThere = Failure(new Exception with NoStackTrace)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /*[0m
[0m[[0m[0mdebug[0m] [0m[0m   * NOTE: the following code is heavily inspired by akka.stream.impl.fusing.MapAsync[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * To get a condensed view of what the Holder is about, have a look there too.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  class Holder[A](var elem: Try[A]) extends (Try[A] => Unit) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // To support both fail-fast when the supervision directive is Stop[0m
[0m[[0m[0mdebug[0m] [0m[0m    // and not calling the decider multiple times, we need to cache the decider result and re-use that[0m
[0m[[0m[0mdebug[0m] [0m[0m    private var cachedSupervisionDirective: OptionVal[Supervision.Directive] = OptionVal.None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def supervisionDirectiveFor(decider: Supervision.Decider, ex: Throwable): Supervision.Directive =[0m
[0m[[0m[0mdebug[0m] [0m[0m      cachedSupervisionDirective match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case OptionVal.Some(d) => d[0m
[0m[[0m[0mdebug[0m] [0m[0m        case OptionVal.None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val d = decider(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m          cachedSupervisionDirective = OptionVal.Some(d)[0m
[0m[[0m[0mdebug[0m] [0m[0m          d[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def apply(t: Try[A]): Unit = elem = t[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class SendAttempt[E <: JmsEnvelope[_]](envelope: E,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              holder: Holder[E],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              attempt: Int = 0,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              backoffMaxed: Boolean = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/SoftReferenceCache.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.mutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.ref.SoftReference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SoftReferenceCache[K, V <: AnyRef] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val cache = mutable.HashMap[K, SoftReference[V]]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def lookup(key: K, default: => V): V =[0m
[0m[[0m[0mdebug[0m] [0m[0m    cache.get(key) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(ref) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        ref.get match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(value) => value[0m
[0m[[0m[0mdebug[0m] [0m[0m          case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            purgeCache() // facing a garbage collected soft reference, purge other entries.[0m
[0m[[0m[0mdebug[0m] [0m[0m            update(key, default)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => update(key, default)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def update(key: K, value: V): V = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    cache.put(key, new SoftReference(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m    value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def purgeCache(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    cache --= cache.collect { case (key, ref) if ref.get.isEmpty => key }.toVector[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsConsumerStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.Semaphore[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsConsumerStage(settings: JmsConsumerSettings, destination: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[jms.Message], JmsConsumerMatValue] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[jms.Message]("JmsConsumer.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes = Attributes.name("JmsConsumer")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: SourceShape[jms.Message] = SourceShape[jms.Message](out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue([0m
[0m[[0m[0mdebug[0m] [0m[0m      inheritedAttributes: Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): (GraphStageLogic, JmsConsumerMatValue) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new SourceStageLogic[jms.Message](shape, out, settings, destination, inheritedAttributes) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val bufferSize = (settings.bufferSize + 1) * settings.sessionCount[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val backpressure = new Semaphore(bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def createSession(connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  createDestination: jms.Session => javax.jms.Destination): JmsConsumerSession = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session =[0m
[0m[[0m[0mdebug[0m] [0m[0m          connection.createSession(false, settings.acknowledgeMode.getOrElse(AcknowledgeMode.AutoAcknowledge).mode)[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JmsConsumerSession(connection, session, createDestination(session), destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def pushMessage(msg: jms.Message): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        push(out, msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m        backpressure.release()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def onSessionOpened(jmsSession: JmsConsumerSession): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsSession[0m
[0m[[0m[0mdebug[0m] [0m[0m          .createConsumer(settings.selector)[0m
[0m[[0m[0mdebug[0m] [0m[0m          .map { consumer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            consumer.setMessageListener(new jms.MessageListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m              def onMessage(message: jms.Message): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m                backpressure.acquire()[0m
[0m[[0m[0mdebug[0m] [0m[0m                handleMessage.invoke(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            })[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .onComplete(sessionOpenedCB.invoke)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, logic.consumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsBrowseStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.{Destination, JmsBrowseSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{ActorAttributes, Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsBrowseStage(settings: JmsBrowseSettings, queue: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[SourceShape[jms.Message]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[jms.Message]("JmsBrowseStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val shape = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes.name("JmsBrowse") and ActorAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      var connection: jms.Connection = _[0m
[0m[[0m[0mdebug[0m] [0m[0m      var session: jms.Session = _[0m
[0m[[0m[0mdebug[0m] [0m[0m      var browser: jms.QueueBrowser = _[0m
[0m[[0m[0mdebug[0m] [0m[0m      var messages: java.util.Enumeration[jms.Message] = _[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val ackMode = settings.acknowledgeMode.mode[0m
[0m[[0m[0mdebug[0m] [0m[0m        connection = settings.connectionFactory.createConnection()[0m
[0m[[0m[0mdebug[0m] [0m[0m        connection.start()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        session = connection.createSession(false, ackMode)[0m
[0m[[0m[0mdebug[0m] [0m[0m        browser = session.createBrowser(session.createQueue(queue.name), settings.selector.orNull)[0m
[0m[[0m[0mdebug[0m] [0m[0m        messages = browser.getEnumeration.asInstanceOf[java.util.Enumeration[jms.Message]][0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        messages = null[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (browser ne null) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          browser.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m          browser = null[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (session ne null) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          session.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m          session = null[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (connection ne null) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m          connection = null[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (messages.hasMoreElements) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          push(out, messages.nextElement())[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          complete(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsTxSourceStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.{AcknowledgeMode, Destination, JmsConsumerSettings, TxEnvelope}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStageLogic, GraphStageWithMaterializedValue}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Await, TimeoutException}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsTxSourceStage(settings: JmsConsumerSettings, destination: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[TxEnvelope], JmsConsumerMatValue] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[TxEnvelope]("JmsSource.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: SourceShape[TxEnvelope] = SourceShape[TxEnvelope](out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes = Attributes.name("JmsTxConsumer")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue([0m
[0m[[0m[0mdebug[0m] [0m[0m      inheritedAttributes: Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): (GraphStageLogic, JmsConsumerMatValue) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new SourceStageLogic[TxEnvelope](shape, out, settings, destination, inheritedAttributes) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def createSession(connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  createDestination: jms.Session => javax.jms.Destination) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session =[0m
[0m[[0m[0mdebug[0m] [0m[0m          connection.createSession(true, settings.acknowledgeMode.getOrElse(AcknowledgeMode.SessionTransacted).mode)[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JmsConsumerSession(connection, session, createDestination(session), destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def pushMessage(msg: TxEnvelope): Unit = push(out, msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def onSessionOpened(jmsSession: JmsConsumerSession): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsSession match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case session: JmsSession =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            session[0m
[0m[[0m[0mdebug[0m] [0m[0m              .createConsumer(settings.selector)[0m
[0m[[0m[0mdebug[0m] [0m[0m              .map { consumer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer.setMessageListener(new jms.MessageListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                  def onMessage(message: jms.Message): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m                    try {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      val envelope = TxEnvelope(message, session)[0m
[0m[[0m[0mdebug[0m] [0m[0m                      handleMessage.invoke(envelope)[0m
[0m[[0m[0mdebug[0m] [0m[0m                      val action = Await.result(envelope.commitFuture, settings.ackTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m                      action()[0m
[0m[[0m[0mdebug[0m] [0m[0m                    } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case _: TimeoutException => session.session.rollback()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case e: IllegalArgumentException => handleError.invoke(e) // Invalid envelope. Fail the stage.[0m
[0m[[0m[0mdebug[0m] [0m[0m                      case e: jms.JMSException => handleError.invoke(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                    }[0m
[0m[[0m[0mdebug[0m] [0m[0m                })[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              .onComplete(sessionOpenedCB.invoke)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            throw new IllegalArgumentException([0m
[0m[[0m[0mdebug[0m] [0m[0m              "Session must be of type JMSAckSession, it is a " +[0m
[0m[[0m[0mdebug[0m] [0m[0m              jmsSession.getClass.getName[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, logic.consumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsAckSourceStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStageLogic, GraphStageWithMaterializedValue}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.OptionVal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsAckSourceStage(settings: JmsConsumerSettings, destination: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[AckEnvelope], JmsConsumerMatValue] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[AckEnvelope]("JmsSource.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes = Attributes.name("JmsAckConsumer")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: SourceShape[AckEnvelope] = SourceShape[AckEnvelope](out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue([0m
[0m[[0m[0mdebug[0m] [0m[0m      inheritedAttributes: Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): (GraphStageLogic, JmsConsumerMatValue) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new SourceStageLogic[AckEnvelope](shape, out, settings, destination, inheritedAttributes) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val maxPendingAck = settings.bufferSize[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def createSession(connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  createDestination: jms.Session => javax.jms.Destination): JmsAckSession = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session =[0m
[0m[[0m[0mdebug[0m] [0m[0m          connection.createSession(false, settings.acknowledgeMode.getOrElse(AcknowledgeMode.ClientAcknowledge).mode)[0m
[0m[[0m[0mdebug[0m] [0m[0m        new JmsAckSession(connection, session, createDestination(session), destination, settings.bufferSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected def pushMessage(msg: AckEnvelope): Unit = push(out, msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def onSessionOpened(jmsSession: JmsConsumerSession): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsSession match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case session: JmsAckSession =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            session[0m
[0m[[0m[0mdebug[0m] [0m[0m              .createConsumer(settings.selector)[0m
[0m[[0m[0mdebug[0m] [0m[0m              .map { consumer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                consumer.setMessageListener(new jms.MessageListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                  var listenerStopped = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                  def onMessage(message: jms.Message): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                    @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m                    def ackQueued(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m                      OptionVal(session.ackQueue.poll()) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case OptionVal.Some(action) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                          try {[0m
[0m[[0m[0mdebug[0m] [0m[0m                            action()[0m
[0m[[0m[0mdebug[0m] [0m[0m                            session.pendingAck -= 1[0m
[0m[[0m[0mdebug[0m] [0m[0m                          } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m                            case _: StopMessageListenerException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                              listenerStopped = true[0m
[0m[[0m[0mdebug[0m] [0m[0m                          }[0m
[0m[[0m[0mdebug[0m] [0m[0m                          if (!listenerStopped) ackQueued()[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case OptionVal.None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                    if (!listenerStopped)[0m
[0m[[0m[0mdebug[0m] [0m[0m                      try {[0m
[0m[[0m[0mdebug[0m] [0m[0m                        handleMessage.invoke(AckEnvelope(message, session))[0m
[0m[[0m[0mdebug[0m] [0m[0m                        session.pendingAck += 1[0m
[0m[[0m[0mdebug[0m] [0m[0m                        if (session.pendingAck > maxPendingAck) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                          val action = session.ackQueue.take()[0m
[0m[[0m[0mdebug[0m] [0m[0m                          action()[0m
[0m[[0m[0mdebug[0m] [0m[0m                          session.pendingAck -= 1[0m
[0m[[0m[0mdebug[0m] [0m[0m                        }[0m
[0m[[0m[0mdebug[0m] [0m[0m                        ackQueued()[0m
[0m[[0m[0mdebug[0m] [0m[0m                      } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case _: StopMessageListenerException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                          listenerStopped = true[0m
[0m[[0m[0mdebug[0m] [0m[0m                        case e: jms.JMSException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                          handleError.invoke(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                      }[0m
[0m[[0m[0mdebug[0m] [0m[0m                  }[0m
[0m[[0m[0mdebug[0m] [0m[0m                })[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              .onComplete(sessionOpenedCB.invoke)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            throw new IllegalArgumentException([0m
[0m[[0m[0mdebug[0m] [0m[0m              "Session must be of type JMSAckSession, it is a " +[0m
[0m[[0m[0mdebug[0m] [0m[0m              jmsSession.getClass.getName[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, logic.consumerControl)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsConnector.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicReference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.pattern.after[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl.InternalConnectionState._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Source, SourceQueueWithComplete}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{AsyncCallback, StageLogging, TimerGraphStageLogic}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{ActorAttributes, ActorMaterializerHelper, Attributes, OverflowStrategy}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait JmsConnector[S <: JmsSession] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  this: TimerGraphStageLogic with StageLogging =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import JmsConnector._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit protected var ec: ExecutionContext = _[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected var jmsSessions = Seq.empty[S][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def destination: Destination[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def jmsSettings: JmsSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def onSessionOpened(jmsSession: S): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val fail: AsyncCallback[Throwable] = getAsyncCallback[Throwable](publishAndFailStage)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val connectionFailedCB = getAsyncCallback[Throwable](connectionFailed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var connectionStateQueue: SourceQueueWithComplete[InternalConnectionState] = _[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val connectionStateSourcePromise = Promise[Source[InternalConnectionState, NotUsed]]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val connectionStateSource: Future[Source[InternalConnectionState, NotUsed]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionStateSourcePromise.future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var connectionState: InternalConnectionState = JmsConnectorDisconnected[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    // keep two elements since the time between initializing and connected can be very short.[0m
[0m[[0m[0mdebug[0m] [0m[0m    // always drops the old state, and keeps the most current (two) state(s) in the queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m    val pair = Source.queue[InternalConnectionState](2, OverflowStrategy.dropHead).preMaterialize()(this.materializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionStateQueue = pair._1[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionStateSourcePromise.complete(Success(pair._2))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def finishStop(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val update: InternalConnectionState => InternalConnectionState = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorStopping(completion) => JmsConnectorStopped(completion)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case current => current[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val previous = updateStateWith(update)[0m
[0m[[0m[0mdebug[0m] [0m[0m    connection(previous).foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionStateQueue.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def publishAndFailStage(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val previous = updateState(JmsConnectorStopping(Failure(ex)))[0m
[0m[[0m[0mdebug[0m] [0m[0m    connection(previous).foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m    failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def updateState(next: InternalConnectionState): InternalConnectionState = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val update: InternalConnectionState => InternalConnectionState = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case current: JmsConnectorStopping => current[0m
[0m[[0m[0mdebug[0m] [0m[0m      case current: JmsConnectorStopped => current[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ => next[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateStateWith(update)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def updateStateWith(f: InternalConnectionState => InternalConnectionState): InternalConnectionState = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val last = connectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionState = f(last)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // use type-based comparison to publish JmsConnectorInitializing only once.[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (last.getClass != connectionState.getClass) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionStateQueue.offer(connectionState)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    last[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def connectionFailed(ex: Throwable): Unit = ex match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case ex: jms.JMSSecurityException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.error([0m
[0m[[0m[0mdebug[0m] [0m[0m        ex,[0m
[0m[[0m[0mdebug[0m] [0m[0m        "{} initializing connection failed, security settings are not properly configured for destination[{}]",[0m
[0m[[0m[0mdebug[0m] [0m[0m        attributes.nameLifted.mkString,[0m
[0m[[0m[0mdebug[0m] [0m[0m        destination.name[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      publishAndFailStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _: jms.JMSException | _: JmsConnectTimedOut => handleRetriableException(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionState match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _: JmsConnectorStopping | _: JmsConnectorStopped => logStoppingException(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.error(ex, "{} connection failed for destination[{}]", attributes.nameLifted.mkString, destination.name)[0m
[0m[[0m[0mdebug[0m] [0m[0m          publishAndFailStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def handleRetriableException(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsSessions = Seq.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionState match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorInitializing(_, attempt, backoffMaxed, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        maybeReconnect(ex, attempt, backoffMaxed)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsConnectorConnected(_) | JmsConnectorDisconnected =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        maybeReconnect(ex, 0, backoffMaxed = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _: JmsConnectorStopping | _: JmsConnectorStopped => logStoppingException(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def logStoppingException(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    log.info("{} caught exception {} while stopping stage: {}",[0m
[0m[[0m[0mdebug[0m] [0m[0m             attributes.nameLifted.mkString,[0m
[0m[[0m[0mdebug[0m] [0m[0m             ex.getClass.getSimpleName,[0m
[0m[[0m[0mdebug[0m] [0m[0m             ex.getMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val onSession: AsyncCallback[S] = getAsyncCallback[S] { session =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsSessions :+= session[0m
[0m[[0m[0mdebug[0m] [0m[0m    onSessionOpened(session)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val sessionOpened: Try[Unit] => Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Success(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionState match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case init @ JmsConnectorInitializing(c, _, _, sessions) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (sessions + 1 == jmsSettings.sessionCount) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            c.foreach { c =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              updateState(JmsConnectorConnected(c))[0m
[0m[[0m[0mdebug[0m] [0m[0m              log.info("{} connected", attributes.nameLifted.mkString)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            updateState(init.copy(sessions = sessions + 1))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case s => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Failure(ex: jms.JMSException) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      updateState(JmsConnectorDisconnected) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case JmsConnectorInitializing(c, attempt, backoffMaxed, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          c.foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m          maybeReconnect(ex, attempt, backoffMaxed)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    case Failure(ex) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.error(ex,[0m
[0m[[0m[0mdebug[0m] [0m[0m                "{} initializing connection failed for destination[{}]",[0m
[0m[[0m[0mdebug[0m] [0m[0m                attributes.nameLifted.mkString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                destination.name)[0m
[0m[[0m[0mdebug[0m] [0m[0m      publishAndFailStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val sessionOpenedCB: AsyncCallback[Try[Unit]] = getAsyncCallback[Try[Unit]](sessionOpened)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def maybeReconnect(ex: Throwable, attempt: Int, backoffMaxed: Boolean): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val retrySettings = jmsSettings.connectionRetrySettings[0m
[0m[[0m[0mdebug[0m] [0m[0m    import retrySettings._[0m
[0m[[0m[0mdebug[0m] [0m[0m    val nextAttempt = attempt + 1[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (maxRetries >= 0 && nextAttempt > maxRetries) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val exception =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (maxRetries == 0) ex[0m
[0m[[0m[0mdebug[0m] [0m[0m        else ConnectionRetryException(s"Could not establish connection after $maxRetries retries.", ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.error(exception,[0m
[0m[[0m[0mdebug[0m] [0m[0m                "{} initializing connection failed for destination[{}]",[0m
[0m[[0m[0mdebug[0m] [0m[0m                attributes.nameLifted.mkString,[0m
[0m[[0m[0mdebug[0m] [0m[0m                destination.name)[0m
[0m[[0m[0mdebug[0m] [0m[0m      publishAndFailStage(exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val status = updateState(JmsConnectorDisconnected)[0m
[0m[[0m[0mdebug[0m] [0m[0m      connection(status).foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m      val delay = if (backoffMaxed) maxBackoff else waitTime(nextAttempt)[0m
[0m[[0m[0mdebug[0m] [0m[0m      val backoffNowMaxed = backoffMaxed || delay == maxBackoff[0m
[0m[[0m[0mdebug[0m] [0m[0m      scheduleOnce(AttemptConnect(nextAttempt, backoffNowMaxed), delay)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def onTimer(timerKey: Any): Unit = timerKey match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case AttemptConnect(attempt, backoffMaxed) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.info("{} retries connecting, attempt {}", attributes.nameLifted.mkString, attempt)[0m
[0m[[0m[0mdebug[0m] [0m[0m      initSessionAsync(attempt, backoffMaxed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def executionContext(attributes: Attributes): ExecutionContext = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val dispatcherId = (attributes.get[ActorAttributes.Dispatcher](ActorAttributes.IODispatcher) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ActorAttributes.Dispatcher("") =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        ActorAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m      case d => d[0m
[0m[[0m[0mdebug[0m] [0m[0m    }) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case d @ ActorAttributes.IODispatcher =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        // this one is not a dispatcher id, but is a config path pointing to the dispatcher id[0m
[0m[[0m[0mdebug[0m] [0m[0m        ActorMaterializerHelper.downcast(materializer).system.settings.config.getString(d.dispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case d => d.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ActorMaterializerHelper.downcast(materializer).system.dispatchers.lookup(dispatcherId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def createSession(connection: jms.Connection, createDestination: jms.Session => jms.Destination): S[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def initSessionAsync(attempt: Int = 0, backoffMaxed: Boolean = false): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val allSessions = openSessions(attempt, backoffMaxed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    allSessions.failed.foreach(connectionFailedCB.invoke)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m    // wait for all sessions to successfully initialize before invoking the onSession callback.[0m
[0m[[0m[0mdebug[0m] [0m[0m    // reduces flakiness (start, consume, then crash) at the cost of increased latency of startup.[0m
[0m[[0m[0mdebug[0m] [0m[0m    allSessions.foreach(_.foreach(onSession.invoke))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def startConnection: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def openSessions(attempt: Int, backoffMaxed: Boolean): Future[Seq[S]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val eventualConnection = openConnection(attempt, backoffMaxed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    eventualConnection.flatMap { connection =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val sessionFutures =[0m
[0m[[0m[0mdebug[0m] [0m[0m        for (_ <- 0 until jmsSettings.sessionCount)[0m
[0m[[0m[0mdebug[0m] [0m[0m          yield Future(createSession(connection, destination.create))[0m
[0m[[0m[0mdebug[0m] [0m[0m      Future.sequence(sessionFutures)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def openConnection(attempt: Int, backoffMaxed: Boolean): Future[jms.Connection] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val system: ActorSystem = ActorMaterializerHelper.downcast(materializer).system[0m
[0m[[0m[0mdebug[0m] [0m[0m    val jmsConnection = openConnectionAttempt(startConnection)[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateState(JmsConnectorInitializing(jmsConnection, attempt, backoffMaxed, 0))[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsConnection.map { connection =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      connection.setExceptionListener(new jms.ExceptionListener {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onException(ex: jms.JMSException): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Try(connection.close()) // best effort closing the connection.[0m
[0m[[0m[0mdebug[0m] [0m[0m          connectionFailedCB.invoke(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m      connection[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def openConnectionAttempt(startConnection: Boolean)(implicit system: ActorSystem): Future[jms.Connection] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val factory = jmsSettings.connectionFactory[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRef = new AtomicReference[Option[jms.Connection]](None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // status is also the decision point between the two futures below which one will win.[0m
[0m[[0m[0mdebug[0m] [0m[0m    val status = new AtomicReference[ConnectionAttemptStatus](Connecting)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionFuture = Future {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connection = jmsSettings.credentials match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Some(c: Credentials) => factory.createConnection(c.username, c.password)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ => factory.createConnection()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (status.get == Connecting) { // `TimedOut` can be set at any point. So we have to check whether to continue.[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.set(Some(connection))[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (startConnection) connection.start()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      // ... and close if the connection is not to be used, don't return the connection[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (!status.compareAndSet(Connecting, Connected)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.get.foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.set(None)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw JmsConnectTimedOut("Received timed out signal trying to establish connection")[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else connection[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectTimeout = jmsSettings.connectionRetrySettings.connectTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m    val timeoutFuture = after(connectTimeout, system.scheduler) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      // Even if the timer goes off, the connection may already be good. We use the[0m
[0m[[0m[0mdebug[0m] [0m[0m      // status field and an atomic compareAndSet to see whether we should indeed time out, or just return[0m
[0m[[0m[0mdebug[0m] [0m[0m      // the connection. In this case it does not matter which future returns. Both will have the right answer.[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (status.compareAndSet(Connecting, TimedOut)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.get.foreach(_.close())[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.set(None)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Future.failed([0m
[0m[[0m[0mdebug[0m] [0m[0m          JmsConnectTimedOut([0m
[0m[[0m[0mdebug[0m] [0m[0m            s"Timed out after $connectTimeout trying to establish connection. " +[0m
[0m[[0m[0mdebug[0m] [0m[0m            "Please see ConnectionRetrySettings.connectTimeout"[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionRef.get match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(connection) => Future.successful(connection)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case None => Future.failed(new IllegalStateException("BUG: Connection reference not set when connected"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Future.firstCompletedOf(Iterator(connectionFuture, timeoutFuture))(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsConnector {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed trait ConnectionAttemptStatus[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Connecting extends ConnectionAttemptStatus[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object Connected extends ConnectionAttemptStatus[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object TimedOut extends ConnectionAttemptStatus[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class AttemptConnect(attempt: Int, backoffMaxed: Boolean)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connection: InternalConnectionState => Future[jms.Connection] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case InternalConnectionState.JmsConnectorInitializing(c, _, _, _) => c[0m
[0m[[0m[0mdebug[0m] [0m[0m    case InternalConnectionState.JmsConnectorConnected(c) => Future.successful(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => Future.failed(JmsNotConnected)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsInternalMatValues.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.KillSwitch[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[jms] trait JmsProducerMatValue {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connected: Source[InternalConnectionState, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[jms] trait JmsConsumerMatValue extends KillSwitch with JmsProducerMatValue[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/InternalConnectionState.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] trait InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] object InternalConnectionState {[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object JmsConnectorDisconnected extends InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class JmsConnectorInitializing(connection: Future[jms.Connection],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      attempt: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      backoffMaxed: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      sessions: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class JmsConnectorConnected(connection: jms.Connection) extends InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class JmsConnectorStopping(completion: Try[Done]) extends InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class JmsConnectorStopped(completion: Try[Done]) extends InternalConnectionState[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/JmsMessageProducer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate class JmsMessageProducer(jmsProducer: jms.MessageProducer, jmsSession: JmsProducerSession, val epoch: Int) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val defaultDestination = jmsSession.jmsDestination[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val destinationCache = new SoftReferenceCache[Destination, jms.Destination]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def send(elem: JmsEnvelope[_]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val message: jms.Message = createMessage(elem)[0m
[0m[[0m[0mdebug[0m] [0m[0m    populateMessageProperties(message, elem)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val (sendHeaders, headersBeforeSend: Set[JmsHeader]) = elem.headers.partition(_.usedDuringSend)[0m
[0m[[0m[0mdebug[0m] [0m[0m    populateMessageHeader(message, headersBeforeSend)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val deliveryMode = sendHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collectFirst { case x: JmsDeliveryMode => x.deliveryMode }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(jmsProducer.getDeliveryMode)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val priority = sendHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collectFirst { case x: JmsPriority => x.priority }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(jmsProducer.getPriority)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val timeToLive = sendHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collectFirst { case x: JmsTimeToLive => x.timeInMillis }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(jmsProducer.getTimeToLive)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination = elem.destination match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(messageDestination) => lookup(messageDestination)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => defaultDestination[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsProducer.send(destination, message, deliveryMode, priority, timeToLive)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def lookup(dest: Destination) = destinationCache.lookup(dest, dest.create(jmsSession.session))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def createMessage(element: JmsEnvelope[_]): jms.Message =[0m
[0m[[0m[0mdebug[0m] [0m[0m    element match {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case textMessage: JmsTextMessagePassThrough[_] => jmsSession.session.createTextMessage(textMessage.body)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case byteMessage: JmsByteMessagePassThrough[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val newMessage = jmsSession.session.createBytesMessage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        newMessage.writeBytes(byteMessage.bytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m        newMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case byteStringMessage: JmsByteStringMessagePassThrough[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val newMessage = jmsSession.session.createBytesMessage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        newMessage.writeBytes(byteStringMessage.bytes.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m        newMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case mapMessage: JmsMapMessagePassThrough[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val newMessage = jmsSession.session.createMapMessage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        populateMapMessage(newMessage, mapMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m        newMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case objectMessage: JmsObjectMessagePassThrough[_] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        jmsSession.session.createObjectMessage(objectMessage.serializable)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case pt: JmsPassThrough[_] => throw new IllegalArgumentException("can't create message for JmsPassThrough")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def populateMessageProperties(message: javax.jms.Message, jmsMessage: JmsEnvelope[_]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsMessage.properties.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (key, v) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: String => message.setStringProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Int => message.setIntProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Boolean => message.setBooleanProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Byte => message.setByteProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Short => message.setShortProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Long => message.setLongProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Double => message.setDoubleProperty(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case null => throw NullMessageProperty(key, jmsMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => throw UnsupportedMessagePropertyType(key, v, jmsMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def populateMapMessage(message: javax.jms.MapMessage, jmsMessage: JmsMapMessagePassThrough[_]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    jmsMessage.body.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (key, v) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        v match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: String => message.setString(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Int => message.setInt(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Boolean => message.setBoolean(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Byte => message.setByte(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Short => message.setShort(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Long => message.setLong(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Double => message.setDouble(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case v: Array[Byte] => message.setBytes(key, v)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case null => throw NullMapMessageEntry(key, jmsMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ => throw UnsupportedMapMessageEntryType(key, v, jmsMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def populateMessageHeader(message: javax.jms.Message, headers: Set[JmsHeader]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsType(jmsType) => message.setJMSType(jmsType)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsReplyTo(destination) => message.setJMSReplyTo(destination.create(jmsSession.session))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsCorrelationId(jmsCorrelationId) => message.setJMSCorrelationID(jmsCorrelationId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case JmsDeliveryMode(_) | JmsPriority(_) | JmsTimeToLive(_) => // see #send(JmsMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object JmsMessageProducer {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(jmsSession: JmsProducerSession, settings: JmsProducerSettings, epoch: Int): JmsMessageProducer = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val producer = jmsSession.session.createProducer(null)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (settings.timeToLive.nonEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      producer.setTimeToLive(settings.timeToLive.get.toMillis)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsMessageProducer(producer, jmsSession, epoch)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/Sessions.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.ArrayBlockingQueue[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.{Destination, DurableTopic, StopMessageListenerException}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] sealed trait JmsSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connection: jms.Connection[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def session: jms.Session[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def closeSessionAsync()(implicit ec: ExecutionContext): Future[Unit] = Future { closeSession() }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def closeSession(): Unit = session.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def abortSessionAsync()(implicit ec: ExecutionContext): Future[Unit] = Future { abortSession() }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def abortSession(): Unit = closeSession()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsProducerSession(val connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val session: jms.Session,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val jmsDestination: jms.Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] class JmsConsumerSession(val connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      val session: jms.Session,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      val jmsDestination: jms.Destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      val settingsDestination: Destination)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] def createConsumer([0m
[0m[[0m[0mdebug[0m] [0m[0m      selector: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit ec: ExecutionContext): Future[jms.MessageConsumer] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Future {[0m
[0m[[0m[0mdebug[0m] [0m[0m      (selector, settingsDestination) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (None, t: DurableTopic) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          session.createDurableSubscriber(jmsDestination.asInstanceOf[jms.Topic], t.subscriberName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (Some(expr), t: DurableTopic) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          session.createDurableSubscriber(jmsDestination.asInstanceOf[jms.Topic], t.subscriberName, expr, false)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (Some(expr), _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          session.createConsumer(jmsDestination, expr)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (None, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          session.createConsumer(jmsDestination)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[jms] final class JmsAckSession(override val connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       override val session: jms.Session,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       override val jmsDestination: jms.Destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       override val settingsDestination: Destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       val maxPendingAcks: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends JmsConsumerSession(connection, session, jmsDestination, settingsDestination) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] var pendingAck = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] val ackQueue = new ArrayBlockingQueue[() => Unit](maxPendingAcks + 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ack(message: jms.Message): Unit = ackQueue.put(message.acknowledge _)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def closeSession(): Unit = stopMessageListenerAndCloseSession()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def abortSession(): Unit = stopMessageListenerAndCloseSession()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def stopMessageListenerAndCloseSession(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    ackQueue.put(() => throw StopMessageListenerException())[0m
[0m[[0m[0mdebug[0m] [0m[0m    session.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/impl/SourceStageLogic.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicBoolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.impl.InternalConnectionState.JmsConnectorStopping[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.jms.{Destination, JmsConsumerSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{OutHandler, StageLogging, TimerGraphStageLogic}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.mutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate trait JmsConsumerConnector extends JmsConnector[JmsConsumerSession] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  this: TimerGraphStageLogic with StageLogging =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val startConnection = true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def createSession(connection: jms.Connection,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              createDestination: jms.Session => jms.Destination): JmsConsumerSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate abstract class SourceStageLogic[T](shape: SourceShape[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           out: Outlet[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           settings: JmsConsumerSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           val destination: Destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                           inheritedAttributes: Attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends TimerGraphStageLogic(shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m    with JmsConsumerConnector[0m
[0m[[0m[0mdebug[0m] [0m[0m    with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def jmsSettings: JmsConsumerSettings = settings[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val queue = mutable.Queue[T]()[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val stopping = new AtomicBoolean(false)[0m
[0m[[0m[0mdebug[0m] [0m[0m  private var stopped = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val markStopped = getAsyncCallback[Done.type] { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    stopped = true[0m
[0m[[0m[0mdebug[0m] [0m[0m    finishStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (queue.isEmpty) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val markAborted = getAsyncCallback[Throwable] { ex =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    stopped = true[0m
[0m[[0m[0mdebug[0m] [0m[0m    finishStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m    failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] val handleError = getAsyncCallback[Throwable] { e =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateState(JmsConnectorStopping(Failure(e)))[0m
[0m[[0m[0mdebug[0m] [0m[0m    fail(out, e)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.preStart()[0m
[0m[[0m[0mdebug[0m] [0m[0m    ec = executionContext(inheritedAttributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m    initSessionAsync()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[jms] val handleMessage = getAsyncCallback[T] { msg =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (isAvailable(out)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (queue.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        pushMessage(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        pushMessage(queue.dequeue())[0m
[0m[[0m[0mdebug[0m] [0m[0m        queue.enqueue(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      queue.enqueue(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def pushMessage(msg: T): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m    out,[0m
[0m[[0m[0mdebug[0m] [0m[0m    new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (queue.nonEmpty) pushMessage(queue.dequeue())[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (stopped && queue.isEmpty) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onDownstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        // no need to keep messages in the queue, downstream will never pull them.[0m
[0m[[0m[0mdebug[0m] [0m[0m        queue.clear()[0m
[0m[[0m[0mdebug[0m] [0m[0m        // keep processing async callbacks for stopSessions.[0m
[0m[[0m[0mdebug[0m] [0m[0m        setKeepGoing(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m        stopSessions()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def stopSessions(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (stopping.compareAndSet(false, true)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val status = updateState(JmsConnectorStopping(Success(Done)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionFuture = JmsConnector.connection(status)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val closeSessionFutures = jmsSessions.map { s =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val f = s.closeSessionAsync()[0m
[0m[[0m[0mdebug[0m] [0m[0m        f.failed.foreach(e => log.error(e, "Error closing jms session"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        f[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      Future[0m
[0m[[0m[0mdebug[0m] [0m[0m        .sequence(closeSessionFutures)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          connectionFuture[0m
[0m[[0m[0mdebug[0m] [0m[0m            .map { connection =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              try {[0m
[0m[[0m[0mdebug[0m] [0m[0m                connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m              } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case NonFatal(e) => log.error(e, "Error closing JMS connection {}", connection)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            .onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              // By this time, after stopping connection, closing sessions, all async message submissions to this[0m
[0m[[0m[0mdebug[0m] [0m[0m              // stage should have been invoked. We invoke markStopped as the last item so it gets delivered after[0m
[0m[[0m[0mdebug[0m] [0m[0m              // all JMS messages are delivered. This will allow the stage to complete after all pending messages[0m
[0m[[0m[0mdebug[0m] [0m[0m              // are delivered, thus preventing message loss due to premature stage completion.[0m
[0m[[0m[0mdebug[0m] [0m[0m              markStopped.invoke(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def abortSessions(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (stopping.compareAndSet(false, true)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val status = updateState(JmsConnectorStopping(Failure(ex)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionFuture = JmsConnector.connection(status)[0m
[0m[[0m[0mdebug[0m] [0m[0m      val abortSessionFutures = jmsSessions.map { s =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val f = s.abortSessionAsync()[0m
[0m[[0m[0mdebug[0m] [0m[0m        f.failed.foreach(e => log.error(e, "Error closing jms session"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        f[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      Future[0m
[0m[[0m[0mdebug[0m] [0m[0m        .sequence(abortSessionFutures)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          connectionFuture[0m
[0m[[0m[0mdebug[0m] [0m[0m            .map { connection =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              try {[0m
[0m[[0m[0mdebug[0m] [0m[0m                connection.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m                log.info("JMS connection {} closed", connection)[0m
[0m[[0m[0mdebug[0m] [0m[0m              } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case NonFatal(e) => log.error(e, "Error closing JMS connection {}", connection)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            .onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              markAborted.invoke(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def consumerControl = new JmsConsumerMatValue {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def shutdown(): Unit = stopSessions()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def abort(ex: Throwable): Unit = abortSessions(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def connected: Source[InternalConnectionState, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      Source.fromFuture(connectionStateSource).flatMapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def postStop(): Unit = finishStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/ConnectionRetrySettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * When a connection to a broker cannot be established and errors out, or is timing out being established or[0m
[0m[[0m[0mdebug[0m] [0m[0m * started, the connection can be retried.[0m
[0m[[0m[0mdebug[0m] [0m[0m * All JMS publishers, consumers, and browsers are configured with connection retry settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ConnectionRetrySettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectTimeout: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val initialRetry: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val backoffFactor: Double,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxBackoff: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxRetries: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Time allowed to establish and start a connection. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectTimeout(value: scala.concurrent.duration.FiniteDuration): ConnectionRetrySettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Time allowed to establish and start a connection. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectTimeout(value: java.time.Duration): ConnectionRetrySettings = copy(connectTimeout = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Wait time before retrying the first time. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInitialRetry(value: scala.concurrent.duration.FiniteDuration): ConnectionRetrySettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(initialRetry = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Wait time before retrying the first time. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInitialRetry(value: java.time.Duration): ConnectionRetrySettings = copy(initialRetry = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Back-off factor for subsequent retries. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBackoffFactor(value: Double): ConnectionRetrySettings = copy(backoffFactor = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Maximum back-off time allowed, after which all retries will happen after this delay. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxBackoff(value: scala.concurrent.duration.FiniteDuration): ConnectionRetrySettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(maxBackoff = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Maximum back-off time allowed, after which all retries will happen after this delay. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxBackoff(value: java.time.Duration): ConnectionRetrySettings = copy(maxBackoff = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Maximum number of retries allowed. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMaxRetries(value: Int): ConnectionRetrySettings = copy(maxRetries = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Do not limit the number of retries. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withInfiniteRetries(): ConnectionRetrySettings = withMaxRetries(ConnectionRetrySettings.infiniteRetries)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The wait time before the next attempt may be made. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def waitTime(retryNumber: Int): FiniteDuration =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (initialRetry * Math.pow(retryNumber, backoffFactor)).asInstanceOf[FiniteDuration].min(maxBackoff)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectTimeout: scala.concurrent.duration.FiniteDuration = connectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      initialRetry: scala.concurrent.duration.FiniteDuration = initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m      backoffFactor: Double = backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxBackoff: scala.concurrent.duration.FiniteDuration = maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxRetries: Int = maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ConnectionRetrySettings = new ConnectionRetrySettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    connectTimeout = connectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m    initialRetry = initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m    backoffFactor = backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m    maxBackoff = maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m    maxRetries = maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ConnectionRetrySettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectTimeout=${connectTimeout.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"initialRetry=${initialRetry.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"backoffFactor=$backoffFactor," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"maxBackoff=${maxBackoff.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"maxRetries=${if (maxRetries == ConnectionRetrySettings.infiniteRetries) "infinite" else maxRetries}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ConnectionRetrySettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.jms.connection-retry"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val infiniteRetries: Int = -1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config): ConnectionRetrySettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectTimeout = c.getDuration("connect-timeout").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    val initialRetry = c.getDuration("initial-retry").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    val backoffFactor = c.getDouble("backoff-factor")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxBackoff = c.getDuration("max-backoff").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maxRetries = if (c.getString("max-retries") == "infinite") infiniteRetries else c.getInt("max-retries")[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ConnectionRetrySettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      initialRetry,[0m
[0m[[0m[0mdebug[0m] [0m[0m      backoffFactor,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxBackoff,[0m
[0m[[0m[0mdebug[0m] [0m[0m      maxRetries[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: Reads from the given config. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config): ConnectionRetrySettings = apply(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the default config provided by the actor system at `alpakka.jms.connection-retry`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(actorSystem: ActorSystem): ConnectionRetrySettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config.getConfig(configPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the default config provided by the actor system at `alpakka.jms.connection-retry`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(actorSystem: ActorSystem): ConnectionRetrySettings = apply(actorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/JmsBrowseSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.{Config, ConfigValueType}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Settings for [[akka.stream.alpakka.jms.scaladsl.JmsConsumer.browse]] and [[akka.stream.alpakka.jms.javadsl.JmsConsumer.browse]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class JmsBrowseSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionFactory: javax.jms.ConnectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings: ConnectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination: Option[Destination],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: Option[Credentials],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val selector: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val acknowledgeMode: AcknowledgeMode[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends akka.stream.alpakka.jms.JmsSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val sessionCount = 1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Factory to use for creating JMS connections. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionFactory(value: javax.jms.ConnectionFactory): JmsBrowseSettings = copy(connectionFactory = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Configure connection retrying. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConnectionRetrySettings(value: ConnectionRetrySettings): JmsBrowseSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(connectionRetrySettings = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a queue name to browse from. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withQueue(name: String): JmsBrowseSettings = copy(destination = Some(Queue(name)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set a JMS to subscribe to. Allows for custom handling with [[akka.stream.alpakka.jms.CustomDestination CustomDestination]]. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withDestination(value: Destination): JmsBrowseSettings = copy(destination = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set JMS broker credentials. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: Credentials): JmsBrowseSettings = copy(credentials = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * JMS selector expression.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.oracle.com/cd/E19798-01/821-1841/bncer/index.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSelector(value: String): JmsBrowseSettings = copy(selector = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Set an explicit acknowledge mode. (Consumers have specific defaults.) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAcknowledgeMode(value: AcknowledgeMode): JmsBrowseSettings = copy(acknowledgeMode = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory: javax.jms.ConnectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings: ConnectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination: Option[Destination] = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: Option[Credentials] = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      selector: Option[String] = selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m      acknowledgeMode: AcknowledgeMode = acknowledgeMode[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): JmsBrowseSettings = new JmsBrowseSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionFactory = connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionRetrySettings = connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    destination = destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    selector = selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m    acknowledgeMode = acknowledgeMode[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "JmsBrowseSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionFactory=$connectionFactory," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"connectionRetrySettings=$connectionRetrySettings," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"destination=$destination," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"credentials=$credentials," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"selector=$selector," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"acknowledgeMode=${AcknowledgeMode.asString(acknowledgeMode)}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject JmsBrowseSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.jms.browse"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsBrowseSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getOption[A](path: String, read: Config => A): Option[A] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(path) && (c.getValue(path).valueType() != ConfigValueType.STRING || c.getString(path) != "off"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        Some(read(c))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else None[0m
[0m[[0m[0mdebug[0m] [0m[0m    def getStringOption(path: String): Option[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(path) && c.getString(path).nonEmpty) Some(c.getString(path)) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionRetrySettings = ConnectionRetrySettings(c.getConfig("connection-retry"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val destination = None[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials = getOption("credentials", c => Credentials(c.getConfig("credentials")))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val selector = getStringOption("selector")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val acknowledgeMode = AcknowledgeMode.from(c.getString("acknowledge-mode"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    new JmsBrowseSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionFactory,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionRetrySettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      destination,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      selector,[0m
[0m[[0m[0mdebug[0m] [0m[0m      acknowledgeMode[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param c Config instance read configuration from[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config, connectionFactory: javax.jms.ConnectionFactory): JmsBrowseSettings = apply(c, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the default config provided by the actor system at `alpakka.jms.browse`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsBrowseSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config.getConfig(configPath), connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the default config provided by the actor system at `alpakka.jms.browse`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param actorSystem The actor system[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionFactory Factory to use for creating JMS connections.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(actorSystem: ActorSystem, connectionFactory: javax.jms.ConnectionFactory): JmsBrowseSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem, connectionFactory)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/javadsl/JmsConnectorState.java[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.javadsl;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpublic enum JmsConnectorState {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Disconnected, Connecting, Connected, Completing, Completed, Failing, Failed[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/javadsl/JmsConsumerControl.java[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.javadsl;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed;[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.KillSwitch;[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpublic interface JmsConsumerControl extends KillSwitch {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /**[0m
[0m[[0m[0mdebug[0m] [0m[0m     * source that provides connector status change information.[0m
[0m[[0m[0mdebug[0m] [0m[0m     * Only the most recent connector state is buffered if the source is not consumed.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source<JmsConnectorState, NotUsed> connectorState();[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/jms/src/main/scala/akka/stream/alpakka/jms/javadsl/JmsProducerStatus.java[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.jms.javadsl;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed;[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpublic interface JmsProducerStatus {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /**[0m
[0m[[0m[0mdebug[0m] [0m[0m     * source that provides connector status change information.[0m
[0m[[0m[0mdebug[0m] [0m[0m     * Only the most recent connector state is buffered if the source is not consumed.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source<JmsConnectorState, NotUsed> connectorState();[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
