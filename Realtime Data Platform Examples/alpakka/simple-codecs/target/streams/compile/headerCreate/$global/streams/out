[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/simple-codecs/src/main/scala/akka/stream/alpakka/recordio/javadsl/RecordIOFraming.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.recordio.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.recordio.impl.RecordIOFramingStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides a flow that can separate records from an incoming RecordIO-formatted [[akka.util.ByteString]] stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject RecordIOFraming {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Returns a flow that parses an incoming RecordIO stream and emits the identified records.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The incoming stream is expected to be a concatenation of records of the format:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *   [record length]\n[record data][0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The parser ignores whitespace before or after each record. It is agnostic to the record data contents.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The flow will emit each record's data as a byte string.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param maxRecordLength The maximum record length allowed. If a record is indicated to be longer, this Flow will fail the stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def scanner(maxRecordLength: Int): Flow[ByteString, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new RecordIOFramingStage(maxRecordLength)).named("recordIOFraming")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def scanner(): Flow[ByteString, ByteString, NotUsed] = scanner(10 * 1024)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/simple-codecs/src/main/scala/akka/stream/alpakka/recordio/scaladsl/RecordIOFraming.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.recordio.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.recordio.impl.RecordIOFramingStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Provides a flow that can separate records from an incoming RecordIO-formatted [[akka.util.ByteString]] stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject RecordIOFraming {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Returns a flow that parses an incoming RecordIO stream and emits the identified records.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The incoming stream is expected to be a concatenation of records of the format:[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *   [record length]\n[record data][0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The parser ignores whitespace before or after each record. It is agnostic to the record data contents.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The flow will emit each record's data as a byte string.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param maxRecordLength The maximum record length allowed. If a record is indicated to be longer, this Flow will fail the stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def scanner(maxRecordLength: Int = Int.MaxValue): Flow[ByteString, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[ByteString].via(new RecordIOFramingStage(maxRecordLength)).named("recordIOFraming")[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/simple-codecs/src/main/scala/akka/stream/alpakka/recordio/impl/RecordIOFramingStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.recordio.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes.name[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Framing.FramingException[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[recordio] class RecordIOFramingStage(maxRecordLength: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ByteString, ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import RecordIOFramingStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in = Inlet[ByteString]("RecordIOFramingStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out = Outlet[ByteString]("RecordIOFramingStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ByteString, ByteString] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes = name("recordIOFraming")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String = "RecordIOFraming"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // The maximum length of the record prefix indicating its size.[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val maxRecordPrefixLength = maxRecordLength.toString.length[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var buffer = ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def trimWhitespace(): Unit = buffer = buffer.dropWhile(isWhitespace)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var currentRecordLength: Option[Int] = None // the byte length of the next record, if known[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        buffer ++= grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        doParse()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = doParse()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (buffer.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else if (isAvailable(out)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          doParse()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } // else swallow the termination and wait for pull[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def tryPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (isClosed(in)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          failStage(new FramingException("Stream finished but there was a truncated final record in the buffer."))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def doParse(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        currentRecordLength match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(length) if buffer.size >= length =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val (record, buf) = buffer.splitAt(length)[0m
[0m[[0m[0mdebug[0m] [0m[0m            buffer = buf.compact[0m
[0m[[0m[0mdebug[0m] [0m[0m            trimWhitespace()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            currentRecordLength = None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            push(out, record.compact)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Some(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m          case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            trimWhitespace()[0m
[0m[[0m[0mdebug[0m] [0m[0m            buffer.indexOf(LineFeed) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case -1 if buffer.size > maxRecordPrefixLength =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                failStage(new FramingException(s"Record size prefix is longer than $maxRecordPrefixLength bytes."))[0m
[0m[[0m[0mdebug[0m] [0m[0m              case -1 if isClosed(in) && buffer.isEmpty =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case -1 =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                tryPull()[0m
[0m[[0m[0mdebug[0m] [0m[0m              case lfPos =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val (recordSizePrefix, buf) = buffer.splitAt(lfPos)[0m
[0m[[0m[0mdebug[0m] [0m[0m                buffer = buf.drop(1).compact[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m                Try(recordSizePrefix.utf8String.toInt) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Success(length) if length > maxRecordLength =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    failStage([0m
[0m[[0m[0mdebug[0m] [0m[0m                      new FramingException([0m
[0m[[0m[0mdebug[0m] [0m[0m                        s"Record of size $length bytes exceeds maximum of $maxRecordLength bytes."[0m
[0m[[0m[0mdebug[0m] [0m[0m                      )[0m
[0m[[0m[0mdebug[0m] [0m[0m                    )[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Success(length) if length < 0 =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    failStage(new FramingException(s"Record size prefix $length is negative."))[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Success(length) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    currentRecordLength = Some(length)[0m
[0m[[0m[0mdebug[0m] [0m[0m                    doParse()[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case Failure(ex) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object RecordIOFramingStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val LineFeed = '\n'.toByte[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val CarriageReturn = '\r'.toByte[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val Tab = '\t'.toByte[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val Space = ' '.toByte[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val Whitespace: Set[Byte] = Set(LineFeed, CarriageReturn, Tab, Space)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def isWhitespace(byte: Byte): Boolean = Whitespace.contains(byte)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
