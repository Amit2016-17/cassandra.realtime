[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/javadsl/CouchbaseFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API: Factory methods for Couchbase flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to query Couchbase for by `id` and emit [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromId(sessionSettings: CouchbaseSessionSettings, bucketName: String): Flow[String, JsonDocument, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.fromId(sessionSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to query Couchbase for by `id` and emit documents of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromId[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               target: Class[T]): Flow[String, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.fromId(sessionSettings, bucketName, target).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase [[com.couchbase.client.java.document.JsonDocument JsonDocument]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Flow[JsonDocument, JsonDocument, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.upsert(sessionSettings, writeSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase document of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  bucketName: String): Flow[T, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.upsertDoc(sessionSettings, writeSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase document of the given class and emit a result so that write failures[0m
[0m[[0m[0mdebug[0m] [0m[0m   * can be handled in-stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDocWithResult[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            bucketName: String): Flow[T, CouchbaseWriteResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.upsertDocWithResult(sessionSettings, writeSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to delete documents from Couchbase by `id`. Emits the same `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delete(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Flow[String, String, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.delete(sessionSettings, writeSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to delete documents from Couchbase by `id` and emit operation outcome containing the same `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteWithResult(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                       writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                       bucketName: String): Flow[String, CouchbaseDeleteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseFlow.deleteWithResult(sessionSettings, writeSettings, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/javadsl/CouchbaseSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.{scaladsl, CouchbaseSessionSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{N1qlQuery, Statement}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API: Factory methods for Couchbase sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source query Couchbase by statement, emitted as [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromStatement(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    statement: Statement,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    bucketName: String): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseSource.fromStatement(sessionSettings, statement, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source query Couchbase by statement, emitted as [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromN1qlQuery(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    query: N1qlQuery,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    bucketName: String): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.CouchbaseSource.fromN1qlQuery(sessionSettings, query, bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/javadsl/CouchbaseSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API: Factory methods for Couchbase sinks.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update or insert a Couchbase [[com.couchbase.client.java.document.JsonDocument JsonDocument]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Sink[JsonDocument, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .upsert(sessionSettings, writeSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update or insert a Couchbase document of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  bucketName: String): Sink[T, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .upsertDoc[T](sessionSettings, writeSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to delete documents from Couchbase by `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delete(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Sink[String, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .delete(sessionSettings, writeSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/javadsl/CouchbaseSession.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Optional[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.{CompletionStage, Executor}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.DoNotInherit[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.impl.CouchbaseSessionJavaAdapter[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.scaladsl.{CouchbaseSession => ScalaDslCouchbaseSession}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.{CouchbaseSessionSettings, CouchbaseWriteSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.util.IndexInfo[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{N1qlQuery, Statement}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.{AsyncBucket, AsyncCluster, Bucket}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API: Gives access to Couchbase.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @see [[akka.stream.alpakka.couchbase.CouchbaseSessionRegistry]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a session against the given bucket. The couchbase client used to connect will be created and then closed when[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the session is closed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(settings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             executor: Executor): CompletionStage[CouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaDslCouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m      .apply(settings, bucketName)(executionContext(executor))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(new CouchbaseSessionJavaAdapter(_): CouchbaseSession)([0m
[0m[[0m[0mdebug[0m] [0m[0m        ExecutionContexts.sameThreadExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a given bucket using a pre-existing cluster client, allowing for it to be shared among[0m
[0m[[0m[0mdebug[0m] [0m[0m   * multiple `CouchbaseSession`s. The cluster client's life-cycle is the user's responsibility.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(client: AsyncCluster, bucketName: String, executor: Executor): CompletionStage[CouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaDslCouchbaseSession(client, bucketName)(executionContext(executor))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(new CouchbaseSessionJavaAdapter(_): CouchbaseSession)([0m
[0m[[0m[0mdebug[0m] [0m[0m        ExecutionContexts.sameThreadExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Connects to a Couchbase cluster by creating an `AsyncCluster`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The life-cycle of it is the user's responsibility.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createClient(settings: CouchbaseSessionSettings, executor: Executor): CompletionStage[AsyncCluster] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaDslCouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m      .createClusterClient(settings)(executionContext(executor))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def executionContext(executor: Executor): ExecutionContext =[0m
[0m[[0m[0mdebug[0m] [0m[0m    executor match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ec: ExecutionContext => ec[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ => ExecutionContext.fromExecutor(executor)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a session against the given bucket. You are responsible for managing the lifecycle of the couchbase client[0m
[0m[[0m[0mdebug[0m] [0m[0m   * that the bucket was created with.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(bucket: Bucket): CouchbaseSession = new CouchbaseSessionJavaAdapter(ScalaDslCouchbaseSession.apply(bucket))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API: A Couchbase session allowing querying and interacting with a specific couchbase bucket.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Not for user extension.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m// must be an abstract class, otherwise static forwarders are missing for companion object if building with Scala 2.11[0m
[0m[[0m[0mdebug[0m] [0m[0m@DoNotInherit[0m
[0m[[0m[0mdebug[0m] [0m[0mabstract class CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def underlying: AsyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def asScala: ScalaDslCouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a JSON document using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `insertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A CompletionStage that completes with the written document when the write completes[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument): CompletionStage[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a document using the default write settings. Separate from `insert` to make the most common[0m
[0m[[0m[0mdebug[0m] [0m[0m   * case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A CompletionStage that completes with the written document when the write completes[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T): CompletionStage[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a JSON document using the given write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `insertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): CompletionStage[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a document using the given write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate from `insert` to make the most common case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): CompletionStage[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String): CompletionStage[Optional[JsonDocument]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, documentClass: Class[T]): CompletionStage[Optional[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param timeout fail the returned CompletionStage with a TimeoutException if it takes longer than this[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String, timeout: Duration): CompletionStage[Optional[JsonDocument]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param timeout fail the returned CompletionStage with a TimeoutException if it takes longer than this[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, timeout: Duration, documentClass: Class[T]): CompletionStage[Optional[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the default write settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `upsertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a CompletionStage that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument): CompletionStage[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate from `upsert` to make the most common case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a CompletionStage that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T): CompletionStage[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the given write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `upsertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a CompletionStage that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): CompletionStage[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the given write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate from `upsert` to make the most common case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a CompletionStage that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): CompletionStage[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Remove a document by id using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return CompletionStage that completes when the document has been removed, if there is no such document[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         the CompletionStage is failed with a `DocumentDoesNotExistException`[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String): CompletionStage[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Remove a document by id using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return CompletionStage that completes when the document has been removed, if there is no such document[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         the CompletionStage is failed with a `DocumentDoesNotExistException`[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String, writeSettings: CouchbaseWriteSettings): CompletionStage[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: N1qlQuery): Source[JsonObject, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: Statement): Source[JsonObject, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: Statement): CompletionStage[Optional[JsonObject]][0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: N1qlQuery): CompletionStage[Optional[JsonObject]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create or increment a counter[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param id What counter document id[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param delta Value to increase the counter with if it does exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param initial Value to start from if the counter does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The value of the counter after applying the delta[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long): CompletionStage[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create or increment a counter[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param id What counter document id[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param delta Value to increase the counter with if it does exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param initial Value to start from if the counter does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The value of the counter after applying the delta[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long, writeSettings: CouchbaseWriteSettings): CompletionStage[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Close the session and release all resources it holds. Subsequent calls to other methods will likely fail.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def close(): CompletionStage[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a secondary index for the current bucket.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param indexName the name of the index.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param ignoreIfExist if a secondary index already exists with that name, an exception will be thrown unless this[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                      is set to true.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param fields the JSON fields to index - each can be either `String` or [[com.couchbase.client.java.query.dsl.Expression]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[java.util.concurrent.CompletionStage]] of `true` if the index was/will be effectively created, `false`[0m
[0m[[0m[0mdebug[0m] [0m[0m   *      if the index existed and ignoreIfExist` is true. Completion of the `CompletionStage` does not guarantee the index[0m
[0m[[0m[0mdebug[0m] [0m[0m   *      is online and ready to be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m    **/[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createIndex(indexName: String, ignoreIfExist: Boolean, fields: AnyRef*): CompletionStage[Boolean][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * List the existing secondary indexes for the bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listIndexes(): Source[IndexInfo, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/CouchbaseResponseException.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Describes a Couchbase related failure with an error code.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CouchbaseResponseException(msg: String, val code: Option[Int]) extends RuntimeException(msg) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString = s"CouchbaseResponseException($msg, $code)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** INTERNAL API */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[akka] object CouchbaseResponseException {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(json: JsonObject): CouchbaseResponseException =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseResponseException([0m
[0m[[0m[0mdebug[0m] [0m[0m      msg = if (json.containsKey("msg")) json.getString("msg") else "",[0m
[0m[[0m[0mdebug[0m] [0m[0m      code = if (json.containsKey("code")) Some(json.getInt("code")) else None[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/CouchbaseSessionRegistry.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicReference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.{ActorSystem, ExtendedActorSystem, Extension, ExtensionId, ExtensionIdProvider}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.impl.CouchbaseClusterRegistry[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.javadsl.{CouchbaseSession => JCouchbaseSession}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.scaladsl.CouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * This Couchbase session registry makes it possible to share Couchbase sessions between multiple use sites[0m
[0m[[0m[0mdebug[0m] [0m[0m * in the same `ActorSystem` (important for the Couchbase Akka Persistence plugin where it is shared between journal,[0m
[0m[[0m[0mdebug[0m] [0m[0m * query plugin and snapshot plugin)[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSessionRegistry extends ExtensionId[CouchbaseSessionRegistry] with ExtensionIdProvider {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createExtension(system: ExtendedActorSystem): CouchbaseSessionRegistry =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseSessionRegistry(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: get the session registry[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get(system: ActorSystem): CouchbaseSessionRegistry =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.get(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def lookup(): ExtensionId[CouchbaseSessionRegistry] = this[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private case class SessionKey(settings: CouchbaseSessionSettings, bucketName: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CouchbaseSessionRegistry(system: ExtendedActorSystem) extends Extension {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import CouchbaseSessionRegistry._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val blockingDispatcher = system.dispatchers.lookup("akka.actor.default-blocking-io-dispatcher")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val clusterRegistry = new CouchbaseClusterRegistry(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val sessions = new AtomicReference(Map.empty[SessionKey, Future[CouchbaseSession]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: Get an existing session or start a new one with the given settings and bucket name,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * makes it possible to share one session across plugins.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Note that the session must not be stopped manually, it is shut down when the actor system is shutdown,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if you need a more fine grained life cycle control, create the CouchbaseSession manually instead.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sessionFor(settings: CouchbaseSessionSettings, bucketName: String): Future[CouchbaseSession] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val key = SessionKey(settings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m    sessions.get.get(key) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(futureSession) => futureSession[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ => startSession(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Get an existing session or start a new one with the given settings and bucket name,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * makes it possible to share one session across plugins.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Note that the session must not be stopped manually, it is shut down when the actor system is shutdown,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if you need a more fine grained life cycle control, create the CouchbaseSession manually instead.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getSessionFor(settings: CouchbaseSessionSettings, bucketName: String): CompletionStage[JCouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    sessionFor(settings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def startSession(key: SessionKey): Future[CouchbaseSession] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val promise = Promise[CouchbaseSession]()[0m
[0m[[0m[0mdebug[0m] [0m[0m    val oldSessions = sessions.get()[0m
[0m[[0m[0mdebug[0m] [0m[0m    val newSessions = oldSessions.updated(key, promise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (sessions.compareAndSet(oldSessions, newSessions)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      // we won cas, initialize session[0m
[0m[[0m[0mdebug[0m] [0m[0m      val session = clusterRegistry[0m
[0m[[0m[0mdebug[0m] [0m[0m        .clusterFor(key.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .flatMap(cluster => CouchbaseSession(cluster, key.bucketName)(blockingDispatcher))([0m
[0m[[0m[0mdebug[0m] [0m[0m          ExecutionContexts.sameThreadExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      promise.completeWith(session)[0m
[0m[[0m[0mdebug[0m] [0m[0m      promise.future[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      // we lost cas (could be concurrent call for some other key though), retry[0m
[0m[[0m[0mdebug[0m] [0m[0m      startSession(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/scaladsl/CouchbaseFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.impl.Setup[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API: Factory methods for Couchbase flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to query Couchbase for by `id` and emit [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromId(sessionSettings: CouchbaseSessionSettings, bucketName: String): Flow[String, JsonDocument, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[String][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(1)(id => session.flatMap(_.get(id /* timeout? */ ))(materializer.system.dispatcher))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .collect { case Some(doc) => doc }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to query Couchbase for by `id` and emit documents of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromId[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               target: Class[T]): Flow[String, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[String][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(1)(id => session.flatMap(_.get(id /* timeout? */, target))(materializer.system.dispatcher))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .collect { case Some(doc) => doc }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase [[com.couchbase.client.java.document.JsonDocument JsonDocument]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Flow[JsonDocument, JsonDocument, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(writeSettings.parallelism)([0m
[0m[[0m[0mdebug[0m] [0m[0m            doc => session.flatMap(_.upsert(doc, writeSettings))(materializer.system.dispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase document of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  bucketName: String): Flow[T, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[T][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(writeSettings.parallelism)([0m
[0m[[0m[0mdebug[0m] [0m[0m            doc => session.flatMap(_.upsertDoc(doc, writeSettings))(materializer.system.dispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to update or insert a Couchbase document of the given class and emit a result so that write failures[0m
[0m[[0m[0mdebug[0m] [0m[0m   * can be handled in-stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDocWithResult[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            bucketName: String): Flow[T, CouchbaseWriteResult[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[T][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(writeSettings.parallelism)([0m
[0m[[0m[0mdebug[0m] [0m[0m            doc => {[0m
[0m[[0m[0mdebug[0m] [0m[0m              implicit val executor = materializer.system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m              session[0m
[0m[[0m[0mdebug[0m] [0m[0m                .flatMap(_.upsertDoc(doc, writeSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m                .map(_ => CouchbaseWriteSuccess(doc))[0m
[0m[[0m[0mdebug[0m] [0m[0m                .recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case exception => CouchbaseWriteFailure(doc, exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to delete documents from Couchbase by `id`. Emits the same `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delete(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Flow[String, String, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[String][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(writeSettings.parallelism)([0m
[0m[[0m[0mdebug[0m] [0m[0m            id => {[0m
[0m[[0m[0mdebug[0m] [0m[0m              implicit val executor = materializer.system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m              session[0m
[0m[[0m[0mdebug[0m] [0m[0m                .flatMap(_.remove(id, writeSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m                .map(_ => id)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a flow to delete documents from Couchbase by `id` and emit operation outcome containing the same `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteWithResult(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                       writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                       bucketName: String): Flow[String, CouchbaseDeleteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow[String][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(writeSettings.parallelism)([0m
[0m[[0m[0mdebug[0m] [0m[0m            id => {[0m
[0m[[0m[0mdebug[0m] [0m[0m              implicit val executor = materializer.system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m              session[0m
[0m[[0m[0mdebug[0m] [0m[0m                .flatMap(_.remove(id, writeSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m                .map(_ => CouchbaseDeleteSuccess(id))[0m
[0m[[0m[0mdebug[0m] [0m[0m                .recover {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case exception => CouchbaseDeleteFailure(id, exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/scaladsl/CouchbaseSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.impl.Setup[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.{CouchbaseSessionRegistry, CouchbaseSessionSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{N1qlQuery, Statement}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API: Factory methods for Couchbase sources.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source query Couchbase by statement, emitted as [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromStatement(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    statement: Statement,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    bucketName: String): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Source[0m
[0m[[0m[0mdebug[0m] [0m[0m          .fromFuture(session.map(_.streamedQuery(statement))(materializer.system.dispatcher))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a source query Couchbase by statement, emitted as [[com.couchbase.client.java.document.JsonDocument JsonDocument]]s.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromN1qlQuery(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    query: N1qlQuery,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    bucketName: String): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { materializer => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val session = CouchbaseSessionRegistry(materializer.system).sessionFor(sessionSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m        Source[0m
[0m[[0m[0mdebug[0m] [0m[0m          .fromFuture(session.map(_.streamedQuery(query))(materializer.system.dispatcher))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/scaladsl/CouchbaseSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API: Factory methods for Couchbase sinks.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update or insert a Couchbase [[com.couchbase.client.java.document.JsonDocument JsonDocument]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Sink[JsonDocument, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow.upsert(sessionSettings, writeSettings, bucketName).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to update or insert a Couchbase document of the given class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  bucketName: String): Sink[T, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m      .upsertDoc(sessionSettings, writeSettings, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a sink to delete documents from Couchbase by `id`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delete(sessionSettings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             writeSettings: CouchbaseWriteSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m             bucketName: String): Sink[String, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CouchbaseFlow.delete(sessionSettings, writeSettings, bucketName).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/scaladsl/CouchbaseSession.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.{DoNotInherit, InternalApi}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.impl.{CouchbaseSessionImpl, RxUtilities}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.javadsl.{CouchbaseSession => JavaDslCouchbaseSession}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.{CouchbaseSessionSettings, CouchbaseWriteSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.util.IndexInfo[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API: Gives access to Couchbase.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @see [[akka.stream.alpakka.couchbase.CouchbaseSessionRegistry]][0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a session against the given bucket. The couchbase client used to connect will be created and then closed when[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the session is closed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: CouchbaseSessionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m            bucketName: String)(implicit ec: ExecutionContext): Future[CouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    createClusterClient(settings).flatMap(c => openBucket(c, disconnectClusterOnClose = true, bucketName))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a given bucket using a pre-existing cluster client, allowing for it to be shared among[0m
[0m[[0m[0mdebug[0m] [0m[0m   * multiple `CouchbaseSession`s. The cluster client's life-cycle is the user's responsibility.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(cluster: AsyncCluster, bucketName: String)(implicit ec: ExecutionContext): Future[CouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    openBucket(cluster, disconnectClusterOnClose = false, bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a session against the given bucket. You are responsible for managing the lifecycle of the couchbase client[0m
[0m[[0m[0mdebug[0m] [0m[0m   * that the bucket was created with.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(bucket: Bucket): CouchbaseSession =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseSessionImpl(bucket.async(), None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * INTERNAL API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Connects to a Couchbase cluster by creating an `AsyncCluster`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The life-cycle of it is the user's responsibility.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[couchbase] def createClusterClient([0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: CouchbaseSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit ec: ExecutionContext): Future[AsyncCluster] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    //wrap CouchbaseAsyncCluster.create up in the Future because it's blocking[0m
[0m[[0m[0mdebug[0m] [0m[0m    Future(settings.environment match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(environment) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        CouchbaseAsyncCluster.create(environment, settings.nodes: _*)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        CouchbaseAsyncCluster.create(settings.nodes: _*)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }).map(_.authenticate(settings.username, settings.password))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def openBucket(cluster: AsyncCluster, disconnectClusterOnClose: Boolean, bucketName: String)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[CouchbaseSession] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    RxUtilities[0m
[0m[[0m[0mdebug[0m] [0m[0m      .singleObservableToFuture(cluster.openBucket(bucketName), "openBucket")[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { bucket =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        new CouchbaseSessionImpl(bucket, if (disconnectClusterOnClose) Some(cluster) else None)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Scala API: A Couchbase session allowing querying and interacting with a specific couchbase bucket.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Not for user extension.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@DoNotInherit[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def underlying: AsyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def asJava: JavaDslCouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a JSON document using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `insertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A future that completes with the written document when the write completes[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument): Future[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert any type of document using the default write settings. Separate from `insert` to make the most common[0m
[0m[[0m[0mdebug[0m] [0m[0m   * case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A future that completes with the written document when the write completes[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T): Future[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert a JSON document using the given write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For inserting other types of documents see `insertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): Future[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Insert any type of document using the given write settings. Separate from `insert` to make the most common[0m
[0m[[0m[0mdebug[0m] [0m[0m   * case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A future that completes with the written document when the write completes[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): Future[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String): Future[Option[JsonDocument]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document of the given type if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, documentClass: Class[T]): Future[Option[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param timeout fail the returned future with a TimeoutException if it takes longer than this[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String, timeout: FiniteDuration): Future[Option[JsonDocument]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A document of the given type if found or none if there is no document for the id[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, timeout: FiniteDuration, documentClass: Class[T]): Future[Option[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For upserting other types of documents see `upsertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a future that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument): Future[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate from `upsert` to make the most common case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a future that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T): Future[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the given write settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For upserting other types of documents see `upsertDoc`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a future that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): Future[JsonDocument][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Upsert using the given write settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate from `upsert` to make the most common case smoother with the type inference[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a future that completes when the upsert is done[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): Future[T][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Remove a document by id using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return Future that completes when the document has been removed, if there is no such document[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         the future is failed with a `DocumentDoesNotExistException`[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String): Future[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Remove a document by id using the default write settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return Future that completes when the document has been removed, if there is no such document[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         the future is failed with a `DocumentDoesNotExistException`[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String, writeSettings: CouchbaseWriteSettings): Future[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: N1qlQuery): Source[JsonObject, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: Statement): Source[JsonObject, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: Statement): Future[Option[JsonObject]][0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: N1qlQuery): Future[Option[JsonObject]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create or increment a counter[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param id What counter document id[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param delta Value to increase the counter with if it does exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param initial Value to start from if the counter does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The value of the counter after applying the delta[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long): Future[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create or increment a counter[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param id What counter document id[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param delta Value to increase the counter with if it does exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param initial Value to start from if the counter does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The value of the counter after applying the delta[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long, writeSettings: CouchbaseWriteSettings): Future[Long][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Close the session and release all resources it holds. Subsequent calls to other methods will likely fail.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def close(): Future[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a secondary index for the current bucket.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param indexName the name of the index.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param ignoreIfExist if a secondary index already exists with that name, an exception will be thrown unless this[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                      is set to true.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param fields the JSON fields to index - each can be either `String` or [com.couchbase.client.java.query.dsl.Expression][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[scala.concurrent.Future]] of `true` if the index was/will be effectively created, `false`[0m
[0m[[0m[0mdebug[0m] [0m[0m   *      if the index existed and `ignoreIfExist` is `true`. Completion of the future does not guarantee the index is online[0m
[0m[[0m[0mdebug[0m] [0m[0m   *      and ready to be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createIndex(indexName: String, ignoreIfExist: Boolean, fields: AnyRef*): Future[Boolean][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * List the existing secondary indexes for the bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listIndexes(): Source[IndexInfo, NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/impl/CouchbaseSessionJavaAdapter.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Optional[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.CouchbaseWriteSettings[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.AsyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.util.IndexInfo[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{N1qlQuery, Statement}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{duration, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[couchbase] final class CouchbaseSessionJavaAdapter(delegate: scaladsl.CouchbaseSession)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends javadsl.CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def asScala: scaladsl.CouchbaseSession = delegate[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def underlying: AsyncBucket = delegate.underlying[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def insert(document: JsonDocument): CompletionStage[JsonDocument] = delegate.insertDoc(document).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def insertDoc[T <: Document[_]](document: T): CompletionStage[T] = delegate.insertDoc(document).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def insert([0m
[0m[[0m[0mdebug[0m] [0m[0m      document: JsonDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m      writeSettings: CouchbaseWriteSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): CompletionStage[JsonDocument] = delegate.insert(document, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def insertDoc[T <: Document[_]]([0m
[0m[[0m[0mdebug[0m] [0m[0m      document: T,[0m
[0m[[0m[0mdebug[0m] [0m[0m      writeSettings: CouchbaseWriteSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): CompletionStage[T] = delegate.insertDoc(document, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get(id: String): CompletionStage[Optional[JsonDocument]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.get(id))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get[T <: Document[_]](id: String, clazz: Class[T]): CompletionStage[Optional[T]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.get(id, clazz))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get(id: String, timeout: Duration): CompletionStage[Optional[JsonDocument]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.get(id, FiniteDuration.apply(timeout.toNanos, duration.NANOSECONDS)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, timeout: Duration, documentClass: Class[T]): CompletionStage[Optional[T]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.get(id, FiniteDuration.apply(timeout.toNanos, duration.NANOSECONDS), documentClass))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def upsert(document: JsonDocument): CompletionStage[JsonDocument] = delegate.upsert(document).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def upsertDoc[T <: Document[_]](document: T): CompletionStage[T] = delegate.upsertDoc(document).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def upsert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): CompletionStage[JsonDocument] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.upsert(document, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def upsertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): CompletionStage[T] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.upsertDoc(document, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def remove(id: String): CompletionStage[Done] = delegate.remove(id).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def remove(id: String, writeSettings: CouchbaseWriteSettings): CompletionStage[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.remove(id, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def streamedQuery(query: N1qlQuery): Source[JsonObject, _root_.akka.NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.streamedQuery(query).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def streamedQuery(query: Statement): Source[JsonObject, _root_.akka.NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.streamedQuery(query).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def singleResponseQuery(query: Statement): CompletionStage[Optional[JsonObject]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.singleResponseQuery(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def singleResponseQuery(query: N1qlQuery): CompletionStage[Optional[JsonObject]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    futureOptToJava(delegate.singleResponseQuery(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def counter(id: String, delta: Long, initial: Long): CompletionStage[Long] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.counter(id, delta, initial).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def counter([0m
[0m[[0m[0mdebug[0m] [0m[0m      id: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      delta: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m      initial: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m      writeSettings: CouchbaseWriteSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): CompletionStage[Long] = delegate.counter(id, delta, initial, writeSettings).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def close(): CompletionStage[Done] = delegate.close().toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createIndex(indexName: String, ignoreIfExist: Boolean, fields: AnyRef*): CompletionStage[Boolean] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.createIndex(indexName, ignoreIfExist, fields).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def futureOptToJava[T](future: Future[Option[T]]): CompletionStage[Optional[T]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    future.map(_.asJava)(ExecutionContexts.sameThreadExecutionContext).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listIndexes(): Source[IndexInfo, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    delegate.listIndexes().asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/impl/SetupStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private final class SetupFlowStage[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[FlowShape[T, U], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[T]("SetupFlowStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[U]("SetupFlowStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[U]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subOutlet = new SubSourceOutlet[T]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: U), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    subOutlet.setHandler(delegateToInlet(() => pull(in), () => cancel(in)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(in, delegateToSubOutlet(() => grab(in), subOutlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val flow = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .fromGraph(subOutlet.source)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .viaMat(flow)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private final class SetupSourceStage[T, M](factory: ActorMaterializer => Attributes => Source[T, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[T], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[T]("SetupSourceStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[T]("SetupSourceStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: T), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val source = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object SetupStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubOutlet[T](grab: () => T, subOutlet: GraphStageLogic#SubSourceOutlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.push(grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToOutlet[T](push: T => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          complete: () => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          fail: Throwable => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          subInlet: GraphStageLogic#SubSinkInlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      push(subInlet.grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubInlet[T](subInlet: GraphStageLogic#SubSinkInlet[T]) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToInlet(pull: () => Unit, cancel: () => Unit) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def actorMaterializer(mat: Materializer): ActorMaterializer = mat match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case am: ActorMaterializer => am[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => throw new Error("ActorMaterializer required")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[couchbase] object Setup {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M]): Flow[T, U, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new SetupFlowStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def source[T, M](factory: ActorMaterializer => Attributes => Source[T, M]): Source[T, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new SetupSourceStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/impl/CouchbaseSessionImpl.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.scaladsl.CouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.{javadsl, CouchbaseWriteSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.bucket.AsyncBucketManager[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.{Document, JsonDocument}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.util.IndexInfo[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{N1qlQuery, Statement}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.{AsyncBucket, AsyncCluster}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport rx.RxReactiveStreams[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param cluster if provided, it will be shut down when `close()` is called[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal private[couchbase] class CouchbaseSessionImpl(asyncBucket: AsyncBucket, cluster: Option[AsyncCluster])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends CouchbaseSession {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import RxUtilities._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def asJava: javadsl.CouchbaseSession = new CouchbaseSessionJavaAdapter(this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def underlying: AsyncBucket = asyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument): Future[JsonDocument] = insertDoc(document)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T): Future[T] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.insert(document), document)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): Future[JsonDocument] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    insertDoc(document, writeSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): Future[T] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture([0m
[0m[[0m[0mdebug[0m] [0m[0m      asyncBucket.insert(document, writeSettings.persistTo, writeSettings.timeout.toMillis, TimeUnit.MILLISECONDS),[0m
[0m[[0m[0mdebug[0m] [0m[0m      document[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String): Future[Option[JsonDocument]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    zeroOrOneObservableToFuture(asyncBucket.get(id))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String, documentClass: Class[T]): Future[Option[T]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    zeroOrOneObservableToFuture(asyncBucket.get(id, documentClass))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get(id: String, timeout: FiniteDuration): Future[Option[JsonDocument]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    zeroOrOneObservableToFuture(asyncBucket.get(id, timeout.toMillis, TimeUnit.MILLISECONDS))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def get[T <: Document[_]](id: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            timeout: FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            documentClass: Class[T]): scala.concurrent.Future[Option[T]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    zeroOrOneObservableToFuture(asyncBucket.get(id, documentClass, timeout.toMillis, TimeUnit.MILLISECONDS))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument): Future[JsonDocument] = upsertDoc(document)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T): Future[T] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.upsert(document), document.id)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsert(document: JsonDocument, writeSettings: CouchbaseWriteSettings): Future[JsonDocument] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    upsertDoc(document, writeSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def upsertDoc[T <: Document[_]](document: T, writeSettings: CouchbaseWriteSettings): Future[T] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.upsert(document,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.persistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.replicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.timeout.toMillis,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                TimeUnit.MILLISECONDS),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             document.id)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.remove(id), id)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => Done)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(id: String, writeSettings: CouchbaseWriteSettings): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.remove(id,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.persistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.replicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                writeSettings.timeout.toMillis,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                TimeUnit.MILLISECONDS),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             id)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => Done)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: N1qlQuery): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    // FIXME verify cancellation works[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromPublisher(RxReactiveStreams.toPublisher(asyncBucket.query(query).flatMap(RxUtilities.unfoldJsonObjects)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def streamedQuery(query: Statement): Source[JsonObject, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromPublisher(RxReactiveStreams.toPublisher(asyncBucket.query(query).flatMap(RxUtilities.unfoldJsonObjects)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: Statement): Future[Option[JsonObject]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleResponseQuery(N1qlQuery.simple(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleResponseQuery(query: N1qlQuery): Future[Option[JsonObject]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    zeroOrOneObservableToFuture(asyncBucket.query(query).flatMap(RxUtilities.unfoldJsonObjects))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long): Future[Long] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.counter(id, delta, initial), id)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.content(): Long)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def counter(id: String, delta: Long, initial: Long, writeSettings: CouchbaseWriteSettings): Future[Long] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture(asyncBucket.counter(id,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 delta,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 initial,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 writeSettings.persistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 writeSettings.replicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 writeSettings.timeout.toMillis,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                 TimeUnit.MILLISECONDS),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             id)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.content(): Long)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def close(): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (!asyncBucket.isClosed) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      singleObservableToFuture(asyncBucket.close(), "close")[0m
[0m[[0m[0mdebug[0m] [0m[0m        .flatMap { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          cluster match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(cluster) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              singleObservableToFuture(cluster.disconnect(), "close").map(_ => Done)(ExecutionContexts.global())[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None => Future.successful(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }(ExecutionContexts.global())[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      Future.successful(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String = s"CouchbaseSession(${asyncBucket.name()})"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createIndex(indexName: String, ignoreIfExist: Boolean, fields: AnyRef*): Future[Boolean] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    singleObservableToFuture([0m
[0m[[0m[0mdebug[0m] [0m[0m      asyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0m        .bucketManager()[0m
[0m[[0m[0mdebug[0m] [0m[0m        .flatMap([0m
[0m[[0m[0mdebug[0m] [0m[0m          func1Observable[AsyncBucketManager, Boolean]([0m
[0m[[0m[0mdebug[0m] [0m[0m            _.createN1qlIndex(indexName, ignoreIfExist, false, fields: _*)[0m
[0m[[0m[0mdebug[0m] [0m[0m              .map(func1(Boolean.unbox))[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        ),[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"Create index: $indexName"[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def listIndexes(): Source[IndexInfo, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromPublisher([0m
[0m[[0m[0mdebug[0m] [0m[0m      RxReactiveStreams.toPublisher([0m
[0m[[0m[0mdebug[0m] [0m[0m        asyncBucket[0m
[0m[[0m[0mdebug[0m] [0m[0m          .bucketManager()[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMap([0m
[0m[[0m[0mdebug[0m] [0m[0m            func1Observable((abm: AsyncBucketManager) => abm.listN1qlIndexes())[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/impl/CouchbaseClusterRegistry.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicReference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.event.Logging[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.CouchbaseSessionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.scaladsl.CouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.AsyncCluster[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal private[couchbase] class CouchbaseClusterRegistry(system: ActorSystem) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val log = Logging(system, classOf[CouchbaseClusterRegistry])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val blockingDispatcher = system.dispatchers.lookup("akka.actor.default-blocking-io-dispatcher")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val clusters = new AtomicReference(Map.empty[CouchbaseSessionSettings, Future[AsyncCluster]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clusterFor(settings: CouchbaseSessionSettings): Future[AsyncCluster] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    clusters.get.get(settings) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(futureSession) => futureSession[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ => createClusterClient(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createClusterClient(settings: CouchbaseSessionSettings): Future[AsyncCluster] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val promise = Promise[AsyncCluster]()[0m
[0m[[0m[0mdebug[0m] [0m[0m    val oldClusters = clusters.get()[0m
[0m[[0m[0mdebug[0m] [0m[0m    val newClusters = oldClusters.updated(settings, promise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (clusters.compareAndSet(oldClusters, newClusters)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      // we won cas, initialize session[0m
[0m[[0m[0mdebug[0m] [0m[0m      def nodesAsString = settings.nodes.mkString("\"", "\", \"", "\"")[0m
[0m[[0m[0mdebug[0m] [0m[0m      log.info("Starting Couchbase client for nodes [{}]", nodesAsString)[0m
[0m[[0m[0mdebug[0m] [0m[0m      promise.completeWith([0m
[0m[[0m[0mdebug[0m] [0m[0m        CouchbaseSession[0m
[0m[[0m[0mdebug[0m] [0m[0m          .createClusterClient(settings)(blockingDispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      val future = promise.future[0m
[0m[[0m[0mdebug[0m] [0m[0m      system.registerOnTermination {[0m
[0m[[0m[0mdebug[0m] [0m[0m        future.foreach { cluster =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val nodesAsString = settings.nodes.mkString("\"", "\", \"", "\"")[0m
[0m[[0m[0mdebug[0m] [0m[0m          log.info("Shutting down Couchbase client for nodes [{}]", nodesAsString)[0m
[0m[[0m[0mdebug[0m] [0m[0m          cluster.disconnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }(system.dispatcher)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      future[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      // we lost cas (could be concurrent call for some other settings though), retry[0m
[0m[[0m[0mdebug[0m] [0m[0m      createClusterClient(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/impl/RxUtilities.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.couchbase.CouchbaseResponseException[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.json.JsonObject[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.query.{AsyncN1qlQueryResult, AsyncN1qlQueryRow}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport rx.functions.Func1[0m
[0m[[0m[0mdebug[0m] [0m[0mimport rx.{Observable, Subscriber}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[couchbase] object RxUtilities {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val unfoldDocument = new Func1[AsyncN1qlQueryRow, JsonObject] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def call(row: AsyncN1qlQueryRow): JsonObject =[0m
[0m[[0m[0mdebug[0m] [0m[0m      row.value()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val failStreamOnError = new Func1[JsonObject, Observable[JsonObject]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def call(err: JsonObject): Observable[JsonObject] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      Observable.error(CouchbaseResponseException(err))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val unfoldJsonObjects = new Func1[AsyncN1qlQueryResult, Observable[JsonObject]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def call(t: AsyncN1qlQueryResult): Observable[JsonObject] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val data: Observable[JsonObject] = t.rows().map(unfoldDocument)[0m
[0m[[0m[0mdebug[0m] [0m[0m      val errors = t.errors().flatMap(failStreamOnError)[0m
[0m[[0m[0mdebug[0m] [0m[0m      data.mergeWith(errors)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def singleObservableToFuture[T](o: Observable[T], id: Any): Future[T] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val p = Promise[T][0m
[0m[[0m[0mdebug[0m] [0m[0m    o.single()[0m
[0m[[0m[0mdebug[0m] [0m[0m      .subscribe(new Subscriber[T]() {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onCompleted(): Unit = p.tryFailure(new RuntimeException(s"No document found for $id"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onError(e: Throwable): Unit = p.tryFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onNext(t: T): Unit = p.trySuccess(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m    p.future[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def zeroOrOneObservableToFuture[T](o: Observable[T]): Future[Option[T]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val p = Promise[Option[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m    o.subscribe(new Subscriber[T]() {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onCompleted(): Unit = p.trySuccess(None)[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onError(e: Throwable): Unit = p.tryFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onNext(t: T): Unit = p.trySuccess(Some(t))[0m
[0m[[0m[0mdebug[0m] [0m[0m    })[0m
[0m[[0m[0mdebug[0m] [0m[0m    p.future[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def func1Observable[T, R](fun: T => Observable[R]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Func1[T, Observable[R]]() {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def call(b: T): Observable[R] = fun(b)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def func1[T, R](fun: T => R) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Func1[T, R]() {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def call(b: T): R = fun(b)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/couchbase/src/main/scala/akka/stream/alpakka/couchbase/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.couchbase[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.document.Document[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.env.CouchbaseEnvironment[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.couchbase.client.java.{PersistTo, ReplicateTo}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Configure Couchbase writes.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseWriteSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Simple settings not requiring replication nor persistence.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val inMemory = CouchbaseWriteSettings(1, ReplicateTo.NONE, PersistTo.NONE, 2.seconds)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): CouchbaseWriteSettings = inMemory[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(parallelism: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m            replicateTo: ReplicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m            persistTo: PersistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m            timeout: FiniteDuration): CouchbaseWriteSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseWriteSettings(parallelism, replicateTo, persistTo, timeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): CouchbaseWriteSettings = inMemory[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(parallelism: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m             replicateTo: ReplicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m             persistTo: PersistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m             timeout: java.time.Duration): CouchbaseWriteSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseWriteSettings(parallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               replicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               persistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               FiniteDuration(timeout.toMillis, TimeUnit.MILLISECONDS))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Configure Couchbase writes.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CouchbaseWriteSettings private (val parallelism: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val replicateTo: ReplicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val persistTo: PersistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                            val timeout: FiniteDuration) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withParallelism(parallelism: Int): CouchbaseWriteSettings = copy(parallelism = parallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withReplicateTo(replicateTo: ReplicateTo): CouchbaseWriteSettings = copy(replicateTo = replicateTo)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPersistTo(persistTo: PersistTo): CouchbaseWriteSettings = copy(persistTo = persistTo)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTimeout(timeout: java.time.Duration): CouchbaseWriteSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(timeout = FiniteDuration(timeout.toMillis, TimeUnit.MILLISECONDS))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTimeout(timeout: FiniteDuration): CouchbaseWriteSettings = copy(timeout = timeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def copy(parallelism: Int = parallelism,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         replicateTo: ReplicateTo = replicateTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         persistTo: PersistTo = persistTo,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         timeout: FiniteDuration = timeout) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseWriteSettings(parallelism, replicateTo, persistTo, timeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: CouchbaseWriteSettings =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      this.parallelism == that.parallelism &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      this.replicateTo == that.replicateTo &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      this.persistTo == that.persistTo &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      this.timeout == that.timeout[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int = java.util.Objects.hash(int2Integer(parallelism), replicateTo, persistTo, timeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "CouchbaseWriteSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"parallelism=$parallelism," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"replicateTo=$replicateTo," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"persistTo=$persistTo," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"timeout=${timeout.toCoarsest}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CouchbaseSessionSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val configPath = "alpakka.couchbase.session"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Load the session from the given config object, expects the config object to have the fields `username`,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * `password` and `nodes`. Using it means first looking your config namespace up yourself using `config.getConfig("some.path")`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(config: Config): CouchbaseSessionSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val username = config.getString("username")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val password = config.getString("password")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val nodes = config.getStringList("nodes").asScala.toList[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseSessionSettings(username, password, nodes, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Load the session from the default config path `alpakka.couchbase.session`, expects the config object to have the fields `username`,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * `password` and `nodes`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(system: ActorSystem): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(system.settings.config.getConfig(configPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(username: String, password: String): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseSessionSettings(username, password, Nil, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(username: String, password: String): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Load the session from the given config object, expects the config object to have the fields `username`,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * `password` and `nodes`. Using it means first looking your config namespace up yourself using `config.getConfig("some.path")`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(config: Config): CouchbaseSessionSettings = apply(config)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Load the session from the default config path `alpakka.couchbase.session`, expects the config object to have the fields `username`,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * `password` and `nodes`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(system: ActorSystem): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(system.settings.config.getConfig(configPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CouchbaseSessionSettings private (val username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              val password: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              val nodes: immutable.Seq[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              val environment: Option[CouchbaseEnvironment]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUsername(username: String): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(username = username)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassword(password: String): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(password = password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withNodes(nodes: String): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(nodes = nodes :: Nil)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withNodes(nodes: immutable.Seq[String]): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(nodes = nodes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withNodes(nodes: java.util.List[String]): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(nodes = nodes.asScala.toList)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withEnvironment(environment: CouchbaseEnvironment): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(environment = Some(environment))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(username: String = username,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   password: String = password,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   nodes: immutable.Seq[String] = nodes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   environment: Option[CouchbaseEnvironment] = environment): CouchbaseSessionSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CouchbaseSessionSettings(username, password, nodes, environment)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: CouchbaseSessionSettings =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      username == that.username &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      password == that.password &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      nodes == that.nodes &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      environment == that.environment[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    java.util.Objects.hash(username, password, nodes, environment)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "CouchbaseSessionSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"username=$username," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"password=*****," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"nodes=${nodes.mkString("[", ", ", "]")}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"environment=$environment" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Wrapper to for handling Couchbase write failures in-stream instead of failing the stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait CouchbaseWriteResult[T <: Document[_]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isSuccess: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isFailure: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  def doc: T[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Emitted for a successful Couchbase write operation.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CouchbaseWriteSuccess[T <: Document[_]] private (override val doc: T) extends CouchbaseWriteResult[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isSuccess: Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isFailure: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Emitted for a failed Couchbase write operation.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CouchbaseWriteFailure[T <: Document[_]] private (override val doc: T, failure: Throwable)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends CouchbaseWriteResult[T] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isSuccess: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isFailure: Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Wrapper to for handling Couchbase write failures in-stream instead of failing the stream.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait CouchbaseDeleteResult {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isSuccess: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isFailure: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  def id: String[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Emitted for a successful Couchbase write operation.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CouchbaseDeleteSuccess private (override val id: String) extends CouchbaseDeleteResult {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isSuccess: Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isFailure: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Emitted for a failed Couchbase write operation.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CouchbaseDeleteFailure private (override val id: String, failure: Throwable)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends CouchbaseDeleteResult {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isSuccess: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isFailure: Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
