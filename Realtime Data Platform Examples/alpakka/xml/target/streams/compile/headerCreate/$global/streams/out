[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/javadsl/XmlWriting.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.{Charset, StandardCharsets}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.ParseEvent[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject XmlWriting {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Writer Flow that takes a stream of XML events similar to SAX and write ByteStrings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * encoding UTF-8[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def writer(): akka.stream.javadsl.Flow[ParseEvent, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.StreamingXmlWriter(StandardCharsets.UTF_8)).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Writer Flow that takes a stream of XML events similar to SAX and write ByteStrings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param charset encoding of the stream[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def writer(charset: Charset): akka.stream.javadsl.Flow[ParseEvent, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.StreamingXmlWriter(charset)).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/javadsl/XmlParsing.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.ParseEvent[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.w3c.dom.Element[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject XmlParsing {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Parser Flow that takes a stream of ByteStrings and parses them to XML events similar to SAX.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def parser(): akka.stream.javadsl.Flow[ByteString, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    xml.scaladsl.XmlParsing.parser(ignoreInvalidChars = false).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Parser Flow that takes a stream of ByteStrings and parses them to XML events similar to SAX.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def parser(ignoreInvalidChars: Boolean): akka.stream.javadsl.Flow[ByteString, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    xml.scaladsl.XmlParsing.parser(ignoreInvalidChars).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage coalesces consequitive CData and Characters[0m
[0m[[0m[0mdebug[0m] [0m[0m   * events into a single Characters event or fails if the buffered string is larger than the maximum defined.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def coalesce(maximumTextLength: Int): akka.stream.javadsl.Flow[ParseEvent, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    xml.scaladsl.XmlParsing.coalesce(maximumTextLength).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage filters out any event not corresponding to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a certain path in the XML document. Any event that is under the specified path (including subpaths) is passed[0m
[0m[[0m[0mdebug[0m] [0m[0m   * through.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def subslice(path: java.util.Collection[String]): akka.stream.javadsl.Flow[ParseEvent, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    xml.scaladsl.XmlParsing.subslice(path.asScala.toIndexedSeq).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage pushes elements of a certain path in[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the XML document as org.w3c.dom.Element.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def subtree(path: java.util.Collection[String]): akka.stream.javadsl.Flow[ParseEvent, Element, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    xml.scaladsl.XmlParsing.subtree(path.asScala.toIndexedSeq).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/scaladsl/XmlWriting.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.{Charset, StandardCharsets}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.ParseEvent[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject XmlWriting {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Writer Flow that takes a stream of XML events similar to SAX and write ByteStrings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param charset charset of encoding[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def writer(charset: Charset): Flow[ParseEvent, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.StreamingXmlWriter(charset))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Writer Flow that takes a stream of XML events similar to SAX and write ByteStrings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * encoding UTF-8[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val writer: Flow[ParseEvent, ByteString, NotUsed] = writer(StandardCharsets.UTF_8)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/scaladsl/XmlParsing.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.ParseEvent[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.w3c.dom.Element[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject XmlParsing {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Parser Flow that takes a stream of ByteStrings and parses them to XML events similar to SAX.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  val parser: Flow[ByteString, ParseEvent, NotUsed] = parser(false)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Parser Flow that takes a stream of ByteStrings and parses them to XML events similar to SAX.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def parser(ignoreInvalidChars: Boolean = false): Flow[ByteString, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.StreamingXmlParser(ignoreInvalidChars))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage coalesces consecutive CData and Characters[0m
[0m[[0m[0mdebug[0m] [0m[0m   * events into a single Characters event or fails if the buffered string is larger than the maximum defined.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def coalesce(maximumTextLength: Int): Flow[ParseEvent, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.Coalesce(maximumTextLength))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage filters out any event not corresponding to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * a certain path in the XML document. Any event that is under the specified path (including subpaths) is passed[0m
[0m[[0m[0mdebug[0m] [0m[0m   * through.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def subslice(path: immutable.Seq[String]): Flow[ParseEvent, ParseEvent, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.Subslice(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A Flow that transforms a stream of XML ParseEvents. This stage pushes elements of a certain path in[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the XML document as org.w3c.dom.Element.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def subtree(path: immutable.Seq[String]): Flow[ParseEvent, Element, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new impl.Subtree(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/impl/Subslice.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.{EndElement, ParseEvent, StartElement}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[xml] class Subslice(path: immutable.Seq[String])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ParseEvent, ParseEvent]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ParseEvent] = Inlet("XMLSubslice.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ParseEvent] = Outlet("XMLSubslice.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ParseEvent, ParseEvent] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var expected = path.toList[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var matchedSoFar: List[String] = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val passThrough: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        var depth = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case start: StartElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            depth += 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            push(out, start)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case end: EndElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (depth == 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              expected = matchedSoFar.head :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m              matchedSoFar = matchedSoFar.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m              setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m              pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              depth -= 1[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, end)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            push(out, other)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (path.isEmpty) setHandler(in, passThrough) else setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val partialMatch: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case StartElement(name, _, _, _, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (name == expected.head) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              matchedSoFar = expected.head :: matchedSoFar[0m
[0m[[0m[0mdebug[0m] [0m[0m              expected = expected.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (expected.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                setHandler(in, passThrough)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              setHandler(in, noMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case EndElement(name) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            expected = matchedSoFar.head :: expected[0m
[0m[[0m[0mdebug[0m] [0m[0m            matchedSoFar = matchedSoFar.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val noMatch: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        var depth = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case start: StartElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            depth += 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case end: EndElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (depth == 0) setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m            else depth -= 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/impl/Subtree.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.xml.parsers.DocumentBuilderFactory[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.w3c.dom.Element[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[xml] class Subtree(path: immutable.Seq[String])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ParseEvent, Element]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ParseEvent] = Inlet("XMLSubtree.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[Element] = Outlet("XMLSubtree.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ParseEvent, Element] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createElement(start: StartElement): Element = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val element = start.namespace match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(ns) => doc.createElementNS(ns, start.localName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None => doc.createElement(start.localName)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    start.attributes.foreach {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (name, value) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        element.setAttribute(name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    element[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var expected = path.toList[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var matchedSoFar: List[String] = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var elementStack: List[Element] = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val matching: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case start: StartElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val element = createElement(start)[0m
[0m[[0m[0mdebug[0m] [0m[0m            elementStack.headOption.foreach { head =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              head.appendChild(element)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            elementStack = element :: elementStack[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: EndElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            elementStack match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case head :: Nil =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                expected = matchedSoFar.head :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m                matchedSoFar = matchedSoFar.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m                push(out, head)[0m
[0m[[0m[0mdebug[0m] [0m[0m                elementStack = Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m                setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                elementStack = elementStack.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m                pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case cdata: CData =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            elementStack.headOption.foreach { element =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              element.appendChild(doc.createCDATASection(cdata.text))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case text: TextEvent =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            elementStack.headOption.foreach { element =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              element.appendChild(doc.createTextNode(text.text))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (path.isEmpty) setHandler(in, matching) else setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val partialMatch: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case start: StartElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (start.localName == expected.head) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              matchedSoFar = expected.head :: matchedSoFar[0m
[0m[[0m[0mdebug[0m] [0m[0m              expected = expected.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (expected.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                val element = createElement(start)[0m
[0m[[0m[0mdebug[0m] [0m[0m                elementStack = element :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m                setHandler(in, matching)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              setHandler(in, noMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: EndElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            expected = matchedSoFar.head :: expected[0m
[0m[[0m[0mdebug[0m] [0m[0m            matchedSoFar = matchedSoFar.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val noMatch: InHandler = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        var depth = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: StartElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            depth += 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _: EndElement =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (depth == 0) setHandler(in, partialMatch)[0m
[0m[[0m[0mdebug[0m] [0m[0m            else depth -= 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/impl/StreamingXmlWriter.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.Charset[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.{ByteString, ByteStringBuilder}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.xml.stream.XMLOutputFactory[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[xml] class StreamingXmlWriter(charset: Charset)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ParseEvent, ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ParseEvent] = Inlet("XMLWriter.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ByteString] = Outlet("XMLWriter.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ParseEvent, ByteString] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val xMLOutputFactory = XMLOutputFactory.newInstance()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val byteStringBuilder = new ByteStringBuilder()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val output = xMLOutputFactory.createXMLStreamWriter(byteStringBuilder.asOutputStream, charset.name())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def writeAttributes(attributes: List[Attribute]): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        attributes.foreach { att =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          att match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Attribute(name, value, Some(prefix), Some(namespace)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              output.writeAttribute(prefix, namespace, name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Attribute(name, value, None, Some(namespace)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              output.writeAttribute(namespace, name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Attribute(name, value, Some(_), None) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              output.writeAttribute(name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Attribute(name, value, None, None) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              output.writeAttribute(name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val ev: ParseEvent = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        ev match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case StartDocument =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeStartDocument()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case EndDocument =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeEndDocument()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case StartElement(localName, attributes, optPrefix, Some(namespace), namespaceCtx) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val prefix = optPrefix.getOrElse("")[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.setPrefix(prefix, namespace)[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeStartElement(prefix, localName, namespace)[0m
[0m[[0m[0mdebug[0m] [0m[0m            namespaceCtx.foreach(ns => output.writeNamespace(ns.prefix.getOrElse(""), ns.uri))[0m
[0m[[0m[0mdebug[0m] [0m[0m            writeAttributes(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case StartElement(localName, attributes, Some(_), None, namespaceCtx) => // Shouldn't happened[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeStartElement(localName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            namespaceCtx.foreach(ns => output.writeNamespace(ns.prefix.getOrElse(""), ns.uri))[0m
[0m[[0m[0mdebug[0m] [0m[0m            writeAttributes(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case StartElement(localName, attributes, None, None, namespaceCtx) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeStartElement(localName)[0m
[0m[[0m[0mdebug[0m] [0m[0m            namespaceCtx.foreach(ns => output.writeNamespace(ns.prefix.getOrElse(""), ns.uri))[0m
[0m[[0m[0mdebug[0m] [0m[0m            writeAttributes(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case EndElement(_) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeEndElement()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Characters(text) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeCharacters(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ProcessingInstruction(Some(target), Some(data)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeProcessingInstruction(target, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ProcessingInstruction(Some(target), None) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeProcessingInstruction(target)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ProcessingInstruction(None, Some(data)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeProcessingInstruction(None.orNull, data)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ProcessingInstruction(None, None) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          case Comment(text) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeComment(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case CData(text) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            output.writeCData(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        push(out, byteStringBuilder.result().compact)[0m
[0m[[0m[0mdebug[0m] [0m[0m        byteStringBuilder.clear()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        output.flush()[0m
[0m[[0m[0mdebug[0m] [0m[0m        val finalData = byteStringBuilder.result().compact[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (finalData.length != 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          emit(out, finalData)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        super.onUpstreamFinish()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/impl/StreamingXmlParser.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.aalto.{AsyncByteArrayFeeder, AsyncXMLInputFactory, AsyncXMLStreamReader}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.aalto.stax.InputFactoryImpl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.fasterxml.aalto.util.IllegalCharHandler.ReplacingIllegalCharHandler[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[xml] class StreamingXmlParser(ignoreInvalidChars: Boolean)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ByteString, ParseEvent]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ByteString] = Inlet("XMLParser.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ParseEvent] = Outlet("XMLParser.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ByteString, ParseEvent] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      import javax.xml.stream.XMLStreamConstants[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val feeder: AsyncXMLInputFactory = new InputFactoryImpl()[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val parser: AsyncXMLStreamReader[AsyncByteArrayFeeder] = feeder.createAsyncFor(Array.empty)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (ignoreInvalidChars) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        parser.getConfig.setIllegalCharHandler(new ReplacingIllegalCharHandler(0))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val array = grab(in).toArray[0m
[0m[[0m[0mdebug[0m] [0m[0m        parser.getInputFeeder.feedInput(array, 0, array.length)[0m
[0m[[0m[0mdebug[0m] [0m[0m        advanceParser()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = advanceParser()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        parser.getInputFeeder.endOfInput()[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!parser.hasNext) completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m        else if (isAvailable(out)) advanceParser()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      @tailrec private def advanceParser(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (parser.hasNext) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          parser.next() match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case AsyncXMLStreamReader.EVENT_INCOMPLETE =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (!isClosed(in)) pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m              else failStage(new IllegalStateException("Stream finished before event was fully parsed."))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.START_DOCUMENT =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, StartDocument)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.END_DOCUMENT =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, EndDocument)[0m
[0m[[0m[0mdebug[0m] [0m[0m              completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.START_ELEMENT =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              val attributes = (0 until parser.getAttributeCount).map { i =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val optNs = Option(parser.getAttributeNamespace(i)).filterNot(_ == "")[0m
[0m[[0m[0mdebug[0m] [0m[0m                val optPrefix = Option(parser.getAttributePrefix(i)).filterNot(_ == "")[0m
[0m[[0m[0mdebug[0m] [0m[0m                Attribute(name = parser.getAttributeLocalName(i),[0m
[0m[[0m[0mdebug[0m] [0m[0m                          value = parser.getAttributeValue(i),[0m
[0m[[0m[0mdebug[0m] [0m[0m                          prefix = optPrefix,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          namespace = optNs)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }.toList[0m
[0m[[0m[0mdebug[0m] [0m[0m              val namespaces = (0 until parser.getNamespaceCount).map { i =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val namespace = parser.getNamespaceURI(i)[0m
[0m[[0m[0mdebug[0m] [0m[0m                val optPrefix = Option(parser.getNamespacePrefix(i)).filterNot(_ == "")[0m
[0m[[0m[0mdebug[0m] [0m[0m                Namespace(namespace, optPrefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }.toList[0m
[0m[[0m[0mdebug[0m] [0m[0m              val optPrefix = Option(parser.getPrefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m              val optNs = optPrefix.flatMap(prefix => Option(parser.getNamespaceURI(prefix)))[0m
[0m[[0m[0mdebug[0m] [0m[0m              push([0m
[0m[[0m[0mdebug[0m] [0m[0m                out,[0m
[0m[[0m[0mdebug[0m] [0m[0m                StartElement(parser.getLocalName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             attributes,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             optPrefix.filterNot(_ == ""),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             optNs.filterNot(_ == ""),[0m
[0m[[0m[0mdebug[0m] [0m[0m                             namespaceCtx = namespaces)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.END_ELEMENT =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, EndElement(parser.getLocalName))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.CHARACTERS =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, Characters(parser.getText))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.PROCESSING_INSTRUCTION =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, ProcessingInstruction(Option(parser.getPITarget), Option(parser.getPIData)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.COMMENT =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, Comment(parser.getText))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case XMLStreamConstants.CDATA =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              push(out, CData(parser.getText))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            // Do not support DTD, SPACE, NAMESPACE, NOTATION_DECLARATION, ENTITY_DECLARATION, PROCESSING_INSTRUCTION[0m
[0m[[0m[0mdebug[0m] [0m[0m            // ATTRIBUTE is handled in START_ELEMENT implicitly[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case x =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              advanceParser()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/impl/Coalesce.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.xml.{Characters, ParseEvent, TextEvent}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[xml] class Coalesce(maximumTextLength: Int) extends GraphStage[FlowShape[ParseEvent, ParseEvent]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ParseEvent] = Inlet("XMLCoalesce.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ParseEvent] = Outlet("XMLCoalesce.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ParseEvent, ParseEvent] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var isBuffering = false[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val buffer = new StringBuilder[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = grab(in) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case t: TextEvent =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (t.text.length + buffer.length > maximumTextLength)[0m
[0m[[0m[0mdebug[0m] [0m[0m            failStage([0m
[0m[[0m[0mdebug[0m] [0m[0m              new IllegalStateException([0m
[0m[[0m[0mdebug[0m] [0m[0m                s"Too long character sequence, maximum is $maximumTextLength but got " +[0m
[0m[[0m[0mdebug[0m] [0m[0m                s"${t.text.length + buffer.length - maximumTextLength} more "[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            buffer.append(t.text)[0m
[0m[[0m[0mdebug[0m] [0m[0m            isBuffering = true[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (isBuffering) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val coalesced = buffer.toString()[0m
[0m[[0m[0mdebug[0m] [0m[0m            isBuffering = false[0m
[0m[[0m[0mdebug[0m] [0m[0m            buffer.clear()[0m
[0m[[0m[0mdebug[0m] [0m[0m            emit(out, Characters(coalesced), () => emit(out, other, () => if (isClosed(in)) completeStage()))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            push(out, other)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (isBuffering) emit(out, Characters(buffer.toString()), () => completeStage())[0m
[0m[[0m[0mdebug[0m] [0m[0m        else completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/scala/akka/stream/alpakka/xml/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Optional[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * XML parsing events emitted by the parser flow. These roughly correspond to Java XMLEvent types.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API: allows to use switch statement to match parse events */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def marker: ParseEventMarker[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait TextEvent extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def text: String[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object StartDocument extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLStartDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getInstance(): StartDocument.type = this[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object EndDocument extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLEndDocument[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getInstance(): EndDocument.type = this[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Namespace(uri: String, prefix: Option[String] = None) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPrefix(): java.util.Optional[String] = prefix.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Namespace {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(uri: String, prefix: Optional[String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Namespace(uri, prefix.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Attribute(name: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                           value: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                           prefix: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                           namespace: Option[String] = None) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPrefix(): java.util.Optional[String] = prefix.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getNamespace(): java.util.Optional[String] = namespace.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Attribute {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(name: String, value: String, prefix: Optional[String], namespace: Optional[String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Attribute(name, value, prefix.asScala, namespace.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(name: String, value: String) = Attribute(name, value)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class StartElement(localName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              attributesList: List[Attribute] = List.empty[Attribute],[0m
[0m[[0m[0mdebug[0m] [0m[0m                              prefix: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              namespace: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                              namespaceCtx: List[Namespace] = List.empty[Namespace])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLStartElement[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val attributes: Map[String, String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    attributesList.map(attr => attr.name -> attr.value).toMap[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getAttributes(): java.util.Map[String, String] = attributes.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPrefix(): java.util.Optional[String] = prefix.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getNamespace(): java.util.Optional[String] = namespace.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getNamespaceCtx(): java.util.List[Namespace] = namespaceCtx.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def findAttribute(name: String): Option[Attribute] = attributesList.find(_.name == name)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject StartElement {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromMapToAttributeList(prefix: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             namespace: Option[String] = None)(attributes: Map[String, String]): List[Attribute] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    attributes.toList.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (name, value) => Attribute(name, value, prefix, namespace)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(localName: String, attributes: Map[String, String]): StartElement = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val attributesList = fromMapToAttributeList()(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m    new StartElement(localName, attributesList, prefix = None, namespace = None, namespaceCtx = List.empty[Namespace])[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(localName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             attributesList: java.util.List[Attribute],[0m
[0m[[0m[0mdebug[0m] [0m[0m             prefix: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             namespace: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             namespaceCtx: java.util.List[Namespace]): StartElement =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new StartElement(localName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     attributesList.asScala.toList,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     prefix.asScala,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     namespace.asScala,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     namespaceCtx.asScala.toList)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(localName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m             attributesList: java.util.List[Attribute],[0m
[0m[[0m[0mdebug[0m] [0m[0m             prefix: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m             namespace: Optional[String]): StartElement =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new StartElement(localName, attributesList.asScala.toList, prefix.asScala, namespace.asScala, List.empty[Namespace])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(localName: String, attributesList: java.util.List[Attribute], namespace: String): StartElement =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new StartElement(localName,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     attributesList.asScala.toList,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     prefix = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                     namespace = Some(namespace),[0m
[0m[[0m[0mdebug[0m] [0m[0m                     namespaceCtx = List(Namespace(namespace)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(localName: String, attributes: java.util.Map[String, String]): StartElement =[0m
[0m[[0m[0mdebug[0m] [0m[0m    StartElement(localName, attributes.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class EndElement(localName: String) extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLEndElement[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject EndElement {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(localName: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    EndElement(localName)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Characters(text: String) extends TextEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLCharacters[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Characters {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(text: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Characters(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class ProcessingInstruction(target: Option[String], data: Option[String]) extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLProcessingInstruction[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getTarget(): java.util.Optional[String] = target.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getData(): java.util.Optional[String] = data.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ProcessingInstruction {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(target: Optional[String], data: Optional[String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ProcessingInstruction(target.asScala, data.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class Comment(text: String) extends ParseEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLComment[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Comment {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(text: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Comment(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class CData(text: String) extends TextEvent {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val marker = ParseEventMarker.XMLCData[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CData {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(text: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CData(text)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/xml/src/main/java/akka/stream/alpakka/xml/ParseEventMarker.java[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.xml;[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Mirrors the sub-classes of [[ParseEvent]] to allow use with Java switch statements instead of[0m
[0m[[0m[0mdebug[0m] [0m[0m * chained `instanceOf` tests.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mpublic enum ParseEventMarker {[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLStartDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLEndDocument,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLStartElement,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLEndElement,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLCharacters,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLProcessingInstruction,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLComment,[0m
[0m[[0m[0mdebug[0m] [0m[0m  XMLCData,[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
