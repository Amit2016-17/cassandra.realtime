[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/javadsl/package.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.scaladsl.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  Committable => ScalaCommittable,[0m
[0m[[0m[0mdebug[0m] [0m[0m  CommittableMessage => ScalaCommittableMessage[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * This implicit classes allow to convert the Committable and CommittableMessage between scaladsl and javadsl.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage object javadsl {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[javadsl] implicit class RichScalaCommittableMessage(cm: ScalaCommittableMessage) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def asJava: CommittableMessage = new CommittableMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def message: Message = cm.message[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def commit(): CompletionStage[Done] = cm.commit().toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[javadsl] implicit class RichScalaCommittable(cm: ScalaCommittable) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def asJava: Committable = new Committable {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def commit(): CompletionStage[Done] = cm.commit().toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[javadsl] implicit class RichCommittableMessage(cm: CommittableMessage) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def asScala: ScalaCommittableMessage = new ScalaCommittableMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def message: Message = cm.message[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def commit(): Future[Done] = cm.commit().toScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[javadsl] implicit class RichCommittable(cm: Committable) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def asScala: ScalaCommittable = new ScalaCommittable {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def commit(): Future[Done] = cm.commit().toScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/javadsl/IronMqConsumer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.scaladsl.{IronMqConsumer => ScalaIronMqConsumer}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqConsumer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnceSource(queueName: String, settings: IronMqSettings): Source[Message, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaIronMqConsumer.atMostOnceSource(queueName, settings).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSource(queueName: String, settings: IronMqSettings): Source[CommittableMessage, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaIronMqConsumer.atLeastOnceSource(queueName, settings).map(_.asJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/javadsl/IronMqProducer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.japi.Pair[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{Flow, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Flow => ScalaFlow}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.scaladsl.{IronMqProducer => ScalaIronMqProducer}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqProducer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow(queueName: String, settings: IronMqSettings): Flow[PushMessage, String, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaIronMqProducer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow(queueName, settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m      // To make Message.Id a String[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asInstanceOf[Flow[PushMessage, String, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink(queueName: String, settings: IronMqSettings): Sink[PushMessage, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaIronMqProducer.sink(queueName, settings).mapMaterializedValue(_.toJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceFlow[C1 <: Committable]([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: IronMqSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[CommittablePushMessage[C1], String, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaFlow[CommittablePushMessage[C1]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { cm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        cm.message -> cm.toCommit.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(ScalaIronMqProducer.atLeastOnceFlow(queueName, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m      // To make Message.Id a String[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asInstanceOf[Flow[CommittablePushMessage[C1], String, NotUsed]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSink[C1 <: Committable](queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                         settings: IronMqSettings): Sink[CommittablePushMessage[C1], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaFlow[CommittablePushMessage[C1]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { cm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        cm.message -> cm.toCommit.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .to(ScalaIronMqProducer.atLeastOnceSink(queueName, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceFlow[ToCommit, CommitResult, CommitMat]([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: IronMqSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      commitFlow: Flow[ToCommit, CommitResult, CommitMat][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[CommittablePushMessage[ToCommit], Pair[String, CommitResult], CommitMat] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaFlow[CommittablePushMessage[ToCommit]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { cm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        cm.message -> cm.toCommit[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .viaMat(ScalaIronMqProducer.atLeastOnceFlow(queueName, settings, commitFlow.asScala))([0m
[0m[[0m[0mdebug[0m] [0m[0m        Keep.right[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(p => Pair(p._1.asInstanceOf[String], p._2))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSink[ToCommit, CommitResult, CommitMat]([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: IronMqSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      commitFlow: Flow[ToCommit, CommitResult, CommitMat][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[CommittablePushMessage[ToCommit], CommitMat] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaFlow[CommittablePushMessage[ToCommit]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { cm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        cm.message -> cm.toCommit[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(ScalaIronMqProducer.atLeastOnceSink(queueName, settings, commitFlow.asScala))([0m
[0m[[0m[0mdebug[0m] [0m[0m        Keep.right[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class CommittablePushMessage[ToCommit](message: PushMessage, toCommit: ToCommit)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CommittablePushMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[ToCommit](message: PushMessage, toCommit: ToCommit): CommittablePushMessage[ToCommit] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CommittablePushMessage(message, toCommit)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[ToCommit](messageBody: String, toCommit: ToCommit): CommittablePushMessage[ToCommit] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CommittablePushMessage(PushMessage(messageBody), toCommit)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(committableMessage: CommittableMessage): CommittablePushMessage[CommittableMessage] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    CommittablePushMessage(PushMessage(committableMessage.message.body), committableMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/javadsl/CommittableMessage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.Message[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Commit an offset that is included in a [[CommittableMessage]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait Committable {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def commit(): CompletionStage[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * A [[Committable]] wrapper around the IronMq [[Message]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait CommittableMessage extends Committable {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def message: Message[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/scaladsl/IronMqConsumer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.impl.IronMqPullStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqConsumer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atMostOnceSource(queueName: String, settings: IronMqSettings): Source[Message, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new IronMqPullStage(queueName, settings)).mapAsync(1) { cm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      cm.commit().map(_ => cm.message)(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSource[K, V](queueName: String, settings: IronMqSettings): Source[CommittableMessage, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new IronMqPullStage(queueName, settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/scaladsl/IronMqProducer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.FlowShape[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.impl.IronMqPushStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqProducer {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This is plain producer [[akka.stream.scaladsl.Flow Flow]] that consume [[PushMessage]] and emit [[Message.Id]] for each produced message.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow(queueName: String, settings: IronMqSettings): Flow[PushMessage, Message.Id, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    // The parallelism MUST be 1 to guarantee the order of the messages[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new IronMqPushStage(queueName, settings)).mapAsync(1)(identity).mapConcat(_.ids)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A plain producer [[akka.stream.scaladsl.Sink Sink]] that consume [[PushMessage]] and push them on IronMq.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink(queueName: String, settings: IronMqSettings): Sink[PushMessage, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    flow(queueName, settings).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[Committable]] aware producer [[akka.stream.scaladsl.Flow Flow]] that consume [[(PushMessage, Committable)]], push messages on IronMq and[0m
[0m[[0m[0mdebug[0m] [0m[0m   * commit the associated [[Committable]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceFlow(queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      settings: IronMqSettings): Flow[(PushMessage, Committable), Message.Id, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    // TODO Not sure about parallelism, as the commits should not be in-order, maybe add it as parameter?[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnceFlow(queueName, settings, Flow[Committable].mapAsync(1)(_.commit())).map(_._1)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[Committable]] aware producer [[akka.stream.scaladsl.Sink Sink]] that consume [[(PushMessage, Committable)]] push messages on IronMq and[0m
[0m[[0m[0mdebug[0m] [0m[0m   * commit the associated [[Committable]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSink(queueName: String, settings: IronMqSettings): Sink[(PushMessage, Committable), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnceFlow(queueName, settings).to(Sink.ignore)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A more generic committable aware producer [[akka.stream.scaladsl.Flow Flow]] that can be used for other committable source, like Kafka. The[0m
[0m[[0m[0mdebug[0m] [0m[0m   * user is responsible to supply the committing flow. The result of the commit is emitted as well as the materialized[0m
[0m[[0m[0mdebug[0m] [0m[0m   * value of the committing flow.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceFlow[ToCommit, CommitResult, CommitMat]([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: IronMqSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      commitFlow: Flow[ToCommit, CommitResult, CommitMat][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[(PushMessage, ToCommit), (Message.Id, CommitResult), CommitMat] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // This graph is used to pass the ToCommit through the producer. It assume a 1-to-1 semantic on the producer[0m
[0m[[0m[0mdebug[0m] [0m[0m    val producerGraph = GraphDSL.create(flow(queueName, settings)) { implicit builder => producer =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      import GraphDSL.Implicits._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val broadcast = builder.add(Broadcast[(PushMessage, ToCommit)](2))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val zip = builder.add(Zip[Message.Id, ToCommit])[0m
[0m[[0m[0mdebug[0m] [0m[0m      val extractPushMessage = builder.add(Flow[(PushMessage, ToCommit)].map(_._1))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val extractCommittable = builder.add(Flow[(PushMessage, ToCommit)].map(_._2))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      broadcast ~> extractPushMessage ~> producer ~> zip.in0[0m
[0m[[0m[0mdebug[0m] [0m[0m      broadcast ~> extractCommittable ~> zip.in1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      FlowShape(broadcast.in, zip.out)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // This graph is used to pass the ToCommit through the commitFlow. Again it assume the commitFlow to have 1-to-1 semantic[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(GraphDSL.create(producerGraph, commitFlow)(Keep.right) { implicit builder => (producer, committer) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      import GraphDSL.Implicits._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val broadcast = builder.add(Broadcast[(Message.Id, ToCommit)](2))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val extractMessageId = builder.add(Flow[(Message.Id, ToCommit)].map(_._1))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val extractCommittable = builder.add(Flow[(Message.Id, ToCommit)].map(_._2))[0m
[0m[[0m[0mdebug[0m] [0m[0m      val zip = builder.add(Zip[Message.Id, CommitResult])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      producer ~> broadcast ~> extractMessageId ~> zip.in0[0m
[0m[[0m[0mdebug[0m] [0m[0m      broadcast ~> extractCommittable ~> committer ~> zip.in1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      FlowShape(producer.in, zip.out)[0m
[0m[[0m[0mdebug[0m] [0m[0m    })[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A more generic committable aware producer [[akka.stream.scaladsl.Sink Sink]] that can be used for other committable source, like Kafka. The[0m
[0m[[0m[0mdebug[0m] [0m[0m   * user is responsible to supply the committing flow. The materialized value of the committing flow is returned.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def atLeastOnceSink[ToCommit, CommitResult, CommitMat]([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings: IronMqSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m      commitFlow: Flow[ToCommit, CommitResult, CommitMat][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[(PushMessage, ToCommit), CommitMat] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    atLeastOnceFlow(queueName, settings, commitFlow).to(Sink.ignore)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/scaladsl/CommittableMessage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.Message[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Commit an offset that is included in a [[CommittableMessage]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait Committable {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def commit(): Future[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * A [[Committable]] wrapper around the IronMq [[Message]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mtrait CommittableMessage extends Committable {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def message: Message[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/IronMqSettings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.Uri[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.IronMqSettings.ConsumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * IronMQ settings. To a detailed documentation please refer to the reference.conf.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class IronMqSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val endpoint: akka.http.scaladsl.model.Uri,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val projectId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val token: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val consumerSettings: ConsumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The IronMq endpoint. It is available on the IronMQ project page and change based on availability zone and region. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withEndpoint(value: akka.http.scaladsl.model.Uri): IronMqSettings = copy(endpoint = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The IronMq project id, it is available on the IronMQ hud. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProjectId(value: String): IronMqSettings = copy(projectId = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The IronMq authentication token, it is available on the IronMQ hud. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withToken(value: String): IronMqSettings = copy(token = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** The IronMq consumer settings. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConsumerSettings(value: ConsumerSettings): IronMqSettings = copy(consumerSettings = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      endpoint: akka.http.scaladsl.model.Uri = endpoint,[0m
[0m[[0m[0mdebug[0m] [0m[0m      projectId: String = projectId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      token: String = token,[0m
[0m[[0m[0mdebug[0m] [0m[0m      consumerSettings: ConsumerSettings = consumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): IronMqSettings = new IronMqSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    endpoint = endpoint,[0m
[0m[[0m[0mdebug[0m] [0m[0m    projectId = projectId,[0m
[0m[[0m[0mdebug[0m] [0m[0m    token = token,[0m
[0m[[0m[0mdebug[0m] [0m[0m    consumerSettings = consumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "IronMqSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"endpoint=$endpoint," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"projectId=$projectId," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"token=$token," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"consumerSettings=$consumerSettings" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConfigPath = "alpakka.ironmq"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final class ConsumerSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m      val bufferMinSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      val bufferMaxSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      val fetchInterval: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m      val pollTimeout: scala.concurrent.duration.FiniteDuration,[0m
[0m[[0m[0mdebug[0m] [0m[0m      val reservationTimeout: scala.concurrent.duration.FiniteDuration[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** The buffer size limit where a new batch of message will be consumed from the queue. */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withBufferMinSize(value: Int): ConsumerSettings = copy(bufferMinSize = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** The maximum number of buffered messages. */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withBufferMaxSize(value: Int): ConsumerSettings = copy(bufferMaxSize = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Scala API: The interval of time between each poll loop. */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withFetchInterval(value: scala.concurrent.duration.FiniteDuration): ConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m      copy(fetchInterval = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Java API: The interval of time between each poll loop. */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withFetchInterval(value: java.time.Duration): ConsumerSettings = copy(fetchInterval = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m     * The amount of time the consumer will wait for the messages to be available on the queue. The IronMQ time unit is[0m
[0m[[0m[0mdebug[0m] [0m[0m     * the second so any other value is approximated to the second.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withPollTimeout(value: scala.concurrent.duration.FiniteDuration): ConsumerSettings = copy(pollTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m     * The amount of time the consumer will wait for the messages to be available on the queue. The IronMQ time unit is[0m
[0m[[0m[0mdebug[0m] [0m[0m     * the second so any other value is approximated to the second.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withPollTimeout(value: java.time.Duration): ConsumerSettings = copy(pollTimeout = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m     * The amount of time the consumer will reserve the message from. It should be higher that the time needed to[0m
[0m[[0m[0mdebug[0m] [0m[0m     * process the message otherwise the same message will be processed multiple times. Again the IronMq time unit is[0m
[0m[[0m[0mdebug[0m] [0m[0m     * the second.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withReservationTimeout(value: scala.concurrent.duration.FiniteDuration): ConsumerSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m      copy(reservationTimeout = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /** Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m     * The amount of time the consumer will reserve the message from. It should be higher that the time needed to[0m
[0m[[0m[0mdebug[0m] [0m[0m     * process the message otherwise the same message will be processed multiple times. Again the IronMq time unit is[0m
[0m[[0m[0mdebug[0m] [0m[0m     * the second.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withReservationTimeout(value: java.time.Duration): ConsumerSettings = copy(reservationTimeout = value.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m        bufferMinSize: Int = bufferMinSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        bufferMaxSize: Int = bufferMaxSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        fetchInterval: scala.concurrent.duration.FiniteDuration = fetchInterval,[0m
[0m[[0m[0mdebug[0m] [0m[0m        pollTimeout: scala.concurrent.duration.FiniteDuration = pollTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m        reservationTimeout: scala.concurrent.duration.FiniteDuration = reservationTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m    ): ConsumerSettings = new ConsumerSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferMinSize = bufferMinSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferMaxSize = bufferMaxSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      fetchInterval = fetchInterval,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pollTimeout = pollTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m      reservationTimeout = reservationTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m      "ConsumerSettings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"bufferMinSize=$bufferMinSize," +[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"bufferMaxSize=$bufferMaxSize," +[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"fetchInterval=${fetchInterval.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"pollTimeout=${pollTimeout.toCoarsest}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"reservationTimeout=${reservationTimeout.toCoarsest}" +[0m
[0m[[0m[0mdebug[0m] [0m[0m      ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  object ConsumerSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def apply(config: Config): ConsumerSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val bufferMinSize: Int = config.getInt("buffer-min-size")[0m
[0m[[0m[0mdebug[0m] [0m[0m      val bufferMaxSize: Int = config.getInt("buffer-max-size")[0m
[0m[[0m[0mdebug[0m] [0m[0m      val fetchInterval: FiniteDuration = config.getDuration("fetch-interval").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m      val pollTimeout: FiniteDuration = config.getDuration("poll-timeout").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m      val reservationTimeout: FiniteDuration = config.getDuration("reservation-timeout").asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m      new ConsumerSettings(bufferMinSize, bufferMaxSize, fetchInterval, pollTimeout, reservationTimeout)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Will create a [[IronMqSettings]] from a config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(config: Config): IronMqSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val endpoint: Uri = config.getString("endpoint")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val projectId: String = config.getString("credentials.project-id")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val token: String = config.getString("credentials.token")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val consumerSettings: ConsumerSettings = ConsumerSettings(config.getConfig("consumer"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    new IronMqSettings(endpoint, projectId, token, consumerSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Will create a [[IronMqSettings]] from a ActorSystem using the default config path `alpakka.ironmq`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply()(implicit as: ActorSystem): IronMqSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(as.settings.config.getConfig(ConfigPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(config: Config): IronMqSettings = apply(config)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(as: ActorSystem): IronMqSettings = apply()(as)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/impl/IronMqPullStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.IronMqSettings.ConsumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.scaladsl.CommittableMessage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContextExecutor, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] object IronMqPullStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val FetchMessagesTimerKey = "fetch-messages"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * This stage will fetch messages from IronMq and buffer them internally.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * It is implemented as a timed loop, each invocation will fetch new messages from IronMq if the amount of buffered[0m
[0m[[0m[0mdebug[0m] [0m[0m * messages is lower than [[akka.stream.alpakka.ironmq.IronMqSettings.ConsumerSettings.bufferMinSize]].[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The frequency of the loop is controlled by [[akka.stream.alpakka.ironmq.IronMqSettings.ConsumerSettings.fetchInterval]] while the amount of time the client is[0m
[0m[[0m[0mdebug[0m] [0m[0m * blocked on the HTTP request waiting for messages is controlled by [[ConsumerSettings.pollTimeout]].[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Keep in mind that the IronMq time unit is the second, so any value below the second is considered 0.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] final class IronMqPullStage(queueName: String, settings: IronMqSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[SourceShape[CommittableMessage]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import IronMqPullStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val consumerSettings: ConsumerSettings = settings.consumerSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  import consumerSettings._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out: Outlet[CommittableMessage] = Outlet("IronMqPull.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected val initialAttributes: Attributes = Attributes.name("IronMqPull")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: SourceShape[CommittableMessage] = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new TimerGraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit def ec: ExecutionContextExecutor = materializer.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      // This flag avoid run concurrent fetch from IronMQ[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var fetching: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var buffer: List[ReservedMessage] = List.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var client: IronMqClient = _ // set in preStart[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        client = IronMqClient(settings)(ActorMaterializerHelper.downcast(materializer).system, materializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        out,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPull(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (!isTimerActive(FetchMessagesTimerKey)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              schedulePeriodically(FetchMessagesTimerKey, fetchInterval)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            deliveryMessages()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected def onTimer(timerKey: Any): Unit = timerKey match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case FetchMessagesTimerKey =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          fetchMessages()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def fetchMessages(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!fetching && buffer.size < bufferMinSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          fetching = true[0m
[0m[[0m[0mdebug[0m] [0m[0m          client[0m
[0m[[0m[0mdebug[0m] [0m[0m            .reserveMessages([0m
[0m[[0m[0mdebug[0m] [0m[0m              queueName,[0m
[0m[[0m[0mdebug[0m] [0m[0m              bufferMaxSize - buffer.size,[0m
[0m[[0m[0mdebug[0m] [0m[0m              watch = pollTimeout,[0m
[0m[[0m[0mdebug[0m] [0m[0m              timeout = reservationTimeout[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m            .onComplete {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Success(xs) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                updateBuffer.invoke(xs.toList)[0m
[0m[[0m[0mdebug[0m] [0m[0m                updateFetching.invoke(false)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case Failure(error) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                fail(out, error)[0m
[0m[[0m[0mdebug[0m] [0m[0m                updateFetching.invoke(false)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def deliveryMessages(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        while (buffer.nonEmpty && isAvailable(out)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val messageToDelivery: ReservedMessage = buffer.head[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          val committableMessage: CommittableMessage = new CommittableMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m            override val message: Message = messageToDelivery.message[0m
[0m[[0m[0mdebug[0m] [0m[0m            override def commit(): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m              client.deleteMessages(queueName, messageToDelivery.reservation).map(_ => Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          push(out, committableMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m          buffer = buffer.tail[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val updateBuffer = getAsyncCallback { xs: List[ReservedMessage] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        buffer = buffer ::: xs[0m
[0m[[0m[0mdebug[0m] [0m[0m        deliveryMessages()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val updateFetching = getAsyncCallback { x: Boolean =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        fetching = x[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/impl/Codec.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.Message[0m
[0m[[0m[0mdebug[0m] [0m[0mimport io.circe.syntax._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport io.circe.{Decoder, Encoder, Json}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// required on Scala 2.11[0m
[0m[[0m[0mdebug[0m] [0m[0mimport cats.syntax.either._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Simplified representation of the IronMq queue for JSON conversion.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param name The name associated with this Queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate case class Queue(name: Queue.Name)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object Queue {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Name(value: String) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String = value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate trait Codec {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val messageIdEncoder: Encoder[Message.Id] = Encoder.instance { id =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    Json.fromString(id.value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val messageIdDecoder: Decoder[Message.Id] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    cursor.as[String].map(Message.Id.apply)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val reservationIdEncoder: Encoder[Reservation.Id] = Encoder.instance { id =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    Json.fromString(id.value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val reservationIdDecoder: Decoder[Reservation.Id] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    cursor.as[String].map(Reservation.Id.apply)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val messageIdsDecoder: Decoder[Message.Ids] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    cursor.downField("ids").as[List[Message.Id]].map(Message.Ids.apply)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val queueDecoder: Decoder[Queue] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      name <- cursor.downField("name").as[Queue.Name][0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield Queue(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val queueNameDecoder: Decoder[Queue.Name] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    cursor.as[String].map(Queue.Name.apply)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val queueNameEncoder: Encoder[Queue.Name] = Encoder.instance { qn =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    Json.fromString(qn.value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val messageDecoder: Decoder[Message] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      id <- cursor.downField("id").as[Message.Id][0m
[0m[[0m[0mdebug[0m] [0m[0m      body <- cursor.downField("body").as[String][0m
[0m[[0m[0mdebug[0m] [0m[0m      noOfReservations <- cursor.downField("reserved_count").as[Int][0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield Message(id, body, noOfReservations)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val reservedMessageDecoder: Decoder[ReservedMessage] = Decoder.instance { cursor =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      message <- cursor.as[Message][0m
[0m[[0m[0mdebug[0m] [0m[0m      reservationId <- cursor.downField("reservation_id").as[Reservation.Id][0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield ReservedMessage(reservationId, message)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val reservationEncoder: Encoder[Reservation] = Encoder.instance { r =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    Json.obj("id" -> r.messageId.asJson, "reservation_id" -> r.reservationId.asJson)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object Codec extends Codec[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/impl/IronMqClient.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.Http[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.Http.HostConnectionPool[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.client.RequestBuilding._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.{Authorization, GenericHttpCredentials}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{HttpRequest, HttpResponse, Uri}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.unmarshalling.Unmarshal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.util.FastFuture[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Materializer[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0mimport de.heikoseeberger.akkahttpcirce.ErrorAccumulatingCirceSupport._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport io.circe.Json[0m
[0m[[0m[0mdebug[0m] [0m[0mimport io.circe.syntax._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.{Duration, FiniteDuration}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m * An IronMq client based on Akka-http.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * This client provide a subset of the operation you can do by the IronMQ protocol. It is not intended to be used by[0m
[0m[[0m[0mdebug[0m] [0m[0m * the final user but as internal API. Still it could be used to create/list/delete queues if needed.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] final class IronMqClient(settings: IronMqSettings)(implicit actorSystem: ActorSystem,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                   materializer: Materializer) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import Codec._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val http = Http(actorSystem)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val connectionPoolFlow: Flow[(HttpRequest, NotUsed), (Try[HttpResponse], NotUsed), HostConnectionPool] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val endpoint = settings.endpoint[0m
[0m[[0m[0mdebug[0m] [0m[0m    endpoint.scheme match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case "https" =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        http.cachedHostConnectionPoolHttps[NotUsed](endpoint.authority.host.address(), endpoint.authority.port)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case "http" => http.cachedHostConnectionPool[NotUsed](endpoint.authority.host.address(), endpoint.authority.port)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw new IllegalArgumentException(s"Endpoint $endpoint contains an invalid HTTP/HTTPS scheme $other")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val pipeline: Flow[HttpRequest, HttpResponse, _] = Flow[HttpRequest][0m
[0m[[0m[0mdebug[0m] [0m[0m    .map(_.withHeaders(Authorization(GenericHttpCredentials("OAuth", settings.token))))[0m
[0m[[0m[0mdebug[0m] [0m[0m    .map(_ -> NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m    .via(connectionPoolFlow)[0m
[0m[[0m[0mdebug[0m] [0m[0m    .map(_._1)[0m
[0m[[0m[0mdebug[0m] [0m[0m    .mapAsync(1) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(response) if response.status.isSuccess() =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        FastFuture.successful(response)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Success(response) if !response.status.isSuccess() =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        FastFuture.failed(new RuntimeException(response.status.reason()))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Failure(error) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        FastFuture.failed(error)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * List the available queues.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It support pagination by providing the last queue name and number of desired results. It can also filter by queue[0m
[0m[[0m[0mdebug[0m] [0m[0m   * name prefix.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listQueues(prefix: Option[String] = None, from: Option[String] = None, noOfQueues: Int = 50)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[Traversable[String]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def parseQueues(json: Json) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      def extractName(json: Json) = json.hcursor.downField("name").as[Json] match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(r) => r[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Left(_) => Json.Null[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      json.hcursor[0m
[0m[[0m[0mdebug[0m] [0m[0m        .downField("queues")[0m
[0m[[0m[0mdebug[0m] [0m[0m        .withFocus { xsJson =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          xsJson.mapArray { xs =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            xs.map(extractName)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .as[Traversable[String]][0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val query = List(prefix.map("prefix" -> _), from.map("previous" -> _.value))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Some(x) => x[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .foldLeft(Uri.Query("per_page" -> noOfQueues.toString)) { (q, x) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        x +: q[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Get(Uri(s"$queuesPath").withQuery(query))).flatMap(Unmarshal(_).to[Json]).map(parseQueues).collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Right(xs) => xs[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create a new queue, with default parameters, with the given name.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createQueue(name: String)(implicit ec: ExecutionContext): Future[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Put(Uri(s"$queuesPath/${name}"), Json.obj()))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMap(Unmarshal(_).to[Json])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.hcursor.downField("queue").as[Queue])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(queue) => queue.name.value[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete the queue with the given name.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteQueue(name: String)(implicit ec: ExecutionContext): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Delete(Uri(s"$queuesPath/${name}"))).map(_ => Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Produce the given messages to the queue with the given name. Return the ids ot the produced messages.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def pushMessages(queueName: String, messages: PushMessage*)(implicit ec: ExecutionContext): Future[Message.Ids] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = Json.obj([0m
[0m[[0m[0mdebug[0m] [0m[0m      "messages" -> Json.fromValues([0m
[0m[[0m[0mdebug[0m] [0m[0m        messages.map { pm =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Json.obj("body" -> Json.fromString(pm.body), "delay" -> Json.fromLong(pm.delay.toSeconds))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Post(Uri(s"$queuesPath/${queueName}/messages"), payload)).flatMap(Unmarshal(_).to[Message.Ids])[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reserve a number of messages from the given queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * When a message has been reserved, it is not available to other consumer for the time specified by the timeout[0m
[0m[[0m[0mdebug[0m] [0m[0m   * argument.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The name of the queue to reserve from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param noOfMessages The maximum number of messages to reserve (It will return a number of messages up to this number)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param timeout The reservation timeout. After this time the reserved message is put back in the queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param watch The amount of time the consumer will wait for more messages to be reserved.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def reserveMessages([0m
[0m[[0m[0mdebug[0m] [0m[0m      queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      noOfMessages: Int = 1,[0m
[0m[[0m[0mdebug[0m] [0m[0m      timeout: Duration = Duration.Undefined,[0m
[0m[[0m[0mdebug[0m] [0m[0m      watch: Duration = Duration.Undefined[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit ec: ExecutionContext): Future[Iterable[ReservedMessage]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = (if (timeout.isFinite()) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.obj("timeout" -> Json.fromLong(timeout.toSeconds))[0m
[0m[[0m[0mdebug[0m] [0m[0m                   } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.Null[0m
[0m[[0m[0mdebug[0m] [0m[0m                   }) deepMerge (if (watch.isFinite()) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   Json.obj("wait" -> Json.fromLong(watch.toSeconds))[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                                   Json.Null[0m
[0m[[0m[0mdebug[0m] [0m[0m                                 }) deepMerge Json.obj("n" -> Json.fromInt(noOfMessages),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                       "delete" -> Json.fromBoolean(false))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Post(Uri(s"$queuesPath/${queueName}/reservations"), payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMap(Unmarshal(_).to[Json])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { json =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        json.hcursor.downField("messages").as[Iterable[ReservedMessage]][0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(xs) => xs[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Consume a number of messages from the given queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The messages will not be available anymore to any other consumer. They are deleted immediately after being fetched.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName  The name of the queue to consume from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param noOfMessages The maximum number of messages to consume (It will return a number of messages up to this number)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param watch The amount of time the consumer will wait for more messages to be consumed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def pullMessages(queueName: String, noOfMessages: Int = 1, watch: Duration = Duration.Undefined)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[Iterable[Message]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = (if (watch.isFinite()) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.obj("wait" -> Json.fromLong(watch.toSeconds))[0m
[0m[[0m[0mdebug[0m] [0m[0m                   } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.Null[0m
[0m[[0m[0mdebug[0m] [0m[0m                   }) deepMerge Json.obj("n" -> Json.fromInt(noOfMessages), "delete" -> Json.fromBoolean(true))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Post(Uri(s"$queuesPath/${queueName}/reservations"), payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMap(Unmarshal(_).to[Json])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { json =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        json.hcursor.downField("messages").as[Iterable[Message]][0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(xs) => xs[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This will renew a nearly expired reservation. It is used to extend the reservation period.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The name of the queue to renew the reservation from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param reservation The Reservation to be renewed.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param timeout The new reservation timeout.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def touchMessage(queueName: String, reservation: Reservation, timeout: Duration = Duration.Undefined)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[Reservation] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = (if (timeout.isFinite()) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.obj("timeout" -> timeout.toSeconds.asJson)[0m
[0m[[0m[0mdebug[0m] [0m[0m                   } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                     Json.Null[0m
[0m[[0m[0mdebug[0m] [0m[0m                   }) deepMerge Json.obj("reservation_id" -> reservation.reservationId.asJson)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Post(s"$queuesPath/${queueName}/messages/${reservation.messageId}/touch", payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMap(Unmarshal(_).to[Json])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { json =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        for {[0m
[0m[[0m[0mdebug[0m] [0m[0m          reservationId <- json.hcursor.downField("reservation_id").as[Reservation.Id] match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Right(r) => Some(r)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Left(_) => None[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } yield reservation.copy(reservationId = reservationId)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Some(r) => r[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * It will fetch a number of messages without reserving or deleting them. It is mainly ussed to monitor or inspect a[0m
[0m[[0m[0mdebug[0m] [0m[0m   * queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The name of the queue to fetch the messages from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param numberOfMessages The maximum number of the messages to fetch.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def peekMessages(queueName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   numberOfMessages: Int = 1)(implicit ec: ExecutionContext): Future[Iterable[Message]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m      Get(Uri(s"$queuesPath/${queueName}/messages").withQuery(Uri.Query("n" -> numberOfMessages.toString)))[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).flatMap(Unmarshal(_).to[Json])[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { json =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        json.hcursor.downField("messages").as[Iterable[Message]][0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case Right(xs) => xs[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This will delete previously reserved messages.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The queue to delete messages from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param reservations The reservations to be used to delete messages. They should not be already expired.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMessages(queueName: String, reservations: Reservation*)(implicit ec: ExecutionContext): Future[Unit] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = Json.obj("ids" -> Json.fromValues(reservations.map(_.asJson)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Delete(Uri(s"$queuesPath/${queueName}/messages"), payload)).map(_ => Unit)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This will release a previously reserved message.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The queue to relesse messages from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param reservation The reservations to be used to release messages. It should not be already expired.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param delay How much time before the message will be available to other consumers.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def releaseMessage(queueName: String, reservation: Reservation, delay: FiniteDuration = Duration.Zero)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[Unit] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = Json.obj("reservation_id" -> reservation.reservationId.asJson, "delay" -> delay.toSeconds.asJson)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Post(Uri(s"$queuesPath/${queueName}/messages/${reservation.messageId.value}/release"), payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => Unit)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Purge a queue, removing all messages from it.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * WARNING: It will delete ALL messages from a Queue.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param queueName The queue to be purged.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def clearMessages(queueName: String)(implicit ec: ExecutionContext): Future[Unit] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeRequest(Delete(Uri(s"$queuesPath/${queueName}/messages"), Json.obj())).map(_ => Unit)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val queuesPath = s"/3/projects/${settings.projectId}/queues"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def makeRequest(request: HttpRequest): Future[HttpResponse] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.single(request).via(pipeline).runWith(Sink.head)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject IronMqClient {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply()(implicit actorSystem: ActorSystem, materializer: Materializer): IronMqClient =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(actorSystem.settings.config)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(config: Config)(implicit actorSystem: ActorSystem, materializer: Materializer): IronMqClient =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(IronMqSettings(config))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: IronMqSettings)(implicit actorSystem: ActorSystem, materializer: Materializer): IronMqClient =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new IronMqClient(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/impl/IronMqPushStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * It is a very trivial IronMQ push stage. It push the message to IronMq as soon as they are pushed to this Stage.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Because of that it does not guarantee the order of the produced messages and does not apply any backpressure. A more[0m
[0m[[0m[0mdebug[0m] [0m[0m * sophisticated implementation will buffer the messages before pushing them and allow only a certain amount of parallel[0m
[0m[[0m[0mdebug[0m] [0m[0m * requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] class IronMqPushStage(queueName: String, settings: IronMqSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[PushMessage, Future[Message.Ids]]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[PushMessage] = Inlet("IronMqPush.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[Future[Message.Ids]] = Outlet("IronMqPush.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override protected def initialAttributes: Attributes = Attributes.name("IronMqPush")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[PushMessage, Future[Message.Ids]] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with StageLogging {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit def ec: ExecutionContext = materializer.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected val logSource: Class[_] = classOf[IronMqPushStage][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var runningFutures: Int = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var exceptionFromUpstream: Option[Throwable] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var client: IronMqClient = _ // set in preStart[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        super.preStart()[0m
[0m[[0m[0mdebug[0m] [0m[0m        client = IronMqClient(settings)(ActorMaterializerHelper.downcast(materializer).system, materializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        in,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val pushMessage = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            val future = client.pushMessages(queueName, pushMessage)[0m
[0m[[0m[0mdebug[0m] [0m[0m            runningFutures = runningFutures + 1[0m
[0m[[0m[0mdebug[0m] [0m[0m            setKeepGoing(true)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            push(out, future)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            future.onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              futureCompleted.invoke(())[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m            checkForCompletion()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onUpstreamFailure(ex: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            exceptionFromUpstream = Some(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m            checkForCompletion()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m          tryPull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def checkForCompletion() =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (isClosed(in) && runningFutures <= 0) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          exceptionFromUpstream match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None => completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(ex) => failStage(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private val futureCompleted = getAsyncCallback[Unit] { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        runningFutures = runningFutures - 1[0m
[0m[[0m[0mdebug[0m] [0m[0m        checkForCompletion()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/impl/ReservedMessage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ironmq.Message[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API. The message reserved from IronMq.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * This message has been ask to be reserved from IronMq. It contains both the message itself and the reservation id.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param reservationId The reservation id needed to release or delete the message.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param message The fetched message.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] case class ReservedMessage(reservationId: Reservation.Id, message: Message) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val messageId: Message.Id = message.messageId[0m
[0m[[0m[0mdebug[0m] [0m[0m  val messageBody: String = message.body[0m
[0m[[0m[0mdebug[0m] [0m[0m  val reservation: Reservation = Reservation(messageId, reservationId)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Represent a message reservation. It is used when you need to delete or release a reserved message. It is obtained from[0m
[0m[[0m[0mdebug[0m] [0m[0m * a [[ReservedMessage]] by message id and reservation id.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param messageId The previously reserved message Id.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param reservationId The reservation id[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] case class Reservation(messageId: Message.Id, reservationId: Reservation.Id)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ironmq] object Reservation {[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Id(value: String) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String = value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ironmq/src/main/scala/akka/stream/alpakka/ironmq/domain.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ironmq[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.{Duration, FiniteDuration}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.JavaDurationConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class PushMessage(body: String, delay: FiniteDuration = Duration.Zero)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject PushMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(body: String): PushMessage = PushMessage(body)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(body: String, duration: java.time.Duration): PushMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    PushMessage(body, duration.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * The message consumed from IronMq.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param messageId The unique id of the message.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param body The pushed message content.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param noOfReservations It is the count of how many time the message has been reserved (and released or expired) previously[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mcase class Message(messageId: Message.Id, body: String, noOfReservations: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Message {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Id(value: String) extends AnyVal {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String = value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  case class Ids(ids: List[Id])[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
