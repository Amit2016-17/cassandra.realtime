[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/javadsl/FtpApi.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.{FtpFile, RemoteFileSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.impl.{FtpLike, FtpSourceFactory}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.IOResult[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Sink[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Source => ScalaSource}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Sink => ScalaSink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.SSHClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.function._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FunctionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait FtpApi[FtpClient] { _: FtpSourceFactory[FtpClient] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The refined [[RemoteFileSettings]] type.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S <: RemoteFileSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from the remote user `root` directory.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * By default, `anonymous` credentials will be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(host: String): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(host, basePath = "")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * By default, `anonymous` credentials will be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      basePath: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(basePath, defaultSettings(host))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from the remote user `root` directory.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls("", defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      basePath: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(basePath, defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls([0m
[0m[[0m[0mdebug[0m] [0m[0m      basePath: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaSource[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        createBrowserGraph(basePath, connectionSettings, f => true, _emitTraversedDirectories = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param branchSelector a predicate for pruning the tree. Takes a remote folder and return true[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       if you want to enter that remote folder.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Default behaviour is full recursive which is equivalent with calling this function[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       with [[ls(basePath,connectionSettings,f->true)]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Calling [[ls(basePath,connectionSettings,f->false)]] will emit only the files and folder in[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       non-recursive fashion[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(basePath: String, connectionSettings: S, branchSelector: Predicate[FtpFile]): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      createBrowserGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m        basePath,[0m
[0m[[0m[0mdebug[0m] [0m[0m        connectionSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m        asScalaFromPredicate(branchSelector),[0m
[0m[[0m[0mdebug[0m] [0m[0m        _emitTraversedDirectories = false[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param branchSelector a predicate for pruning the tree. Takes a remote folder and return true[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       if you want to enter that remote folder.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Default behaviour is full recursive which is equivalent with calling this function[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       with [[ls(basePath,connectionSettings,f->true)]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Calling [[ls(basePath,connectionSettings,f->false)]] will emit only the files and folder in[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       non-recursive fashion[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param emitTraversedDirectories whether to include entered directories in the stream[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(basePath: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m         connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m         branchSelector: Predicate[FtpFile],[0m
[0m[[0m[0mdebug[0m] [0m[0m         emitTraversedDirectories: Boolean): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      createBrowserGraph(basePath, connectionSettings, asScalaFromPredicate(branchSelector), emitTraversedDirectories)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, CompletionStage[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, defaultSettings(host))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, CompletionStage[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, CompletionStage[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, connectionSettings, DefaultChunkSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of transmitted [[akka.util.ByteString ByteString]] chunks[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = DefaultChunkSize[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, CompletionStage[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, connectionSettings, chunkSize, 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of transmitted [[akka.util.ByteString ByteString]] chunks[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param offset the offset into the remote file at which to start the file transfer[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      offset: Long[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, CompletionStage[IOResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaSource[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph(createIOSource(path, connectionSettings, chunkSize, offset))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Sink Sink]] of [[akka.util.ByteString ByteString]] to some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param append append data if a file already exists, overwrite the file if not[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Sink Sink]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      append: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, CompletionStage[IOResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaSink.fromGraph(createIOSink(path, connectionSettings, append)).mapMaterializedValue(_.toJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Sink Sink]] of [[akka.util.ByteString ByteString]] to some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If a file already exists at the specified target path, it will get overwritten.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Sink Sink]] of [[akka.util.ByteString ByteString]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, CompletionStage[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    toPath(path, connectionSettings, append = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Sink Sink]] of a [[FtpFile]] that moves a file to some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param destinationPath a function that returns path to where the [[FtpFile]] is moved.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Sink Sink]] of [[FtpFile]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def move(destinationPath: Function[FtpFile, String],[0m
[0m[[0m[0mdebug[0m] [0m[0m           connectionSettings: S): Sink[FtpFile, CompletionStage[IOResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FunctionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaSink[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph(createMoveSink(destinationPath.asScala, connectionSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.javadsl.Sink Sink]] of a [[FtpFile]] that removes a file.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Sink Sink]] of [[FtpFile]] that materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(connectionSettings: S): Sink[FtpFile, CompletionStage[IOResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    ScalaSink.fromGraph(createRemoveSink(connectionSettings)).mapMaterializedValue(_.toJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] implicit def ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mclass SftpApi extends FtpApi[SSHClient] with SftpSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Ftp extends FtpApi[FTPClient] with FtpSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Ftps extends FtpApi[FTPSClient] with FtpsSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Sftp extends SftpApi {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: creates a [[akka.stream.alpakka.ftp.javadsl.SftpApi]][0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param customSshClient custom ssh client[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.alpakka.ftp.javadsl.SftpApi]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(customSshClient: SSHClient): SftpApi =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SftpApi {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val sshClient = customSshClient[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/scaladsl/FtpApi.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.IOResult[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.impl.{FtpLike, FtpSourceFactory, FtpSourceParams, FtpsSourceParams, SftpSourceParams}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.{FtpFile, RemoteFileSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.SSHClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait FtpApi[FtpClient] { _: FtpSourceFactory[FtpClient] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The refined [[RemoteFileSettings]] type.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S <: RemoteFileSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from the remote user `root` directory.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * By default, `anonymous` credentials will be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(host: String): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(host, basePath = "")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * By default, `anonymous` credentials will be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(host: String, basePath: String): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(basePath, defaultSettings(host))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from the remote user `root` directory.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(host: String, username: String, password: String): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls("", defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(host: String, username: String, password: String, basePath: String): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(basePath, defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(basePath: String, connectionSettings: S): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ls(basePath, connectionSettings, f => true)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param branchSelector a function for pruning the tree. Takes a remote folder and return true[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       if you want to enter that remote folder.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Default behaviour is fully recursive which is equivalent with calling this function[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       with [ls(basePath,connectionSettings,f=>true)].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Calling [ls(basePath,connectionSettings,f=>false)] will emit only the files and folder in[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       non-recursive fashion[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(basePath: String, connectionSettings: S, branchSelector: FtpFile => Boolean): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      createBrowserGraph(basePath, connectionSettings, branchSelector, _emitTraversedDirectories = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s from a base path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param basePath Base path from which traverse the remote file server[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param branchSelector a function for pruning the tree. Takes a remote folder and return true[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       if you want to enter that remote folder.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Default behaviour is fully recursive which is equivalent with calling this function[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       with [ls(basePath,connectionSettings,f=>true)].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       Calling [ls(basePath,connectionSettings,f=>false)] will emit only the files and folder in[0m
[0m[[0m[0mdebug[0m] [0m[0m   *                       non-recursive fashion[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param emitTraversedDirectories whether to include entered directories in the stream[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[FtpFile]]s[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ls(basePath: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m         connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m         branchSelector: FtpFile => Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m         emitTraversedDirectories: Boolean): Source[FtpFile, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(createBrowserGraph(basePath, connectionSettings, branchSelector, emitTraversedDirectories))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath(host: String, path: String): Source[ByteString, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, defaultSettings(host))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param host FTP, FTPs or SFTP host[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password password[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath(host: String, username: String, password: String, path: String): Source[ByteString, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, defaultSettings(host, Some(username), Some(password)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of transmitted [[akka.util.ByteString ByteString]] chunks[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = DefaultChunkSize[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    fromPath(path, connectionSettings, chunkSize, 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] from some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection setting[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of transmitted [[akka.util.ByteString ByteString]] chunks[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param offset the offset into the remote file at which to start the file transfer[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] of [[akka.util.ByteString ByteString]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def fromPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      offset: Long[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[ByteString, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(createIOSource(path, connectionSettings, chunkSize, offset))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Sink Sink]] of [[akka.util.ByteString ByteString]] to some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param path the file path[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param append append data if a file already exists, overwrite the file if not[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Sink Sink]] of [[akka.util.ByteString ByteString]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def toPath([0m
[0m[[0m[0mdebug[0m] [0m[0m      path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      append: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Sink.fromGraph(createIOSink(path, connectionSettings, append))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Sink Sink]] of a [[FtpFile]] that moves a file to some file path.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param destinationPath a function that returns path to where the [[FtpFile]] is moved.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Sink Sink]] of [[FtpFile]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def move(destinationPath: FtpFile => String, connectionSettings: S): Sink[FtpFile, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Sink.fromGraph(createMoveSink(destinationPath, connectionSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.scaladsl.Sink Sink]] of a [[FtpFile]] that removes a file.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param connectionSettings connection settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Sink Sink]] of [[FtpFile]] that materializes to a [[scala.concurrent.Future Future]] of [[IOResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(connectionSettings: S): Sink[FtpFile, Future[IOResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Sink.fromGraph(createRemoveSink(connectionSettings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] implicit def ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mclass SftpApi extends FtpApi[SSHClient] with SftpSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Ftp extends FtpApi[FTPClient] with FtpSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Ftps extends FtpApi[FTPSClient] with FtpsSourceParams[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Sftp extends SftpApi {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: creates a [[akka.stream.alpakka.ftp.scaladsl.SftpApi]][0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param customSshClient custom ssh client[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.alpakka.ftp.scaladsl.SftpApi]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(customSshClient: SSHClient): SftpApi =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SftpApi {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val sshClient = customSshClient[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpIOGraphStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.impl.Stages.DefaultAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStageWithMaterializedValue, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, IOResult, Inlet, Outlet, Shape, SinkShape, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString.ByteString1C[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.{IOException, InputStream, OutputStream}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpIOGraphStage[FtpClient, S <: RemoteFileSettings, Sh <: Shape][0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[Sh, Future[IOResult]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def name: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def path: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit def ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes.name(name) and IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def shape: Sh[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpIOSourceStage[FtpClient, S <: RemoteFileSettings][0m
[0m[[0m[0mdebug[0m] [0m[0m    extends FtpIOGraphStage[FtpClient, S, SourceShape[ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def chunkSize: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def offset: Long = 0L[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val shape: SourceShape[ByteString] = SourceShape(Outlet[ByteString](s"$name.out"))[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ByteString] = shape.outlets.head.asInstanceOf[Outlet[ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createLogicAndMaterializedValue(inheritedAttributes: Attributes) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matValuePromise = Promise[IOResult]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new FtpGraphStageLogic[ByteString, FtpClient, S](shape, ftpLike, connectionSettings, ftpClient) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var isOpt: Option[InputStream] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var readBytesTotal: Long = 0L[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        out,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              readChunk() match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case Some(bs) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  push(out, bs)[0m
[0m[[0m[0mdebug[0m] [0m[0m                case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  complete(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case NonFatal(e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                failed = true[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                failStage(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      ) // end of handler[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          isOpt.foreach { os =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              os.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m              ftpLike match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case cfo: CommonFtpOperations =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  if (!cfo.completePendingCommand(handler.get.asInstanceOf[cfo.Handler]))[0m
[0m[[0m[0mdebug[0m] [0m[0m                    throw new IOException("File transfer failed.")[0m
[0m[[0m[0mdebug[0m] [0m[0m                case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case e: IOException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                // If we failed, we have to expect the stream might already be dead[0m
[0m[[0m[0mdebug[0m] [0m[0m                // so swallow the IOException[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (!failed) throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m              case NonFatal(e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } finally {[0m
[0m[[0m[0mdebug[0m] [0m[0m          super.postStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def doPreStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        isOpt = ftpLike match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case ro: RetrieveOffset =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Some(ro.retrieveFileInputStream(path, handler.get.asInstanceOf[ro.Handler], offset).get)[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Some(ftpLike.retrieveFileInputStream(path, handler.get).get)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matSuccess(): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createSuccessful(readBytesTotal))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matFailure(t: Throwable): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createFailed(readBytesTotal, t))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      /** BLOCKING I/O READ */[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] def readChunk() = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        def read(arr: Array[Byte]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m          isOpt.flatMap { is =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val readBytes = is.read(arr)[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (readBytes > -1) Some(readBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m            else None[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        val arr = Array.ofDim[Byte](chunkSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m        read(arr).map { readBytes =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          readBytesTotal += readBytes[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (readBytes == chunkSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m            ByteString1C(arr)[0m
[0m[[0m[0mdebug[0m] [0m[0m          else[0m
[0m[[0m[0mdebug[0m] [0m[0m            ByteString1C(arr).take(readBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    } // end of stage logic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, matValuePromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpIOSinkStage[FtpClient, S <: RemoteFileSettings][0m
[0m[[0m[0mdebug[0m] [0m[0m    extends FtpIOGraphStage[FtpClient, S, SinkShape[ByteString]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def append: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val shape: SinkShape[ByteString] = SinkShape(Inlet[ByteString](s"$name.in"))[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ByteString] = shape.inlets.head.asInstanceOf[Inlet[ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createLogicAndMaterializedValue(inheritedAttributes: Attributes) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matValuePromise = Promise[IOResult]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new FtpGraphStageLogic[ByteString, FtpClient, S](shape, ftpLike, connectionSettings, ftpClient) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var osOpt: Option[OutputStream] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var writtenBytesTotal: Long = 0L[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        in,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              write(grab(in))[0m
[0m[[0m[0mdebug[0m] [0m[0m              pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case NonFatal(e) ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m                failed = true[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                failStage(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onUpstreamFailure(exception: Throwable): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            matFailure(exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m            failed = true[0m
[0m[[0m[0mdebug[0m] [0m[0m            super.onUpstreamFailure(exception)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      ) // end of handler[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          osOpt.foreach { os =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            try {[0m
[0m[[0m[0mdebug[0m] [0m[0m              os.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m              ftpLike match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case cfo: CommonFtpOperations =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  if (!cfo.completePendingCommand(handler.get.asInstanceOf[cfo.Handler]))[0m
[0m[[0m[0mdebug[0m] [0m[0m                    throw new IOException("File transfer failed.")[0m
[0m[[0m[0mdebug[0m] [0m[0m                case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case e: IOException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                // If we failed, we have to expect the stream might already be dead[0m
[0m[[0m[0mdebug[0m] [0m[0m                // so swallow the IOException[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (!failed) throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m              case NonFatal(e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m                throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        } finally {[0m
[0m[[0m[0mdebug[0m] [0m[0m          super.postStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def doPreStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        osOpt = Some(ftpLike.storeFileOutputStream(path, handler.get, append).get)[0m
[0m[[0m[0mdebug[0m] [0m[0m        pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matSuccess(): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createSuccessful(writtenBytesTotal))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matFailure(t: Throwable): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createFailed(writtenBytesTotal, t))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      /** BLOCKING I/O WRITE */[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] def write(bytes: ByteString) =[0m
[0m[[0m[0mdebug[0m] [0m[0m        osOpt.foreach { os =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          os.write(bytes.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m          writtenBytesTotal += bytes.size[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    } // end of stage logic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, matValuePromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpMoveSink[FtpClient, S <: RemoteFileSettings][0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SinkShape[FtpFile], Future[IOResult]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m  val destinationPath: FtpFile => String[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[FtpFile] = Inlet("FtpMvSink")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def shape: SinkShape[FtpFile] = SinkShape(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createLogicAndMaterializedValue(inheritedAttributes: Attributes) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matValuePromise = Promise[IOResult]()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new FtpGraphStageLogic[FtpFile, FtpClient, S](shape, ftpLike, connectionSettings, ftpClient) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      {[0m
[0m[[0m[0mdebug[0m] [0m[0m        setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m          in,[0m
[0m[[0m[0mdebug[0m] [0m[0m          new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m            override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m              val sourcePath = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m              ftpLike.move(sourcePath.path, destinationPath(sourcePath), handler.get)[0m
[0m[[0m[0mdebug[0m] [0m[0m              pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def doPreStart(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matSuccess(): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createSuccessful(1))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matFailure(t: Throwable): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createFailed(1, t))[0m
[0m[[0m[0mdebug[0m] [0m[0m    } // end of stage logic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, matValuePromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpRemoveSink[FtpClient, S <: RemoteFileSettings][0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SinkShape[FtpFile], Future[IOResult]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[FtpFile] = Inlet("FtpRmSink")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def shape: SinkShape[FtpFile] = SinkShape(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createLogicAndMaterializedValue(inheritedAttributes: Attributes) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matValuePromise = Promise[IOResult]()[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new FtpGraphStageLogic[Unit, FtpClient, S](shape, ftpLike, connectionSettings, ftpClient) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      {[0m
[0m[[0m[0mdebug[0m] [0m[0m        setHandler(in, new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            ftpLike.remove(grab(in).path, handler.get)[0m
[0m[[0m[0mdebug[0m] [0m[0m            pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        })[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def doPreStart(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matSuccess(): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createSuccessful(1))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def matFailure(t: Throwable): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m        matValuePromise.trySuccess(IOResult.createFailed(1, t))[0m
[0m[[0m[0mdebug[0m] [0m[0m    } // end of stage logic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, matValuePromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpLike.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.SSHClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.{InputStream, OutputStream}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprotected[ftp] trait FtpLike[FtpClient, S <: RemoteFileSettings] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type Handler[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connect(connectionSettings: S)(implicit ftpClient: FtpClient): Try[Handler][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(handler: Handler)(implicit ftpClient: FtpClient): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(basePath: String, handler: Handler): immutable.Seq[FtpFile][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(handler: Handler): immutable.Seq[FtpFile][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler): Try[InputStream][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def storeFileOutputStream(name: String, handler: Handler, append: Boolean): Try[OutputStream][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def move(fromPath: String, destinationPath: String, handler: Handler): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(path: String, handler: Handler): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprotected[ftp] trait RetrieveOffset { _: FtpLike[_, _] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler, offset: Long): Try[InputStream][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mobject FtpLike {[0m
[0m[[0m[0mdebug[0m] [0m[0m  // type class instances[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val ftpLikeInstance = new FtpLike[FTPClient, FtpSettings] with RetrieveOffset with FtpOperations[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val ftpsLikeInstance = new FtpLike[FTPSClient, FtpsSettings] with RetrieveOffset with FtpsOperations[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val sFtpLikeInstance = new FtpLike[SSHClient, SftpSettings] with RetrieveOffset with SftpOperations[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpOperations.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTP, FTPClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpOperations extends CommonFtpOperations { _: FtpLike[FTPClient, FtpSettings] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connect(connectionSettings: FtpSettings)(implicit ftpClient: FTPClient): Try[Handler] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient.connect(connectionSettings.host, connectionSettings.port)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.configureConnection(ftpClient)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient.login([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings.credentials.username,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings.credentials.password[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.binary) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.setFileType(FTP.BINARY_FILE_TYPE)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.passiveMode) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.enterLocalPassiveMode()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(handler: Handler)(implicit ftpClient: FTPClient): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (ftpClient.isConnected) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.logout()[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.disconnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/CommonFtpOperations.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.{IOException, InputStream, OutputStream}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.Paths[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.attribute.PosixFilePermission[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.TimeZone[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.FtpFile[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPFile}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait CommonFtpOperations {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type Handler = FTPClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(basePath: String, handler: Handler): immutable.Seq[FtpFile] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val path = if (!basePath.isEmpty && basePath.head != '/') s"/$basePath" else if (basePath == "/") "" else basePath[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler[0m
[0m[[0m[0mdebug[0m] [0m[0m      .listFiles(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case file: FTPFile if file.getName != "." && file.getName != ".." =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          val calendar = file.getTimestamp[0m
[0m[[0m[0mdebug[0m] [0m[0m          calendar.setTimeZone(TimeZone.getTimeZone("UTC"))[0m
[0m[[0m[0mdebug[0m] [0m[0m          FtpFile([0m
[0m[[0m[0mdebug[0m] [0m[0m            file.getName,[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (java.io.File.separatorChar == '\\')[0m
[0m[[0m[0mdebug[0m] [0m[0m              Paths.get(s"$path/${file.getName}").normalize.toString.replace('\\', '/')[0m
[0m[[0m[0mdebug[0m] [0m[0m            else[0m
[0m[[0m[0mdebug[0m] [0m[0m              Paths.get(s"$path/${file.getName}").normalize.toString,[0m
[0m[[0m[0mdebug[0m] [0m[0m            file.isDirectory,[0m
[0m[[0m[0mdebug[0m] [0m[0m            file.getSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m            calendar.getTimeInMillis,[0m
[0m[[0m[0mdebug[0m] [0m[0m            getPosixFilePermissions(file)[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toVector[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def getPosixFilePermissions(file: FTPFile) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Map([0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OWNER_READ → file.hasPermission(FTPFile.USER_ACCESS, FTPFile.READ_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OWNER_WRITE → file.hasPermission(FTPFile.USER_ACCESS, FTPFile.WRITE_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OWNER_EXECUTE → file.hasPermission(FTPFile.USER_ACCESS, FTPFile.EXECUTE_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.GROUP_READ → file.hasPermission(FTPFile.GROUP_ACCESS, FTPFile.READ_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.GROUP_WRITE → file.hasPermission(FTPFile.GROUP_ACCESS, FTPFile.WRITE_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.GROUP_EXECUTE → file.hasPermission(FTPFile.GROUP_ACCESS, FTPFile.EXECUTE_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OTHERS_READ → file.hasPermission(FTPFile.WORLD_ACCESS, FTPFile.READ_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OTHERS_WRITE → file.hasPermission(FTPFile.WORLD_ACCESS, FTPFile.WRITE_PERMISSION),[0m
[0m[[0m[0mdebug[0m] [0m[0m      PosixFilePermission.OTHERS_EXECUTE → file.hasPermission(FTPFile.WORLD_ACCESS, FTPFile.EXECUTE_PERMISSION)[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (perm, true) ⇒ perm[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.toSet[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(handler: Handler): immutable.Seq[FtpFile] = listFiles("", handler)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler): Try[InputStream] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    retrieveFileInputStream(name, handler, 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler, offset: Long): Try[InputStream] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.setRestartOffset(offset)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val is = handler.retrieveFileStream(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (is != null) is else throw new IOException(s"$name: No such file or directory")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def storeFileOutputStream(name: String, handler: Handler, append: Boolean): Try[OutputStream] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val os = if (append) handler.appendFileStream(name) else handler.storeFileStream(name)[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (os != null) os else throw new IOException(s"Could not write to $name")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def move(fromPath: String, destinationPath: String, handler: Handler): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.rename(fromPath, destinationPath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(path: String, handler: Handler): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.deleteFile(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def completePendingCommand(handler: Handler): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.completePendingCommand()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpsOperations.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.FtpsSettings[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTP, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpsOperations extends CommonFtpOperations { _: FtpLike[FTPSClient, FtpsSettings] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connect(connectionSettings: FtpsSettings)(implicit ftpClient: FTPSClient): Try[Handler] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient.connect(connectionSettings.host, connectionSettings.port)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    connectionSettings.configureConnection(ftpClient)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient.login([0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings.credentials.username,[0m
[0m[[0m[0mdebug[0m] [0m[0m      connectionSettings.credentials.password[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.binary) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.setFileType(FTP.BINARY_FILE_TYPE)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (connectionSettings.passiveMode) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.enterLocalPassiveMode()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(handler: Handler)(implicit ftpClient: FTPSClient): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (ftpClient.isConnected) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.logout()[0m
[0m[[0m[0mdebug[0m] [0m[0m      ftpClient.disconnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpSourceFactory.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp.FtpCredentials[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.ftp._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.SSHClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpSourceFactory[FtpClient] { self =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S <: RemoteFileSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] final val DefaultChunkSize = 8192[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def ftpBrowserSourceName: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def ftpIOSourceName: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def ftpIOSinkName: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createBrowserGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      _basePath: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _branchSelector: FtpFile => Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]): FtpBrowserGraphStage[FtpClient, S] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    createBrowserGraph(_basePath, _connectionSettings, _branchSelector, _emitTraversedDirectories = false)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createBrowserGraph([0m
[0m[[0m[0mdebug[0m] [0m[0m      _basePath: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _branchSelector: FtpFile => Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _emitTraversedDirectories: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]): FtpBrowserGraphStage[FtpClient, S] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new FtpBrowserGraphStage[FtpClient, S] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val name: String = ftpBrowserSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m      val basePath: String = _basePath[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionSettings: S = _connectionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpClient: () => FtpClient = self.ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpLike: FtpLike[FtpClient, S] = _ftpLike[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val branchSelector: (FtpFile) => Boolean = _branchSelector[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val emitTraversedDirectories: Boolean = _emitTraversedDirectories[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createIOSource([0m
[0m[[0m[0mdebug[0m] [0m[0m      _path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _chunkSize: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]): FtpIOSourceStage[FtpClient, S] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    createIOSource(_path, _connectionSettings, _chunkSize, 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createIOSource([0m
[0m[[0m[0mdebug[0m] [0m[0m      _path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _chunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _offset: Long[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]): FtpIOSourceStage[FtpClient, S] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new FtpIOSourceStage[FtpClient, S] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val name: String = ftpIOSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m      val path: String = _path[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionSettings: S = _connectionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpClient: () => FtpClient = self.ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpLike: FtpLike[FtpClient, S] = _ftpLike[0m
[0m[[0m[0mdebug[0m] [0m[0m      val chunkSize: Int = _chunkSize[0m
[0m[[0m[0mdebug[0m] [0m[0m      override val offset: Long = _offset[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createIOSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      _path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _append: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]): FtpIOSinkStage[FtpClient, S] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new FtpIOSinkStage[FtpClient, S] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      lazy val name: String = ftpIOSinkName[0m
[0m[[0m[0mdebug[0m] [0m[0m      val path: String = _path[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionSettings: S = _connectionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpClient: () => FtpClient = self.ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpLike: FtpLike[FtpClient, S] = _ftpLike[0m
[0m[[0m[0mdebug[0m] [0m[0m      val append: Boolean = _append[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createMoveSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      _destinationPath: FtpFile => String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new FtpMoveSink[FtpClient, S] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionSettings: S = _connectionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpClient: () => FtpClient = self.ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpLike: FtpLike[FtpClient, S] = _ftpLike[0m
[0m[[0m[0mdebug[0m] [0m[0m      val destinationPath: FtpFile => String = _destinationPath[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def createRemoveSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      _connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit _ftpLike: FtpLike[FtpClient, S]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new FtpRemoveSink[FtpClient, S] {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val connectionSettings: S = _connectionSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpClient: () => FtpClient = self.ftpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m      val ftpLike: FtpLike[FtpClient, S] = _ftpLike[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def defaultSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      hostname: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: Option[String] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpSource extends FtpSourceFactory[FTPClient] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpBrowserSourceName = "FtpBrowserSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpIOSourceName = "FtpIOSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpIOSinkName = "FtpIOSink"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpClient: () => FTPClient = () => new FTPClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpBrowserSourceName: String = FtpBrowserSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSourceName: String = FtpIOSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSinkName: String = FtpIOSinkName[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpsSource extends FtpSourceFactory[FTPSClient] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpsBrowserSourceName = "FtpsBrowserSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpsIOSourceName = "FtpsIOSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val FtpsIOSinkName = "FtpsIOSink"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpClient: () => FTPSClient = () => new FTPSClient[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpBrowserSourceName: String = FtpsBrowserSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSourceName: String = FtpsIOSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSinkName: String = FtpsIOSinkName[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait SftpSource extends FtpSourceFactory[SSHClient] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val sFtpBrowserSourceName = "sFtpBrowserSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val sFtpIOSourceName = "sFtpIOSource"[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected final val sFtpIOSinkName = "sFtpIOSink"[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sshClient(): SSHClient = new SSHClient()[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpClient: () => SSHClient = () => sshClient()[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpBrowserSourceName: String = sFtpBrowserSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSourceName: String = sFtpIOSourceName[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected val ftpIOSinkName: String = sFtpIOSinkName[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def defaultSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      hostname: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    FtpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      InetAddress.getByName(hostname)[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).withCredentials([0m
[0m[[0m[0mdebug[0m] [0m[0m      if (username.isDefined)[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.create(username.get, password.getOrElse(""))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.anonymous[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpsDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def defaultSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      hostname: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpsSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    FtpsSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      InetAddress.getByName(hostname)[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).withCredentials([0m
[0m[[0m[0mdebug[0m] [0m[0m      if (username.isDefined)[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.create(username.get, password.getOrElse(""))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.anonymous[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait SftpDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected def defaultSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      hostname: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      username: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      password: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SftpSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    SftpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m      InetAddress.getByName(hostname)[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).withCredentials([0m
[0m[[0m[0mdebug[0m] [0m[0m      if (username.isDefined)[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.create(username.get, password.getOrElse(""))[0m
[0m[[0m[0mdebug[0m] [0m[0m      else[0m
[0m[[0m[0mdebug[0m] [0m[0m        FtpCredentials.anonymous[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpSourceParams extends FtpSource with FtpDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S = FtpSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] val ftpLike: FtpLike[FTPClient, S] = FtpLike.ftpLikeInstance[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpsSourceParams extends FtpsSource with FtpsDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S = FtpsSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] val ftpLike: FtpLike[FTPSClient, S] = FtpLike.ftpsLikeInstance[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait SftpSourceParams extends SftpSource with SftpDefaultSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type S = SftpSettings[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] val ftpLike: FtpLike[SSHClient, S] = FtpLike.sFtpLikeInstance[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/SftpOperations.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.{File, IOException, InputStream, OutputStream}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.attribute.PosixFilePermission[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.SSHClient[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.sftp.{OpenMode, RemoteResourceInfo, SFTPClient}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.transport.verification.PromiscuousVerifier[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.userauth.keyprovider.OpenSSHKeyFile[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.userauth.password.PasswordUtils[0m
[0m[[0m[0mdebug[0m] [0m[0mimport net.schmizz.sshj.xfer.FilePermission[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait SftpOperations { _: FtpLike[SSHClient, SftpSettings] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  type Handler = SFTPClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connect(connectionSettings: SftpSettings)(implicit ssh: SSHClient): Try[Handler] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import connectionSettings._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (!strictHostKeyChecking)[0m
[0m[[0m[0mdebug[0m] [0m[0m      ssh.addHostKeyVerifier(new PromiscuousVerifier)[0m
[0m[[0m[0mdebug[0m] [0m[0m    else[0m
[0m[[0m[0mdebug[0m] [0m[0m      knownHosts.foreach(path => ssh.loadKnownHosts(new File(path)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ssh.connect(host.getHostAddress, port)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (credentials.password != "" && sftpIdentity.isEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m      ssh.authPassword(credentials.username, credentials.password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    sftpIdentity.foreach(setIdentity(_, credentials.username))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    ssh.newSFTPClient()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def disconnect(handler: Handler)(implicit ssh: SSHClient): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (ssh.isConnected) ssh.disconnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(basePath: String, handler: Handler): immutable.Seq[FtpFile] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val path = if (!basePath.isEmpty && basePath.head != '/') s"/$basePath" else basePath[0m
[0m[[0m[0mdebug[0m] [0m[0m    val entries = handler.ls(path).asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m    entries.map { file =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      FtpFile([0m
[0m[[0m[0mdebug[0m] [0m[0m        file.getName,[0m
[0m[[0m[0mdebug[0m] [0m[0m        file.getPath,[0m
[0m[[0m[0mdebug[0m] [0m[0m        file.isDirectory,[0m
[0m[[0m[0mdebug[0m] [0m[0m        file.getAttributes.getSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        file.getAttributes.getMtime * 1000L,[0m
[0m[[0m[0mdebug[0m] [0m[0m        getPosixFilePermissions(file)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.toVector[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def getPosixFilePermissions(file: RemoteResourceInfo) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import PosixFilePermission._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    import FilePermission._[0m
[0m[[0m[0mdebug[0m] [0m[0m    file.getAttributes.getPermissions.asScala.collect {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case USR_R => OWNER_READ[0m
[0m[[0m[0mdebug[0m] [0m[0m      case USR_W => OWNER_WRITE[0m
[0m[[0m[0mdebug[0m] [0m[0m      case USR_X => OWNER_EXECUTE[0m
[0m[[0m[0mdebug[0m] [0m[0m      case GRP_R => GROUP_READ[0m
[0m[[0m[0mdebug[0m] [0m[0m      case GRP_W => GROUP_WRITE[0m
[0m[[0m[0mdebug[0m] [0m[0m      case GRP_X => GROUP_EXECUTE[0m
[0m[[0m[0mdebug[0m] [0m[0m      case OTH_R => OTHERS_READ[0m
[0m[[0m[0mdebug[0m] [0m[0m      case OTH_W => OTHERS_WRITE[0m
[0m[[0m[0mdebug[0m] [0m[0m      case OTH_X => OTHERS_EXECUTE[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.toSet[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listFiles(handler: Handler): immutable.Seq[FtpFile] = listFiles(".", handler)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler): Try[InputStream] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    retrieveFileInputStream(name, handler, 0L)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def retrieveFileInputStream(name: String, handler: Handler, offset: Long): Try[InputStream] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val remoteFile = handler.open(name, java.util.EnumSet.of(OpenMode.READ))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val is = new remoteFile.RemoteFileInputStream(offset) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def close(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          super.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } finally {[0m
[0m[[0m[0mdebug[0m] [0m[0m          remoteFile.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    Option(is).getOrElse {[0m
[0m[[0m[0mdebug[0m] [0m[0m      remoteFile.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m      throw new IOException(s"$name: No such file or directory")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def storeFileOutputStream(name: String, handler: Handler, append: Boolean): Try[OutputStream] = Try {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import OpenMode._[0m
[0m[[0m[0mdebug[0m] [0m[0m    val openModes =[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (append) java.util.EnumSet.of(WRITE, CREAT, APPEND) else java.util.EnumSet.of(WRITE, CREAT, TRUNC)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val remoteFile = handler.open(name, openModes)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val os = new remoteFile.RemoteFileOutputStream() {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def close(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        try {[0m
[0m[[0m[0mdebug[0m] [0m[0m          remoteFile.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m        } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case e: IOException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        super.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    Option(os).getOrElse {[0m
[0m[[0m[0mdebug[0m] [0m[0m      remoteFile.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m      throw new IOException(s"Could not write to $name")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def setIdentity(identity: SftpIdentity, username: String)(implicit ssh: SSHClient) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def bats(array: Array[Byte]): String = new String(array, "UTF-8")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def initKey(f: OpenSSHKeyFile => Unit) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val key = new OpenSSHKeyFile[0m
[0m[[0m[0mdebug[0m] [0m[0m      f(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m      ssh.authPublickey(username, key)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val passphrase =[0m
[0m[[0m[0mdebug[0m] [0m[0m      identity.privateKeyFilePassphrase.map(pass => PasswordUtils.createOneOff(bats(pass).toCharArray)).orNull[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    identity match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case id: RawKeySftpIdentity =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        initKey(_.init(bats(id.privateKey), id.publicKey.map(bats).orNull, passphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case id: KeyFileSftpIdentity =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        initKey(_.init(new File(id.privateKey), passphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def move(fromPath: String, destinationPath: String, handler: Handler): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.rename(fromPath, destinationPath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def remove(path: String, handler: Handler): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.rm(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpGraphStageLogic.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.IOException[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Shape[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.GraphStageLogic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.control.NonFatal[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] abstract class FtpGraphStageLogic[T, FtpClient, S <: RemoteFileSettings]([0m
[0m[[0m[0mdebug[0m] [0m[0m    val shape: Shape,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ftpLike: FtpLike[FtpClient, S],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val connectionSettings: S,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] implicit val client = ftpClient()[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] var handler: Option[ftpLike.Handler] = Option.empty[ftpLike.Handler][0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] var failed = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.preStart()[0m
[0m[[0m[0mdebug[0m] [0m[0m    try {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val tryConnect = ftpLike.connect(connectionSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (tryConnect.isSuccess) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        handler = tryConnect.toOption[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else[0m
[0m[[0m[0mdebug[0m] [0m[0m        tryConnect.failed.foreach { case NonFatal(t) => throw t }[0m
[0m[[0m[0mdebug[0m] [0m[0m      doPreStart()[0m
[0m[[0m[0mdebug[0m] [0m[0m    } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NonFatal(t) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        matFailure(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m        failStage(t)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def postStop(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    try {[0m
[0m[[0m[0mdebug[0m] [0m[0m      disconnect()[0m
[0m[[0m[0mdebug[0m] [0m[0m    } catch {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case e: IOException =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        // If we're failing, we might not be able to cleanly shut down the connection.[0m
[0m[[0m[0mdebug[0m] [0m[0m        // So swallow any IO exceptions[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!failed) throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NonFatal(e) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        matFailure(e)[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw e[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    matSuccess()[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.postStop()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def doPreStart(): Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def disconnect(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    handler.foreach(ftpLike.disconnect)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def matSuccess(): Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  protected[this] def matFailure(t: Throwable): Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/impl/FtpBrowserGraphStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Outlet, SourceShape}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.impl.Stages.DefaultAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate[ftp] trait FtpBrowserGraphStage[FtpClient, S <: RemoteFileSettings] extends GraphStage[SourceShape[FtpFile]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def name: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def basePath: String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def connectionSettings: S[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def ftpClient: () => FtpClient[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ftpLike: FtpLike[FtpClient, S][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val shape: SourceShape[FtpFile] = SourceShape(Outlet[FtpFile](s"$name.out"))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out = shape.outlets.head.asInstanceOf[Outlet[FtpFile]][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val branchSelector: FtpFile => Boolean = (f) => true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def emitTraversedDirectories: Boolean = false[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes.name(name) and IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createLogic(inheritedAttributes: Attributes) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new FtpGraphStageLogic[FtpFile, FtpClient, S](shape, ftpLike, connectionSettings, ftpClient) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var buffer: Seq[FtpFile] = Seq.empty[FtpFile][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] var traversed: Seq[FtpFile] = Seq.empty[FtpFile][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m        out,[0m
[0m[[0m[0mdebug[0m] [0m[0m        new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m          def onPull(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            fillBuffer()[0m
[0m[[0m[0mdebug[0m] [0m[0m            traversed match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case head +: tail =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                traversed = tail[0m
[0m[[0m[0mdebug[0m] [0m[0m                push(out, head)[0m
[0m[[0m[0mdebug[0m] [0m[0m              case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                buffer match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case head +: tail =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    buffer = tail[0m
[0m[[0m[0mdebug[0m] [0m[0m                    push(out, head)[0m
[0m[[0m[0mdebug[0m] [0m[0m                  case _ => complete(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          } // end of onPull[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          override def onDownstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m            matSuccess()[0m
[0m[[0m[0mdebug[0m] [0m[0m            super.onDownstreamFinish()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      ) // end of handler[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      protected[this] def doPreStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        buffer = initBuffer(basePath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected[this] def matSuccess() = true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override protected[this] def matFailure(t: Throwable) = true[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] def initBuffer(basePath: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m        getFilesFromPath(basePath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      @scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] def fillBuffer(): Unit = buffer match {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case head +: tail if head.isDirectory && branchSelector(head) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          buffer = getFilesFromPath(head.path) ++ tail[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (emitTraversedDirectories) traversed = traversed :+ head[0m
[0m[[0m[0mdebug[0m] [0m[0m          fillBuffer()[0m
[0m[[0m[0mdebug[0m] [0m[0m        case _ => // do nothing[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private[this] def getFilesFromPath(basePath: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (basePath.isEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m          ftpLike.listFiles(handler.get)[0m
[0m[[0m[0mdebug[0m] [0m[0m        else[0m
[0m[[0m[0mdebug[0m] [0m[0m          ftpLike.listFiles(basePath, handler.get)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    } // end of stage logic[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    logic[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/ftp/src/main/scala/akka/stream/alpakka/ftp/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.ftp[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.attribute.PosixFilePermission[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.apache.commons.net.ftp.{FTPClient, FTPSClient}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTP remote file descriptor.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param name file name[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param path remote file path as viewed by the logged user.[0m
[0m[[0m[0mdebug[0m] [0m[0m *             It should always start by '/'[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param isDirectory the descriptor is a directory[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param size the file size in bytes[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param lastModified the timestamp of the file last modification[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param permissions the permissions of the file[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal case class FtpFile([0m
[0m[[0m[0mdebug[0m] [0m[0m    name: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    path: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    isDirectory: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    size: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m    lastModified: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m    permissions: Set[PosixFilePermission][0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isFile: Boolean = !this.isDirectory[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Common remote file settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class RemoteFileSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def host: InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  def port: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m  def credentials: FtpCredentials[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Common settings for FTP and FTPs.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class FtpFileSettings extends RemoteFileSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def binary: Boolean // BINARY or ASCII (default)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def passiveMode: Boolean[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTP settings[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param host host[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param port port[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param credentials credentials (username and password)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param binary specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param passiveMode specifies whether to use passive mode connections. Default is active mode (false)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param configureConnection A function which will be called after connecting to the server. Use this for[0m
[0m[[0m[0mdebug[0m] [0m[0m *                            any custom configuration required by the server you are connecting to.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class FtpSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val host: java.net.InetAddress,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val port: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: FtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val binary: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val passiveMode: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val configureConnection: FTPClient => Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends FtpFileSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHost(value: java.net.InetAddress): FtpSettings = copy(host = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPort(value: Int): FtpSettings = copy(port = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: FtpCredentials): FtpSettings = copy(credentials = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBinary(value: Boolean): FtpSettings = if (binary == value) this else copy(binary = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassiveMode(value: Boolean): FtpSettings = if (passiveMode == value) this else copy(passiveMode = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Sets the configure connection callback.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConfigureConnection(value: FTPClient => Unit): FtpSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(configureConnection = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Sets the configure connection callback.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConfigureConnectionConsumer(configureConnection: java.util.function.Consumer[FTPClient]): FtpSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(configureConnection = configureConnection.accept)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m      port: Int = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: FtpCredentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binary: Boolean = binary,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passiveMode: Boolean = passiveMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m      configureConnection: FTPClient => Unit = configureConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpSettings = new FtpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    port = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    binary = binary,[0m
[0m[[0m[0mdebug[0m] [0m[0m    passiveMode = passiveMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m    configureConnection = configureConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""FtpSettings(host=$host,port=$port,credentials=$credentials,binary=$binary,passiveMode=$passiveMode,configureConnection=$configureConnection)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTP settings factory[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject FtpSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Default FTP port (21) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final val DefaultFtpPort = 21[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpSettings = new FtpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    port = DefaultFtpPort,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = FtpCredentials.AnonFtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    binary = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    passiveMode = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    configureConnection = _ => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpSettings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    host[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTPs settings[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param host host[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param port port[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param credentials credentials (username and password)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param binary specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param passiveMode specifies whether to use passive mode connections. Default is active mode (false)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param configureConnection A function which will be called after connecting to the server. Use this for[0m
[0m[[0m[0mdebug[0m] [0m[0m *                            any custom configuration required by the server you are connecting to.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class FtpsSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val host: java.net.InetAddress,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val port: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: FtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val binary: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val passiveMode: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val configureConnection: FTPSClient => Unit[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends FtpFileSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHost(value: java.net.InetAddress): FtpsSettings = copy(host = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPort(value: Int): FtpsSettings = copy(port = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: FtpCredentials): FtpsSettings = copy(credentials = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBinary(value: Boolean): FtpsSettings = if (binary == value) this else copy(binary = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassiveMode(value: Boolean): FtpsSettings = if (passiveMode == value) this else copy(passiveMode = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Sets the configure connection callback.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConfigureConnection(value: FTPSClient => Unit): FtpsSettings = copy(configureConnection = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API:[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Sets the configure connection callback.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withConfigureConnectionConsumer(configureConnection: java.util.function.Consumer[FTPSClient]): FtpsSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(configureConnection = configureConnection.accept)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m      port: Int = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: FtpCredentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      binary: Boolean = binary,[0m
[0m[[0m[0mdebug[0m] [0m[0m      passiveMode: Boolean = passiveMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m      configureConnection: FTPSClient => Unit = configureConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpsSettings = new FtpsSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    port = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    binary = binary,[0m
[0m[[0m[0mdebug[0m] [0m[0m    passiveMode = passiveMode,[0m
[0m[[0m[0mdebug[0m] [0m[0m    configureConnection = configureConnection[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""FtpsSettings(host=$host,port=$port,credentials=$credentials,binary=$binary,passiveMode=$passiveMode,configureConnection=$configureConnection)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTPs settings factory[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject FtpsSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Default FTPs port (2222) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final val DefaultFtpsPort = 2222[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpsSettings = new FtpsSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    DefaultFtpsPort,[0m
[0m[[0m[0mdebug[0m] [0m[0m    FtpCredentials.AnonFtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    binary = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    passiveMode = false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    configureConnection = _ => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): FtpsSettings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    host[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP settings[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param host host[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param port port[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param credentials credentials (username and password)[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param strictHostKeyChecking sets whether to use strict host key checking.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param knownHosts known hosts file to be used when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param sftpIdentity private/public key config to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class SftpSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val host: java.net.InetAddress,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val port: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentials: FtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val strictHostKeyChecking: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val knownHosts: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sftpIdentity: Option[SftpIdentity][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends RemoteFileSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHost(value: java.net.InetAddress): SftpSettings = copy(host = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPort(value: Int): SftpSettings = copy(port = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(value: FtpCredentials): SftpSettings = copy(credentials = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withStrictHostKeyChecking(value: Boolean): SftpSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (strictHostKeyChecking == value) this else copy(strictHostKeyChecking = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKnownHosts(value: String): SftpSettings = copy(knownHosts = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSftpIdentity(value: SftpIdentity): SftpSettings = copy(sftpIdentity = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m      port: Int = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentials: FtpCredentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m      strictHostKeyChecking: Boolean = strictHostKeyChecking,[0m
[0m[[0m[0mdebug[0m] [0m[0m      knownHosts: Option[String] = knownHosts,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sftpIdentity: Option[SftpIdentity] = sftpIdentity[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SftpSettings = new SftpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host = host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    port = port,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentials = credentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    strictHostKeyChecking = strictHostKeyChecking,[0m
[0m[[0m[0mdebug[0m] [0m[0m    knownHosts = knownHosts,[0m
[0m[[0m[0mdebug[0m] [0m[0m    sftpIdentity = sftpIdentity[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""SftpSettings(host=$host,port=$port,credentials=$credentials,strictHostKeyChecking=$strictHostKeyChecking,knownHosts=$knownHosts,sftpIdentity=$sftpIdentity)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP settings factory[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SftpSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Default SFTP port (22) */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final val DefaultSftpPort = 22[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SftpSettings = new SftpSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m    host,[0m
[0m[[0m[0mdebug[0m] [0m[0m    DefaultSftpPort,[0m
[0m[[0m[0mdebug[0m] [0m[0m    FtpCredentials.AnonFtpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m    strictHostKeyChecking = true,[0m
[0m[[0m[0mdebug[0m] [0m[0m    knownHosts = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    sftpIdentity = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      host: java.net.InetAddress[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): SftpSettings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    host[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTP credentials[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class FtpCredentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def username: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  def password: String[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * FTP credentials factory[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject FtpCredentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m  final val Anonymous = "anonymous"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val anonymous: FtpCredentials = AnonFtpCredentials[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Anonymous credentials[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object AnonFtpCredentials extends FtpCredentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val username: String = Anonymous[0m
[0m[[0m[0mdebug[0m] [0m[0m    val password: String = Anonymous[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString = "FtpCredentials(anonymous)"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Non-anonymous credentials[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param username the username[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param password the password[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  final class NonAnonFtpCredentials @InternalApi private[FtpCredentials] (val username: String, val password: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m      extends FtpCredentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString = s"FtpCredentials(username=$username,password.nonEmpty=${password.nonEmpty})"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Create username/password credentials. */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(username: String, password: String): FtpCredentials =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new NonAnonFtpCredentials(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP identity details[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class SftpIdentity {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type KeyType[0m
[0m[[0m[0mdebug[0m] [0m[0m  val privateKey: KeyType[0m
[0m[[0m[0mdebug[0m] [0m[0m  val privateKeyFilePassphrase: Option[Array[Byte]][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP identity factory[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SftpIdentity {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * SFTP identity for authenticating using private/public key value[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKey private key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createRawSftpIdentity(privateKey: Array[Byte]): RawKeySftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RawKeySftpIdentity(privateKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * SFTP identity for authenticating using private/public key value[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKey private key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKeyFilePassphrase password to use to decrypt private key[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createRawSftpIdentity(privateKey: Array[Byte], privateKeyFilePassphrase: Array[Byte]): RawKeySftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RawKeySftpIdentity(privateKey, Some(privateKeyFilePassphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * SFTP identity for authenticating using private/public key value[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKey private key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKeyFilePassphrase password to use to decrypt private key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param publicKey public key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createRawSftpIdentity([0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKey: Array[Byte],[0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKeyFilePassphrase: Array[Byte],[0m
[0m[[0m[0mdebug[0m] [0m[0m      publicKey: Array[Byte][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): RawKeySftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new RawKeySftpIdentity(privateKey, Some(privateKeyFilePassphrase), Some(publicKey))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create SFTP identity for authenticating using private/public key file[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKey private key file to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createFileSftpIdentity(privateKey: String): KeyFileSftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new KeyFileSftpIdentity(privateKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create SFTP identity for authenticating using private/public key file[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKey private key file to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param privateKeyFilePassphrase password to use to decrypt private key file[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createFileSftpIdentity(privateKey: String, privateKeyFilePassphrase: Array[Byte]): KeyFileSftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new KeyFileSftpIdentity(privateKey, Some(privateKeyFilePassphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP identity for authenticating using private/public key value[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param privateKey private key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param privateKeyFilePassphrase password to use to decrypt private key[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param publicKey public key value to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class RawKeySftpIdentity @InternalApi private[ftp] ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val privateKey: Array[Byte],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val privateKeyFilePassphrase: Option[Array[Byte]] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val publicKey: Option[Array[Byte]] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends SftpIdentity {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type KeyType = Array[Byte][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPrivateKey(value: KeyType): RawKeySftpIdentity = copy(privateKey = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPrivateKeyFilePassphrase(privateKeyFilePassphrase: Array[Byte]): RawKeySftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(privateKeyFilePassphrase = Some(privateKeyFilePassphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPublicKey(publicKey: KeyType): RawKeySftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(publicKey = Some(publicKey))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKey: Array[Byte] = privateKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKeyFilePassphrase: Option[Array[Byte]] = privateKeyFilePassphrase,[0m
[0m[[0m[0mdebug[0m] [0m[0m      publicKey: Option[Array[Byte]] = publicKey[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): RawKeySftpIdentity = new RawKeySftpIdentity([0m
[0m[[0m[0mdebug[0m] [0m[0m    privateKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m    privateKeyFilePassphrase,[0m
[0m[[0m[0mdebug[0m] [0m[0m    publicKey[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "RawKeySftpIdentity(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"privateKey(length)=${privateKey.length}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"privateKeyFilePassphrase.isDefined=${privateKeyFilePassphrase.isDefined}," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"publicKey=${publicKey.isDefined})"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * SFTP identity for authenticating using private/public key file[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param privateKey private key file to use when connecting[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param privateKeyFilePassphrase password to use to decrypt private key file[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class KeyFileSftpIdentity @InternalApi private[ftp] ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val privateKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val privateKeyFilePassphrase: Option[Array[Byte]] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m) extends SftpIdentity {[0m
[0m[[0m[0mdebug[0m] [0m[0m  type KeyType = String[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPrivateKey(value: String): KeyFileSftpIdentity = copy(privateKey = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPrivateKeyFilePassphrase(privateKeyFilePassphrase: Array[Byte]): KeyFileSftpIdentity =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(privateKeyFilePassphrase = Some(privateKeyFilePassphrase))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKey: String = privateKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m      privateKeyFilePassphrase: Option[Array[Byte]] = privateKeyFilePassphrase[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): KeyFileSftpIdentity = new KeyFileSftpIdentity([0m
[0m[[0m[0mdebug[0m] [0m[0m    privateKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m    privateKeyFilePassphrase[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
