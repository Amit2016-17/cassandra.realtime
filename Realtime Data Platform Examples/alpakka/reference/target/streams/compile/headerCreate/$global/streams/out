[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/javadsl/Reference.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.{CompletionStage, Executor}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.{ReferenceReadResult, ReferenceWriteMessage, ReferenceWriteResult, SourceSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{Flow, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.ExecutionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Reference {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * No Java API at the start of the method doc needed, since the package is dedicated to the Java API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Call Scala source factory and convert both: the source and materialized values to Java classes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def source(settings: SourceSettings): Source[ReferenceReadResult, CompletionStage[Done]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.Reference.source(settings).mapMaterializedValue(_.toJava).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Only convert the flow type, as the materialized value type is the same between Java and Scala.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow(): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.Reference.flow().asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * In Java API take Executor as parameter if the operator needs to perform asynchronous tasks.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flowAsyncMapped(ex: Executor): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.Reference.flowAsyncMapped()(ExecutionContext.fromExecutor(ex)).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * An implementation of a flow that needs access to materializer or attributes during materialization.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flowWithResource(): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.Reference.flowWithResource().asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/testkit/MessageFactory.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.testkit[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.{ReferenceReadResult, ReferenceWriteMessage, ReferenceWriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MessageFactory {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createReadResult(data: immutable.Seq[ByteString], bytesRead: Try[Int]): ReferenceReadResult =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceReadResult(data, bytesRead)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createReadResultSuccess(data: java.util.List[ByteString], bytesRead: Int): ReferenceReadResult =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceReadResult(data.asScala.toList, Success(bytesRead))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createReadResultFailure(data: java.util.List[ByteString], failure: Throwable): ReferenceReadResult =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceReadResult(data.asScala.toList, Failure(failure))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWriteResult(message: ReferenceWriteMessage, metrics: Map[String, Long], status: Int): ReferenceWriteResult =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceWriteResult(message, metrics, status)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @ApiMayChange[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createWriteResult(message: ReferenceWriteMessage,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        metrics: java.util.Map[String, java.lang.Long],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        status: Int): ReferenceWriteResult =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceWriteResult(message, metrics.asScala.mapValues(Long.unbox).toMap, status)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/Resource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.{ActorSystem, ExtendedActorSystem, Extension, ExtensionId, ExtensionIdProvider}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Some connectors might require an external resource that is used in the[0m
[0m[[0m[0mdebug[0m] [0m[0m * Source, Flow and/or Sink factories.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * For example dynamodb connector needs a DynamoClient to create Sources and Flows.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Another example is Google Pub Sub gRPC connector that uses Grpc Publishers and[0m
[0m[[0m[0mdebug[0m] [0m[0m * Subscribers to create Sources and Sinks. Another connector, Alpakka Kafka, uses[0m
[0m[[0m[0mdebug[0m] [0m[0m * an actor that can be shared across different streams.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * If your connector uses such a resource and it is possible to reuse that resource[0m
[0m[[0m[0mdebug[0m] [0m[0m * across different Akka Stream operator factories, put that resource to a separate[0m
[0m[[0m[0mdebug[0m] [0m[0m * class like below.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class Resource private (val settings: ResourceSettings) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  // a resource that is to be used when creating Akka Stream operators.[0m
[0m[[0m[0mdebug[0m] [0m[0m  val connection = Flow[ByteString].map(_.reverse)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Resource cleanup logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def cleanup() = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Resource {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: ResourceSettings) = new Resource(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(settings: ResourceSettings) = Resource(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Settings required for the Resource should be extracted to a separate class.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ResourceSettings private (val msg: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"ResourceSettings(msg=$msg)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factories for the settings object should take parameters as well as a `Config`[0m
[0m[[0m[0mdebug[0m] [0m[0m * instance for reading values from HOCON.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ResourceSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConfigPath = "alpakka.reference"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(msg: String): ResourceSettings = new ResourceSettings(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(msg: String): ResourceSettings = ResourceSettings(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Resolves settings from a given Config object, which should have all of the required[0m
[0m[[0m[0mdebug[0m] [0m[0m   * values at the top level.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(config: Config): ResourceSettings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val msg = config.getString("msg")[0m
[0m[[0m[0mdebug[0m] [0m[0m    ResourceSettings(msg)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Resolves settings from a given Config object, which should have all of the required[0m
[0m[[0m[0mdebug[0m] [0m[0m   * values at the top level.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(config: Config): ResourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ResourceSettings(config)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Resolves settings from the `ActorSystem`s settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply()(implicit sys: ActorSystem): ResourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ResourceSettings(sys.settings.config.getConfig(ConfigPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Resolves settings from the `ActorSystem`s settings.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(sys: ActorSystem): ResourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ResourceSettings()(sys)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * In order to minimise the user facing API, the resource lifetime can be managed by an[0m
[0m[[0m[0mdebug[0m] [0m[0m * Akka Extension. In that case Akka Extension will make sure that[0m
[0m[[0m[0mdebug[0m] [0m[0m * there is only one instance of the resource instantiated per Actor System.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ResourceExt private (sys: ExtendedActorSystem) extends Extension {[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val resource = Resource(ResourceSettings()(sys))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sys.registerOnTermination(resource.cleanup())[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ResourceExt extends ExtensionId[ResourceExt] with ExtensionIdProvider {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def lookup = ResourceExt[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createExtension(system: ExtendedActorSystem) = new ResourceExt(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Access to extension.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply()(implicit system: ActorSystem): ResourceExt = super.apply(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Access to extension.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get(system: ActorSystem): ResourceExt = super.get(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/settings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// rename Java imports if the name clashes with the Scala name[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.{Duration => JavaDuration}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Optional[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.function.Predicate[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FunctionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Settings class constructor is private and not exposed as API.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Adding or removing arguments to methods with default values is not binary[0m
[0m[[0m[0mdebug[0m] [0m[0m * compatible. However, since the constructor is private, it will be possible[0m
[0m[[0m[0mdebug[0m] [0m[0m * to add or remove attributes without introducing binary incompatibilities.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class SourceSettings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val clientId: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val traceId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val authentication: Authentication = Authentication.None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val pollInterval: FiniteDuration = 5.seconds[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withClientId(clientId: String): SourceSettings = copy(clientId = clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Immutable setter which can be used from both Java and Scala, even if the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * attribute is stored in a Scala specific class.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withTraceId(traceId: String): SourceSettings = copy(traceId = Some(traceId))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Separate setters for every attribute enables easy evolution of settings classes by allowing[0m
[0m[[0m[0mdebug[0m] [0m[0m   * deprecation and addition of attributes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withAuthentication(authentication: Authentication): SourceSettings = copy(authentication = authentication)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For attributes that uses Java or Scala specific classes, a setter is added for both APIs.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPollInterval(pollInterval: FiniteDuration): SourceSettings = copy(pollInterval = pollInterval)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Start method documentation text with "Java API" to make it easy to notice[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java specific methods when browsing generated API documentation.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPollInterval(pollInterval: JavaDuration): SourceSettings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(pollInterval = Duration.fromNanos(pollInterval.toNanos))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A separate getter for Java API that converts Scala Option to Java Optional.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getTraceId(): Optional[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    traceId.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A separate getter for Java API that converts Scala Duration to Java Duration.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPollInterval(): JavaDuration =[0m
[0m[[0m[0mdebug[0m] [0m[0m    JavaDuration.ofNanos(pollInterval.toNanos)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Private copy method for internal use only.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(clientId: String = clientId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   traceId: Option[String] = traceId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   authentication: Authentication = authentication,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   pollInterval: FiniteDuration = pollInterval) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SourceSettings(clientId, traceId, authentication, pollInterval)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"SourceSettings(clientId=$clientId, traceId=$traceId, authentication=$authentication, pollInterval=$pollInterval)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject SourceSettings {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Factory method for Scala.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(clientId: String): SourceSettings = new SourceSettings(clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Factory method for Java.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(clientId: String): SourceSettings = SourceSettings(clientId)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Use sealed for closed class hierarchies.[0m
[0m[[0m[0mdebug[0m] [0m[0m * abstract class instead of trait for visibility inside companion object from Java.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class Authentication[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Authentication {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Make singleton objects extend an abstract class with the same name.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This makes it possible to refer to the object type without `.type`.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class None extends Authentication[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object None extends None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createNone: None = None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  final class Provided private ([0m
[0m[[0m[0mdebug[0m] [0m[0m      verifier: String => Boolean = _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  ) extends Authentication {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withVerifier(verifier: String => Boolean): Provided =[0m
[0m[[0m[0mdebug[0m] [0m[0m      copy(verifier = verifier)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /**[0m
[0m[[0m[0mdebug[0m] [0m[0m     * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m     *[0m
[0m[[0m[0mdebug[0m] [0m[0m     * Because of Scala 2.11 support where Scala function is not a functional interface,[0m
[0m[[0m[0mdebug[0m] [0m[0m     * we need to provide a setter that accepts Java's functional interface.[0m
[0m[[0m[0mdebug[0m] [0m[0m     *[0m
[0m[[0m[0mdebug[0m] [0m[0m     * A different name is needed because after type erasure functional interfaces[0m
[0m[[0m[0mdebug[0m] [0m[0m     * become ambiguous in Scala 2.12.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def withVerifierPredicate(verifier: Predicate[String]): Provided =[0m
[0m[[0m[0mdebug[0m] [0m[0m      copy(verifier = verifier.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    private def copy(verifier: String => Boolean = verifier) =[0m
[0m[[0m[0mdebug[0m] [0m[0m      new Provided(verifier)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"Authentication.Provided(verifier=$verifier)"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  object Provided {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /**[0m
[0m[[0m[0mdebug[0m] [0m[0m     * This is only accessible from Scala, because of the nested objects.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    def apply(): Provided = new Provided()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Factory method needed to access nested object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def createProvided(): Provided = Provided()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/attributes.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes.Attribute[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ReferenceAttributes {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Wrap a `Resource` to an attribute so it can be attached to a stream stage.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def resource(resource: Resource) = Attributes(new ReferenceResourceValue(resource))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ReferenceResourceValue @InternalApi private[reference] (val resource: Resource) extends Attribute[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/scaladsl/Reference.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.impl.{ReferenceFlow, ReferenceSource, ReferenceWithResourceFlow, Setup}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Reference {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * API doc should describe where the messages are coming from.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Also describe the significance of the materialized value.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def source(settings: SourceSettings): Source[ReferenceReadResult, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new ReferenceSource(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * API doc should describe what will be done to the incoming messages to the flow,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and what messages will be emitted by the flow.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow(): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new ReferenceFlow())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If the operator needs an ExecutionContext, take it as an implicit parameter.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flowAsyncMapped()(implicit ec: ExecutionContext): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    flow().mapAsync(parallelism = 4)(m => Future { m })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * An implementation of a flow that needs access to materializer or attributes during materialization.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flowWithResource(): Flow[ReferenceWriteMessage, ReferenceWriteResult, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        Flow.fromGraph(new ReferenceWithResourceFlow(resolveResource()))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def resolveResource()(implicit sys: ActorSystem, attr: Attributes) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    attr.get[ReferenceResourceValue].map(_.resource).getOrElse(ResourceExt().resource)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/impl/SetupStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// This will be removed from Alpakka project once it is merged to Akka.[0m
[0m[[0m[0mdebug[0m] [0m[0m// https://github.com/akka/akka/pull/26477[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupSinkStage[T, M](factory: ActorMaterializer => Attributes => Sink[T, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SinkShape[T], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[T]("SetupSinkStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = SinkShape(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subOutlet = new SubSourceOutlet[T]("SetupSinkStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    subOutlet.setHandler(delegateToInlet(() => pull(in), () => cancel(in)))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(in, delegateToSubOutlet(() => grab(in), subOutlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val sink = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = Source.fromGraph(subOutlet.source).runWith(sink.withAttributes(attributes))(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupFlowStage[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[FlowShape[T, U], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[T]("SetupFlowStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[U]("SetupFlowStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[U]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subOutlet = new SubSourceOutlet[T]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: U), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    subOutlet.setHandler(delegateToInlet(() => pull(in), () => cancel(in)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(in, delegateToSubOutlet(() => grab(in), subOutlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val flow = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .fromGraph(subOutlet.source)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .viaMat(flow.withAttributes(attributes))(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupSourceStage[T, M](factory: ActorMaterializer => Attributes => Source[T, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[T], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[T]("SetupSourceStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[T]("SetupSourceStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: T), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val source = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .withAttributes(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object SetupStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubOutlet[T](grab: () => T, subOutlet: GraphStageLogic#SubSourceOutlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.push(grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToOutlet[T](push: T => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          complete: () => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          fail: Throwable => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          subInlet: GraphStageLogic#SubSinkInlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      push(subInlet.grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubInlet[T](subInlet: GraphStageLogic#SubSinkInlet[T]) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToInlet(pull: () => Unit, cancel: () => Unit) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def actorMaterializer(mat: Materializer): ActorMaterializer = mat match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case am: ActorMaterializer => am[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => throw new Error("ActorMaterializer required")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] object Setup {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink[T, M](factory: ActorMaterializer => Attributes => Sink[T, M]): Sink[T, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Sink.fromGraph(new SetupSinkStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M]): Flow[T, U, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new SetupFlowStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def source[T, M](factory: ActorMaterializer => Attributes => Source[T, M]): Source[T, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new SetupSourceStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/impl/ReferenceFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.event.Logging[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.{ReferenceWriteMessage, ReferenceWriteResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Private package hides the class from the API in Scala. However it is still[0m
[0m[[0m[0mdebug[0m] [0m[0m * visible in Java. Use "InternalApi" annotation and "INTERNAL API" as the first[0m
[0m[[0m[0mdebug[0m] [0m[0m * line in scaladoc to communicate to Java developers that this is private API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceFlowStageLogic([0m
[0m[[0m[0mdebug[0m] [0m[0m    val shape: FlowShape[ReferenceWriteMessage, ReferenceWriteResult][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def in = shape.in[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def out = shape.out[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Initialization logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m    in,[0m
[0m[[0m[0mdebug[0m] [0m[0m    new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val msg = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val total = msg.metrics.values.sum[0m
[0m[[0m[0mdebug[0m] [0m[0m        push(out, new ReferenceWriteResult(msg, msg.metrics + ("total" -> total), 400))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m  })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Cleanup logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def postStop(): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceFlow()[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ReferenceWriteMessage, ReferenceWriteResult]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ReferenceWriteMessage] = Inlet(Logging.simpleName(this) + ".in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ReferenceWriteResult] = Outlet(Logging.simpleName(this) + ".out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Attributes.name(Logging.simpleName(this))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ReferenceWriteMessage, ReferenceWriteResult] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceFlowStageLogic(shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/impl/ReferenceWithResourceFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.event.Logging[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.{ReferenceWriteMessage, ReferenceWriteResult, Resource}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Private package hides the class from the API in Scala. However it is still[0m
[0m[[0m[0mdebug[0m] [0m[0m * visible in Java. Use "InternalApi" annotation and "INTERNAL API" as the first[0m
[0m[[0m[0mdebug[0m] [0m[0m * line in scaladoc to communicate to Java developers that this is private API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceWithResourceFlowStageLogic([0m
[0m[[0m[0mdebug[0m] [0m[0m    val resource: Resource,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val shape: FlowShape[ReferenceWriteMessage, ReferenceWriteResult][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def in = shape.in[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def out = shape.out[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Initialization logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler([0m
[0m[[0m[0mdebug[0m] [0m[0m    in,[0m
[0m[[0m[0mdebug[0m] [0m[0m    new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val writeMessage = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val data = writeMessage.data.map(_ ++ ByteString(s" ${resource.settings.msg}"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        push(out, new ReferenceWriteResult(writeMessage.withData(data), writeMessage.metrics, 200))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m  })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Cleanup logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def postStop(): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceWithResourceFlow(resource: Resource)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ReferenceWriteMessage, ReferenceWriteResult]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in: Inlet[ReferenceWriteMessage] = Inlet(Logging.simpleName(this) + ".in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ReferenceWriteResult] = Outlet(Logging.simpleName(this) + ".out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Attributes.name(Logging.simpleName(this))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: FlowShape[ReferenceWriteMessage, ReferenceWriteResult] = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceWithResourceFlowStageLogic(resource, shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/impl/ReferenceSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.event.Logging[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.reference.{ReferenceReadResult, SourceSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStageLogic, GraphStageWithMaterializedValue, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Success[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Private package hides the class from the API in Scala. However it is still[0m
[0m[[0m[0mdebug[0m] [0m[0m * visible in Java. Use "InternalApi" annotation and "INTERNAL API" as the first[0m
[0m[[0m[0mdebug[0m] [0m[0m * line in scaladoc to communicate to Java developers that this is private API.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceSourceStageLogic([0m
[0m[[0m[0mdebug[0m] [0m[0m    val settings: SourceSettings,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val startupPromise: Promise[Done],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val shape: SourceShape[ReferenceReadResult][0m
[0m[[0m[0mdebug[0m] [0m[0m) extends GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def out = shape.out[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Initialization logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def preStart(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m    startupPromise.success(Done)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  setHandler(out, new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit = push([0m
[0m[[0m[0mdebug[0m] [0m[0m      out,[0m
[0m[[0m[0mdebug[0m] [0m[0m      new ReferenceReadResult(immutable.Seq(ByteString("one")), Success(100))[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Cleanup logic[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def postStop(): Unit = {}[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * INTERNAL API[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[reference] final class ReferenceSource(settings: SourceSettings)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[ReferenceReadResult], Future[Done]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out: Outlet[ReferenceReadResult] = Outlet(Logging.simpleName(this) + ".out")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes: Attributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Attributes.name(Logging.simpleName(this))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape: SourceShape[ReferenceReadResult] = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[Done]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    // materialized value created as a new instance on every materialization[0m
[0m[[0m[0mdebug[0m] [0m[0m    val startupPromise = Promise[Done][0m
[0m[[0m[0mdebug[0m] [0m[0m    val logic = new ReferenceSourceStageLogic(settings, startupPromise, shape)[0m
[0m[[0m[0mdebug[0m] [0m[0m    (logic, startupPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/reference/src/main/scala/akka/stream/alpakka/reference/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.reference[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.{Optional, OptionalInt}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Success, Try}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Use "Read" in message data types to signify that the message was read from outside.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The constructor is INTERNAL API, but you may construct instances for testing by using[0m
[0m[[0m[0mdebug[0m] [0m[0m * [[akka.stream.alpakka.reference.testkit.MessageFactory]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ReferenceReadResult @InternalApi private[reference] ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val data: immutable.Seq[ByteString] = immutable.Seq.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bytesRead: Try[Int] = Success(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If the model class is meant to be also consumed from the user API,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * but the attribute class is Scala specific, create getter for Java API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getData(): java.util.List[ByteString] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If the model class is scala.util.Try, then two getters should be created.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * One for getting the value, and another for getting the exception.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Return bytes read wrapped in OptionalInt if the Try contains a value,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * otherwise return empty Optional.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getBytesRead(): OptionalInt =[0m
[0m[[0m[0mdebug[0m] [0m[0m    bytesRead.toOption.asPrimitive[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Return the exception wrapped in Optional if the Try contains a Failure,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * otherwise return empty Optional.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getBytesReadFailure(): Optional[Throwable] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    bytesRead.failed.toOption.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"ReferenceReadMessage(data=$data, bytesRead=$bytesRead)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Use "Write" in message data types to signify that the messages is to be written to outside.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ReferenceWriteMessage private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val data: immutable.Seq[ByteString] = immutable.Seq.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val metrics: Map[String, Long] = Map.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withData(data: immutable.Seq[ByteString]): ReferenceWriteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(data = data)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMetrics(metrics: Map[String, Long]): ReferenceWriteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(metrics = metrics)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * When settings class has an attribute of Scala collection type,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * create a setter that takes a corresponding Java collection type.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withData(data: java.util.List[ByteString]): ReferenceWriteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(data = data.asScala.toIndexedSeq)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * When settings class has an attribute of Scala Long class,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java setter needs to take Java Long class and convert to Scala Long.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMetrics(metrics: java.util.Map[String, java.lang.Long]): ReferenceWriteMessage =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(metrics = metrics.asScala.mapValues(Long.unbox).toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * If the model class is meant to be also consumed from the user API,[0m
[0m[[0m[0mdebug[0m] [0m[0m   * but the attribute class is Scala specific, create getter for Java API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getData(): java.util.List[ByteString] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    data.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java getter needs to return Java Long classes which is converted from Scala Long.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getMetrics(): java.util.Map[String, java.lang.Long] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    metrics.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (key, value) => key -> java.lang.Long.valueOf(value)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(data: immutable.Seq[ByteString] = data, metrics: Map[String, Long] = metrics) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ReferenceWriteMessage(data, metrics)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"ReferenceWriteMessage(data=$data, metrics=$metrics)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ReferenceWriteMessage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(): ReferenceWriteMessage = new ReferenceWriteMessage()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(): ReferenceWriteMessage = ReferenceWriteMessage()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * The result returned by the flow for each [[ReferenceWriteMessage]].[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * As this class is not meant to be instantiated outside of this connector[0m
[0m[[0m[0mdebug[0m] [0m[0m * the constructor is marked as INTERNAL API.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The constructor is INTERNAL API, but you may construct instances for testing by using[0m
[0m[[0m[0mdebug[0m] [0m[0m * [[akka.stream.alpakka.reference.testkit.MessageFactory]].[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ReferenceWriteResult @InternalApi private[reference] (val message: ReferenceWriteMessage,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  val metrics: Map[String, Long],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                  val status: Int) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getMessage: ReferenceWriteMessage = message[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java getter needs to return Java Long classes which is converted from Scala Long.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getMetrics(): java.util.Map[String, java.lang.Long] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    metrics.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case (key, value) => key -> java.lang.Long.valueOf(value)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getStatus: Int = status[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"""ReferenceWriteResult(message=$message,status=$status)"""[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: ReferenceWriteResult =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.message, that.message) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.status, that.status)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    java.util.Objects.hash(message, Int.box(status))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
