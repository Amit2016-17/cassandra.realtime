[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/csv-bench/src/main/scala/akka/stream/alpakka/csv/scaladsl/CsvBench.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.csv.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.TimeUnit[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.ActorMaterializer[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.openjdk.jmh.annotations._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.openjdk.jmh.infra.Blackhole[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Await[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.duration.Duration[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Measures the time to parse a 1 MB CSV file, consuming the first field of each row.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * ==Using Oracle Flight Recorder==[0m
[0m[[0m[0mdebug[0m] [0m[0m * To record a Flight Recorder file from a JMH run, run it using the jmh.extras.JFR profiler:[0m
[0m[[0m[0mdebug[0m] [0m[0m * > csv-bench/jmh:run -prof jmh.extras.JFR -t1 -f1 -wi 5 -i 10 .*CsvBench[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * This will result in flight recording file which you can open and analyze offline using JMC.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Start with "jmc" from a terminal.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * ==Sample benchmark results==[0m
[0m[[0m[0mdebug[0m] [0m[0m * Your results may differ.[0m
[0m[[0m[0mdebug[0m] [0m[0m * Rerun these on YOUR OWN MACHINE before/after making changes.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * {{{[0m
[0m[[0m[0mdebug[0m] [0m[0m * > csv-bench/jmh:run -t1 -f1 -wi 10 -i 10 .*CsvBench[0m
[0m[[0m[0mdebug[0m] [0m[0m * [info] Benchmark        (bsSize)   Mode  Cnt    Score   Error  Units[0m
[0m[[0m[0mdebug[0m] [0m[0m * [info] CsvBench.parse        32  thrpt   10   78.424 Â± 1.351  ops/s[0m
[0m[[0m[0mdebug[0m] [0m[0m * [info] CsvBench.parse      1024  thrpt   10  158.948 Â± 3.187  ops/s[0m
[0m[[0m[0mdebug[0m] [0m[0m * [info] CsvBench.parse      8192  thrpt   10  167.617 Â± 2.759  ops/s[0m
[0m[[0m[0mdebug[0m] [0m[0m * [info] CsvBench.parse     65536  thrpt   10  170.670 Â± 2.462  ops/s[0m
[0m[[0m[0mdebug[0m] [0m[0m * }}}[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @see https://github.com/ktoso/sbt-jmh[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@Warmup(iterations = 8, time = 1, timeUnit = TimeUnit.SECONDS)[0m
[0m[[0m[0mdebug[0m] [0m[0m@Measurement(iterations = 10, time = 1, timeUnit = TimeUnit.SECONDS)[0m
[0m[[0m[0mdebug[0m] [0m[0m@BenchmarkMode(Array(Mode.Throughput))[0m
[0m[[0m[0mdebug[0m] [0m[0m@Fork(jvmArgsAppend = Array("-Xmx350m", "-XX:+HeapDumpOnOutOfMemoryError"), value = 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m@State(Scope.Benchmark)[0m
[0m[[0m[0mdebug[0m] [0m[0mclass CsvBench {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val system = ActorSystem()[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val executionContext = system.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val mat = ActorMaterializer()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Size of [[ByteString]] chunks in bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Total message size remains the same.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This just determines how big the chunks are.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * WSClient returns a Source[ByteString, _] in 8k chunks.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @Param([0m
[0m[[0m[0mdebug[0m] [0m[0m    Array([0m
[0m[[0m[0mdebug[0m] [0m[0m      "32", //   smaller than a field[0m
[0m[[0m[0mdebug[0m] [0m[0m      "1024", // ~8x smaller than row[0m
[0m[[0m[0mdebug[0m] [0m[0m      "8192", // ~same size as row[0m
[0m[[0m[0mdebug[0m] [0m[0m      "65536" // ~8k larger than row[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m  var bsSize: Int = _[0m
[0m[[0m[0mdebug[0m] [0m[0m  var source: Source[ByteString, NotUsed] = _[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @Benchmark[0m
[0m[[0m[0mdebug[0m] [0m[0m  def parse(bh: Blackhole): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val futureDone = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .via(CsvParsing.lineScanner())[0m
[0m[[0m[0mdebug[0m] [0m[0m        .runForeach { fields =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          bh.consume(fields.head.utf8String)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    Await.result(futureDone, Duration.Inf)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @TearDown[0m
[0m[[0m[0mdebug[0m] [0m[0m  def tearDown(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    mat.shutdown()[0m
[0m[[0m[0mdebug[0m] [0m[0m    system.terminate()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m  def setup(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    /**[0m
[0m[[0m[0mdebug[0m] [0m[0m     * 8 fields in a row, each of size 100, with commas and an '\n' is 8008 bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m     */[0m
[0m[[0m[0mdebug[0m] [0m[0m    val row = ByteString(('a' to 'h').map(_.toString * 100).mkString("", ",", "\n"))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val allChunks = Iterator[0m
[0m[[0m[0mdebug[0m] [0m[0m      .continually(row)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .take(1024 * 1024 / row.length) // approx 1MiB for easy conversion from ops/s[0m
[0m[[0m[0mdebug[0m] [0m[0m      .reduce(_ ++ _)[0m
[0m[[0m[0mdebug[0m] [0m[0m      /**[0m
[0m[[0m[0mdebug[0m] [0m[0m       * Reframe into 8KiB chunks to mimic WSClient, and[0m
[0m[[0m[0mdebug[0m] [0m[0m       * so csv boundaries misalign with ByteString chunks as they would in reality.[0m
[0m[[0m[0mdebug[0m] [0m[0m       */[0m
[0m[[0m[0mdebug[0m] [0m[0m      .grouped(bsSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m      /**[0m
[0m[[0m[0mdebug[0m] [0m[0m       * Compact is important here.[0m
[0m[[0m[0mdebug[0m] [0m[0m       *[0m
[0m[[0m[0mdebug[0m] [0m[0m       * alpakka-csv perf suffers a bit over non-compact [[akka.util.ByteString.ByteStrings]].[0m
[0m[[0m[0mdebug[0m] [0m[0m       * Its design relies on getting bytes by index from the [[ByteString]].[0m
[0m[[0m[0mdebug[0m] [0m[0m       * The indirections add up.[0m
[0m[[0m[0mdebug[0m] [0m[0m       *[0m
[0m[[0m[0mdebug[0m] [0m[0m       * WSClient will return [[akka.util.ByteString.ByteString1C]] chunks,[0m
[0m[[0m[0mdebug[0m] [0m[0m       * so we should do the same.[0m
[0m[[0m[0mdebug[0m] [0m[0m       */[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.compact)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toIndexedSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    source = Source.fromIterator(() => allChunks.iterator)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * For debugging.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CsvBench {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def main(args: Array[String]): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bench = new CsvBench[0m
[0m[[0m[0mdebug[0m] [0m[0m    bench.parse([0m
[0m[[0m[0mdebug[0m] [0m[0m      new Blackhole("Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.")[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m    bench.tearDown()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
