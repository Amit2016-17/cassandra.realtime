[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/S3Ext.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.{ActorSystem, ExtendedActorSystem, Extension, ExtensionId, ExtensionIdProvider}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Manages one [[S3Settings]] per `ActorSystem`.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class S3Ext private (sys: ExtendedActorSystem) extends Extension {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val settings: S3Settings = settings(S3Settings.ConfigPath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def settings(prefix: String): S3Settings = S3Settings(sys.settings.config.getConfig(prefix))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3Ext extends ExtensionId[S3Ext] with ExtensionIdProvider {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def lookup = S3Ext[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createExtension(system: ExtendedActorSystem) = new S3Ext(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def get(system: ActorSystem): S3Ext = super.get(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/javadsl/S3.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Optional[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.japi.{Pair => JPair}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.javadsl.model._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.javadsl.model.headers.ByteRange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.{ByteRange => ScalaByteRange}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{ContentType => ScalaContentType, HttpMethod => ScalaHttpMethod}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Materializer}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.headers.{CannedAcl, ServerSideEncryption}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{RunnableGraph, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.FutureConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Java API[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory of S3 operations.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3 {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Use this for a low level access to S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param method the [[akka.http.javadsl.model.HttpMethod HttpMethod]] to use when making the request[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a raw HTTP response from S3[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def request(bucket: String, key: String, method: HttpMethod, s3Headers: S3Headers): Source[HttpResponse, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    request(bucket, key, Optional.empty(), method, s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Use this for a low level access to S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional versionId of source object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param method the [[akka.http.javadsl.model.HttpMethod HttpMethod]] to use when making the request[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a raw HTTP response from S3[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def request(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m              key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m              versionId: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m              method: HttpMethod = HttpMethods.GET,[0m
[0m[[0m[0mdebug[0m] [0m[0m              s3Headers: S3Headers = S3Headers()): Source[HttpResponse, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .request(S3Location(bucket, key),[0m
[0m[[0m[0mdebug[0m] [0m[0m               method.asInstanceOf[ScalaHttpMethod],[0m
[0m[[0m[0mdebug[0m] [0m[0m               versionId = Option(versionId.orElse(null)),[0m
[0m[[0m[0mdebug[0m] [0m[0m               s3Headers = s3Headers.headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(v => v: HttpResponse)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the metadata for a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] containing an [[java.util.Optional Optional]] that will be empty in case the object does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getObjectMetadata(bucket: String, key: String): Source[Optional[ObjectMetadata], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    getObjectMetadata(bucket, key, null)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the metadata for a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] containing an [[java.util.Optional Optional]] that will be empty in case the object does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getObjectMetadata(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        sse: ServerSideEncryption): Source[Optional[ObjectMetadata], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    getObjectMetadata(bucket, key, Optional.empty(), sse)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the metadata for a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional versionId of source object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] containing an [[java.util.Optional Optional]] that will be empty in case the object does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getObjectMetadata(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        versionId: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        sse: ServerSideEncryption): Source[Optional[ObjectMetadata], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getObjectMetadata(bucket, key, Option(versionId.orElse(null)), Option(sse))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { opt =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Optional.ofNullable(opt.orNull)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] that will emit [[java.lang.Void]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObject(bucket: String, key: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteObject(bucket, key, Optional.empty())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] that will emit [[java.lang.Void]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObject(bucket: String, key: String, versionId: Optional[String]): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .deleteObject(S3Location(bucket, key), Option(versionId.orElse(null)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => Done.getInstance())[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes all keys under the specified bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] that will emit [[java.lang.Void]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObjectsByPrefix(bucket: String): Source[Done, NotUsed] = deleteObjectsByPrefix(bucket, Optional.empty())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes all keys which have the given prefix under the specified bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param prefix optional s3 objects prefix[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.javadsl.Source Source]] that will emit [[java.lang.Void]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObjectsByPrefix(bucket: String, prefix: Optional[String]): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .deleteObjectsByPrefix(bucket, Option(prefix.orElse(null)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_ => Done.getInstance())[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object, use this for small files and [[multipartUpload]] for bigger ones[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param data a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentLength the number of bytes that will be uploaded (required!)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any additional headers for the request[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def putObject(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentLength: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                s3Headers: S3Headers): Source[ObjectMetadata, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .putObject(S3Location(bucket, key),[0m
[0m[[0m[0mdebug[0m] [0m[0m                 contentType.asInstanceOf[ScalaContentType],[0m
[0m[[0m[0mdebug[0m] [0m[0m                 data.asScala,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 contentLength,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object, use this for small files and [[multipartUpload]] for bigger ones[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param data a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentLength the number of bytes that will be uploaded (required!)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def putObject(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentLength: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentType: ContentType): Source[ObjectMetadata, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    putObject(bucket, key, data, contentLength, contentType, S3Headers().withCannedAcl(CannedAcl.Private))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object, use this for small files and [[multipartUpload]] for bigger ones[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param data a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentLength the number of bytes that will be uploaded (required!)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def putObject(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentLength: Long): Source[ObjectMetadata, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    putObject(bucket, key, data, contentLength, ContentTypes.APPLICATION_OCTET_STREAM)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def toJava[M]([0m
[0m[[0m[0mdebug[0m] [0m[0m      download: akka.stream.scaladsl.Source[Option[[0m
[0m[[0m[0mdebug[0m] [0m[0m        (akka.stream.scaladsl.Source[ByteString, M], ObjectMetadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m      ], NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Optional[JPair[Source[ByteString, M], ObjectMetadata]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    download.map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      _.map { case (stream, meta) => JPair(stream.asJava, meta) }.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.japi.Pair]] with a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]], and a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               key: String): Source[Optional[JPair[Source[ByteString, NotUsed], ObjectMetadata]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    toJava(S3Stream.download(S3Location(bucket, key), None, None, None))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.japi.Pair]] with a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]], and a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: ServerSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Optional[JPair[Source[ByteString, NotUsed], ObjectMetadata]], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    toJava(S3Stream.download(S3Location(bucket, key), None, None, Some(sse)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a specific byte range of a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param range the [[akka.http.javadsl.model.headers.ByteRange ByteRange]] you want to download[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.japi.Pair]] with a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]], and a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m               range: ByteRange): Source[Optional[JPair[Source[ByteString, NotUsed], ObjectMetadata]], NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scalaRange = range.asInstanceOf[ScalaByteRange][0m
[0m[[0m[0mdebug[0m] [0m[0m    toJava(S3Stream.download(S3Location(bucket, key), Some(scalaRange), None, None))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a specific byte range of a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param range the [[akka.http.javadsl.model.headers.ByteRange ByteRange]] you want to download[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.japi.Pair]] with a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]], and a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      range: ByteRange,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: ServerSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Optional[JPair[Source[ByteString, NotUsed], ObjectMetadata]], NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scalaRange = range.asInstanceOf[ScalaByteRange][0m
[0m[[0m[0mdebug[0m] [0m[0m    toJava(S3Stream.download(S3Location(bucket, key), Some(scalaRange), None, Some(sse)))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a specific byte range of a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param range the [[akka.http.javadsl.model.headers.ByteRange ByteRange]] you want to download[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.japi.Pair]] with a [[akka.stream.javadsl.Source Source]] of [[akka.util.ByteString ByteString]], and a [[akka.stream.javadsl.Source Source]] containing the [[ObjectMetadata]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      range: ByteRange,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: ServerSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Optional[JPair[Source[ByteString, NotUsed], ObjectMetadata]], NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scalaRange = range.asInstanceOf[ScalaByteRange][0m
[0m[[0m[0mdebug[0m] [0m[0m    toJava([0m
[0m[[0m[0mdebug[0m] [0m[0m      S3Stream.download(S3Location(bucket, key), Option(scalaRange), Option(versionId.orElse(null)), Option(sse))[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Will return a source of object metadata for a given bucket with optional prefix using version 2 of the List Bucket API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This will automatically page through all keys with the given parameters.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The <code>akka.stream.alpakka.s3.list-bucket-api-version</code> can be set to 1 to use the older API version 1[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/v2-RESTBucketGET.html  (version 1 API)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html (version 1 API)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket Which bucket that you list object metadata for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param prefix Prefix of the keys you want to list under passed bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return Source of object metadata[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listBucket(bucket: String, prefix: Option[String]): Source[ListBucketResultContents, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .listBucket(bucket, prefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object by making multiple requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Sink Sink]] that accepts [[akka.util.ByteString ByteString]]'s and materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[MultipartUploadResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      s3Headers: S3Headers): Sink[ByteString, CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .multipartUpload(S3Location(bucket, key), contentType.asInstanceOf[ScalaContentType], s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.toJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object by making multiple requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Sink Sink]] that accepts [[akka.util.ByteString ByteString]]'s and materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[MultipartUploadResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                      contentType: ContentType): Sink[ByteString, CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartUpload(bucket, key, contentType, S3Headers().withCannedAcl(CannedAcl.Private))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object by making multiple requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.javadsl.Sink Sink]] that accepts [[akka.util.ByteString ByteString]]'s and materializes to a [[java.util.concurrent.CompletionStage CompletionStage]] of [[MultipartUploadResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload(bucket: String, key: String): Sink[ByteString, CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartUpload(bucket, key, ContentTypes.APPLICATION_OCTET_STREAM)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy a S3 Object by making multiple requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket the source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey the source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket the target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey the target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceVersionId version id of source object, if the versioning is enabled in source bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the [[akka.stream.alpakka.s3.MultipartUploadResult MultipartUploadResult]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy(sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceVersionId: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    s3Headers: S3Headers): RunnableGraph[CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    RunnableGraph[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromGraph {[0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m          .multipartCopy([0m
[0m[[0m[0mdebug[0m] [0m[0m            S3Location(sourceBucket, sourceKey),[0m
[0m[[0m[0mdebug[0m] [0m[0m            S3Location(targetBucket, targetKey),[0m
[0m[[0m[0mdebug[0m] [0m[0m            Option(sourceVersionId.orElse(null)),[0m
[0m[[0m[0mdebug[0m] [0m[0m            contentType.asInstanceOf[ScalaContentType],[0m
[0m[[0m[0mdebug[0m] [0m[0m            s3Headers[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(func(_.toJava))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy a S3 Object by making multiple requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket the source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey the source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket the target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey the target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceVersionId version id of source object, if the versioning is enabled in source bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the [[akka.stream.alpakka.s3.MultipartUploadResult MultipartUploadResult]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy(sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceVersionId: Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    s3Headers: S3Headers): RunnableGraph[CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartCopy(sourceBucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  sourceKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  targetBucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  targetKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  sourceVersionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  ContentTypes.APPLICATION_OCTET_STREAM,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy a S3 Object by making multiple requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket the source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey the source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket the target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey the target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.javadsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the [[akka.stream.alpakka.s3.MultipartUploadResult MultipartUploadResult]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy(sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    s3Headers: S3Headers): RunnableGraph[CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartCopy(sourceBucket, sourceKey, targetBucket, targetKey, Optional.empty(), contentType, s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy a S3 Object by making multiple requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket the source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey the source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket the target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey the target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the [[akka.stream.alpakka.s3.MultipartUploadResult MultipartUploadResult]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy(sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    s3Headers: S3Headers): RunnableGraph[CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartCopy(sourceBucket, sourceKey, targetBucket, targetKey, ContentTypes.APPLICATION_OCTET_STREAM, s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy a S3 Object by making multiple requests.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket the source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey the source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket the target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey the target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return the [[akka.stream.alpakka.s3.MultipartUploadResult MultipartUploadResult]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy(sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    targetKey: String): RunnableGraph[CompletionStage[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    multipartCopy(sourceBucket, sourceKey, targetBucket, targetKey, ContentTypes.APPLICATION_OCTET_STREAM, S3Headers())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create new bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param attributes attributes to run request with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucket(bucketName: String, materializer: Materializer, attributes: Attributes): CompletionStage[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.makeBucket(bucketName)(materializer, attributes).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create new bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucket(bucketName: String, materializer: Materializer): CompletionStage[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.makeBucket(bucketName)(materializer, Attributes()).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create new bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.javadsl.Source Source]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucketSource(bucketName: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.makeBucketSource(bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketDELETE.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param attributes attributes to run request with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucket(bucketName: String, materializer: Materializer, attributes: Attributes): CompletionStage[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteBucket(bucketName)(materializer, attributes).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketDELETE.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucket(bucketName: String, materializer: Materializer): CompletionStage[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteBucket(bucketName)(materializer, Attributes()).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketDELETE.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.javadsl.Source Source]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucketSource(bucketName: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteBucketSource(bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Checks whether the bucket exists and the user has rights to perform the `ListBucket` operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param attributes attributes to run request with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[BucketAccess]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExists(bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          materializer: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          attributes: Attributes): CompletionStage[BucketAccess] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.checkIfBucketExists(bucketName)(materializer, attributes).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Checks whether the bucket exits and user has rights to perform ListBucket operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param materializer materializer to run with[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[java.util.concurrent.CompletionStage CompletionStage]] of type [[BucketAccess]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExists(bucketName: String, materializer: Materializer): CompletionStage[BucketAccess] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.checkIfBucketExists(bucketName)(materializer, Attributes()).toJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Checks whether the bucket exits and user has rights to perform ListBucket operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName   bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.javadsl.Source Source]] of type [[BucketAccess]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExistsSource(bucketName: String): Source[BucketAccess, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.checkIfBucketExistsSource(bucketName).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def func[T, R](f: T => R) = new akka.japi.function.Function[T, R] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def apply(param: T): R = f(param)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/settings.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.{Path, Paths}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Objects[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.Uri[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.amazonaws.auth._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.amazonaws.regions.{AwsRegionProvider, DefaultAwsRegionProviderChain}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.typesafe.config.Config[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class Proxy private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val host: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val port: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scheme: String[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getHost: String = host[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPort: Int = port[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getScheme: String = scheme[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHost(value: String): Proxy = copy(host = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPort(value: Int): Proxy = copy(port = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withScheme(value: String): Proxy = copy(scheme = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(host: String = host, port: Int = port, scheme: String = scheme): Proxy =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Proxy(host = host, port = port, scheme = scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "Proxy(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"host=$host," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"port=$port," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"scheme=$scheme" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: Proxy =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.host, that.host) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.port, that.port) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.scheme, that.scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(host, Int.box(port), scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject Proxy {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(host: String, port: Int, scheme: String): Proxy =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new Proxy(host, port, scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(host: String, port: Int, scheme: String): Proxy =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(host, port, scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ForwardProxyCredentials private (val username: String, val password: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getUsername: String = username[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPassword: String = password[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUsername(username: String) = copy(username = username)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPassword(password: String) = copy(password = password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(username: String = username, password: String = password) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ForwardProxyCredentials(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ForwardProxyCredentials(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"username=$username," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"password=******" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: ForwardProxyCredentials =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.username, that.username) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.password, that.password)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ForwardProxyCredentials {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(username: String, password: String): ForwardProxyCredentials =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ForwardProxyCredentials(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(username: String, password: String): ForwardProxyCredentials =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(username, password)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ForwardProxy private (val host: String, val port: Int, val credentials: Option[ForwardProxyCredentials]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getHost: String = host[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPort: Int = port[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getCredentials: java.util.Optional[ForwardProxyCredentials] = credentials.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withHost(host: String) = copy(host = host)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPort(port: Int) = copy(port = port)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentials(credentials: ForwardProxyCredentials) = copy(credentials = Option(credentials))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(host: String = host, port: Int = port, credentials: Option[ForwardProxyCredentials] = credentials) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ForwardProxy(host, port, credentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ForwardProxy(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"host=$host," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"port=$port," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"credentials=$credentials" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: ForwardProxy =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.host, that.host) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.port, that.port) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.credentials, that.credentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(host, Int.box(port), credentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ForwardProxy {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(host: String, port: Int, credentials: Option[ForwardProxyCredentials]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new ForwardProxy(host, port, credentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(host: String, port: Int, credentials: Option[ForwardProxyCredentials]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(host, port, credentials)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ApiVersion {[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class ListBucketVersion1 extends ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ListBucketVersion1 extends ListBucketVersion1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getListBucketVersion1: ListBucketVersion1 = ListBucketVersion1[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  sealed abstract class ListBucketVersion2 extends ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object ListBucketVersion2 extends ListBucketVersion2[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getListBucketVersion2: ListBucketVersion2 = ListBucketVersion2[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class S3Settings private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val bufferType: BufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentialsProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val s3RegionProvider: AwsRegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val pathStyleAccess: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val endpointUrl: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m    val listBucketApiVersion: ApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val forwardProxy: Option[ForwardProxy][0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Please use endpointUrl instead", since = "1.0.1") val proxy: Option[Proxy] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getBufferType: BufferType = bufferType[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Please use endpointUrl instead", since = "1.0.1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getProxy: java.util.Optional[Proxy] = proxy.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getCredentialsProvider: AWSCredentialsProvider = credentialsProvider[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getS3RegionProvider: AwsRegionProvider = s3RegionProvider[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isPathStyleAccess: Boolean = pathStyleAccess[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getEndpointUrl: java.util.Optional[String] = endpointUrl.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getListBucketApiVersion: ApiVersion = listBucketApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getForwardProxy: java.util.Optional[ForwardProxy] = forwardProxy.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBufferType(value: BufferType): S3Settings = copy(bufferType = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Please use endpointUrl instead", since = "1.0.1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withProxy(value: Proxy): S3Settings = copy(endpointUrl = Some(s"${value.scheme}://${value.host}:${value.port}"))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCredentialsProvider(value: AWSCredentialsProvider): S3Settings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(credentialsProvider = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withS3RegionProvider(value: AwsRegionProvider): S3Settings = copy(s3RegionProvider = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withPathStyleAccess(value: Boolean): S3Settings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (pathStyleAccess == value) this else copy(pathStyleAccess = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withEndpointUrl(value: String): S3Settings = copy(endpointUrl = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withListBucketApiVersion(value: ApiVersion): S3Settings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(listBucketApiVersion = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withForwardProxy(value: ForwardProxy): S3Settings =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(forwardProxy = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType: BufferType = bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider: AWSCredentialsProvider = credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider: AwsRegionProvider = s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pathStyleAccess: Boolean = pathStyleAccess,[0m
[0m[[0m[0mdebug[0m] [0m[0m      endpointUrl: Option[String] = endpointUrl,[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion: ApiVersion = listBucketApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m      forwardProxy: Option[ForwardProxy] = forwardProxy[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Settings = new S3Settings([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferType = bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentialsProvider = credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3RegionProvider = s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    pathStyleAccess = pathStyleAccess,[0m
[0m[[0m[0mdebug[0m] [0m[0m    endpointUrl = endpointUrl,[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucketApiVersion = listBucketApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m    forwardProxy = forwardProxy[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "S3Settings(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"bufferType=$bufferType," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"credentialsProvider=$credentialsProvider," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"s3RegionProvider=$s3RegionProvider," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"pathStyleAccess=$pathStyleAccess," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"endpointUrl=$endpointUrl," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"listBucketApiVersion=$listBucketApiVersion" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"forwardProxy=$forwardProxy" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: S3Settings =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      java.util.Objects.equals(this.bufferType, that.bufferType) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.credentialsProvider, that.credentialsProvider) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.s3RegionProvider, that.s3RegionProvider) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.pathStyleAccess, that.pathStyleAccess) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.endpointUrl, that.endpointUrl) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.listBucketApiVersion, that.listBucketApiVersion) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.forwardProxy, that.forwardProxy)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 Boolean.box(pathStyleAccess),[0m
[0m[[0m[0mdebug[0m] [0m[0m                 endpointUrl,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 listBucketApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m                 forwardProxy)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3Settings {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ConfigPath = "alpakka.s3"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(c: Config): S3Settings = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bufferType = c.getString("buffer") match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case "memory" =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        MemoryBufferType[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case "disk" =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val diskBufferPath = c.getString("disk-buffer-path")[0m
[0m[[0m[0mdebug[0m] [0m[0m        DiskBufferType(Paths.get(diskBufferPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      case other =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        throw new IllegalArgumentException(s"Buffer type must be 'memory' or 'disk'. Got: [$other]")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maybeProxy = for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      host ← Try(c.getString("proxy.host")).toOption if host.nonEmpty[0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield {[0m
[0m[[0m[0mdebug[0m] [0m[0m      Proxy([0m
[0m[[0m[0mdebug[0m] [0m[0m        host,[0m
[0m[[0m[0mdebug[0m] [0m[0m        c.getInt("proxy.port"),[0m
[0m[[0m[0mdebug[0m] [0m[0m        Uri.httpScheme(c.getBoolean("proxy.secure"))[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val maybeForwardProxy = if (c.hasPath("forward-proxy")) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val maybeCredentials = if (c.hasPath("forward-proxy.credentials")) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        Option([0m
[0m[[0m[0mdebug[0m] [0m[0m          ForwardProxyCredentials(c.getString("forward-proxy.credentials.username"),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  c.getString("forward-proxy.credentials.password"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      Option(ForwardProxy(c.getString("forward-proxy.host"), c.getInt("forward-proxy.port"), maybeCredentials))[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else None[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val pathStyleAccess = c.getBoolean("path-style-access")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val endpointUrl = if (c.hasPath("endpoint-url")) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      Option(c.getString("endpoint-url"))[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      None[0m
[0m[[0m[0mdebug[0m] [0m[0m    }.orElse(maybeProxy.map(p => s"${p.scheme}://${p.host}:${p.port}"))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val regionProvider = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val regionProviderPath = "aws.region.provider"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val staticRegionProvider = new AwsRegionProvider {[0m
[0m[[0m[0mdebug[0m] [0m[0m        lazy val getRegion: String = c.getString("aws.region.default-region")[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(regionProviderPath)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        c.getString(regionProviderPath) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case "static" =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            staticRegionProvider[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            new DefaultAwsRegionProviderChain()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        new DefaultAwsRegionProviderChain()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val credentialsProvider = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val credProviderPath = "aws.credentials.provider"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      if (c.hasPath(credProviderPath)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        c.getString(credProviderPath) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case "default" ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m            DefaultAWSCredentialsProviderChain.getInstance()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case "static" ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m            val aki = c.getString("aws.credentials.access-key-id")[0m
[0m[[0m[0mdebug[0m] [0m[0m            val sak = c.getString("aws.credentials.secret-access-key")[0m
[0m[[0m[0mdebug[0m] [0m[0m            val tokenPath = "aws.credentials.token"[0m
[0m[[0m[0mdebug[0m] [0m[0m            val creds = if (c.hasPath(tokenPath)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              new BasicSessionCredentials(aki, sak, c.getString(tokenPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              new BasicAWSCredentials(aki, sak)[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m            new AWSStaticCredentialsProvider(creds)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case "anon" ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m            new AWSStaticCredentialsProvider(new AnonymousAWSCredentials())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ ⇒[0m
[0m[[0m[0mdebug[0m] [0m[0m            DefaultAWSCredentialsProviderChain.getInstance()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m        DefaultAWSCredentialsProviderChain.getInstance()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val apiVersion = Try(c.getInt("list-bucket-api-version") match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case 1 => ApiVersion.ListBucketVersion1[0m
[0m[[0m[0mdebug[0m] [0m[0m      case 2 => ApiVersion.ListBucketVersion2[0m
[0m[[0m[0mdebug[0m] [0m[0m    }).getOrElse(ApiVersion.ListBucketVersion2)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    new S3Settings([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType = bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider = credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider = regionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pathStyleAccess = pathStyleAccess,[0m
[0m[[0m[0mdebug[0m] [0m[0m      endpointUrl = endpointUrl,[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion = apiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m      forwardProxy = maybeForwardProxy[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Reads from the given config.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(c: Config): S3Settings = apply(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Please use the other factory method that takes only mandatory attributes", since = "1.0.1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType: BufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      proxy: Option[Proxy],[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider: AwsRegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pathStyleAccess: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m      endpointUrl: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion: ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Settings = new S3Settings([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    pathStyleAccess,[0m
[0m[[0m[0mdebug[0m] [0m[0m    endpointUrl,[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucketApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m    None[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType: BufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider: AwsRegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion: ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Settings = new S3Settings([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    false,[0m
[0m[[0m[0mdebug[0m] [0m[0m    None,[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucketApiVersion,[0m
[0m[[0m[0mdebug[0m] [0m[0m    None[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @deprecated("Please use the other factory method that takes only mandatory attributes", since = "1.0.1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType: BufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      proxy: java.util.Optional[Proxy],[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider: AwsRegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pathStyleAccess: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m      endpointUrl: java.util.Optional[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion: ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Settings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    proxy.asScala,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    pathStyleAccess,[0m
[0m[[0m[0mdebug[0m] [0m[0m    endpointUrl.asScala,[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucketApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      bufferType: BufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      credentialsProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3RegionProvider: AwsRegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      listBucketApiVersion: ApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Settings = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    bufferType,[0m
[0m[[0m[0mdebug[0m] [0m[0m    credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3RegionProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucketApiVersion[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Scala API: Creates [[S3Settings]] from the [[com.typesafe.config.Config Config]] attached to an [[akka.actor.ActorSystem]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply()(implicit system: ActorSystem): S3Settings = apply(system.settings.config.getConfig(ConfigPath))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java API: Creates [[S3Settings]] from the [[com.typesafe.config.Config Config]] attached to an [[akka.actor.ActorSystem]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(system: ActorSystem): S3Settings = apply()(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0msealed trait BufferType {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def path: Option[Path][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getPath: java.util.Optional[Path] = path.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object MemoryBufferType extends BufferType {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getInstance: BufferType = MemoryBufferType[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def path: Option[Path] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class DiskBufferType private (filePath: Path) extends BufferType {[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val path: Option[Path] = Some(filePath).filterNot(_.toString.isEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mcase object DiskBufferType {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(path: Path): DiskBufferType = new DiskBufferType(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(path: Path): DiskBufferType = DiskBufferType(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/S3Exception.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.xml.{Elem, XML}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mclass S3Exception(val code: String, val message: String, val requestId: String, val hostId: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends RuntimeException(message) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(xmlResponse: Elem) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this((xmlResponse \ "Code").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m         (xmlResponse \ "Message").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m         (xmlResponse \ "RequestID").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m         (xmlResponse \ "HostID").text)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def this(response: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    this([0m
[0m[[0m[0mdebug[0m] [0m[0m      Try(XML.loadString(response)).getOrElse([0m
[0m[[0m[0mdebug[0m] [0m[0m        <Error><Code>-</Code><Message>{response}</Message><RequestID>-</RequestID><HostID>-</HostID></Error>[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString = s"${super.toString} (Code: $code, RequestID: $requestId, HostID: $hostId)"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/headers/ServerSideEncryption.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.headers[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Objects[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.HttpHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.RawHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.amazonaws.util.{Base64, Md5Utils}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Documentation: http://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed abstract class ServerSideEncryption {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def headers: immutable.Seq[HttpHeader][0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def headersFor(request: S3Request): immutable.Seq[HttpHeader][0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ServerSideEncryption {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def aes256() =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new AES256()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def kms(keyId: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new KMS(keyId, None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def customerKeys(key: String) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new CustomerKeys(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class AES256 private[headers] () extends ServerSideEncryption {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headers: immutable.Seq[HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("x-amz-server-side-encryption", "AES256") :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headersFor(request: S3Request): immutable.Seq[HttpHeader] = request match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case PutObject | InitiateMultipartUpload => headers[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ServerSideEncryption.AES256(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: KMS => true[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Documentation: http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param keyId amazon resource name in the "arn:aws:kms:my-region:my-account-id:key/my-key-id" format.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param context optional base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class KMS private[headers] (val keyId: String, val context: Option[String]) extends ServerSideEncryption {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headers: immutable.Seq[HttpHeader] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val baseHeaders = RawHeader("x-amz-server-side-encryption", "aws:kms") ::[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("x-amz-server-side-encryption-aws-kms-key-id", keyId) ::[0m
[0m[[0m[0mdebug[0m] [0m[0m    Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val headers = baseHeaders ++ context.map(ctx => RawHeader("x-amz-server-side-encryption-context", ctx)).toSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headersFor(request: S3Request): immutable.Seq[HttpHeader] = request match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case PutObject | InitiateMultipartUpload => headers[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKeyId(keyId: String) = copy(keyId = keyId)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withContext(context: String) = copy(context = Some(context))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      keyId: String = keyId,[0m
[0m[[0m[0mdebug[0m] [0m[0m      context: Option[String] = context[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): KMS = new KMS([0m
[0m[[0m[0mdebug[0m] [0m[0m    keyId = keyId,[0m
[0m[[0m[0mdebug[0m] [0m[0m    context = context[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ServerSideEncryption.KMS(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"keyId=$keyId," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"context=$context" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: KMS =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.keyId, that.keyId) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.context, that.context)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(keyId, context)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Documentation: http://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param key base64-encoded encryption key for Amazon S3 to use to encrypt or decrypt your data.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param md5 optional base64-encoded 128-bit MD5 digest of the encryption key according to RFC 1321.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CustomerKeys private[headers] (val key: String, val md5: Option[String] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends ServerSideEncryption {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headers: immutable.Seq[HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("x-amz-server-side-encryption-customer-algorithm", "AES256") ::[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("x-amz-server-side-encryption-customer-key", key) ::[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("x-amz-server-side-encryption-customer-key-MD5", md5.getOrElse({[0m
[0m[[0m[0mdebug[0m] [0m[0m      val decodedKey = Base64.decode(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m      val md5 = Md5Utils.md5AsBase64(decodedKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m      md5[0m
[0m[[0m[0mdebug[0m] [0m[0m    })) :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] override def headersFor(request: S3Request): immutable.Seq[HttpHeader] = request match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case GetObject | HeadObject | PutObject | InitiateMultipartUpload | UploadPart =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers[0m
[0m[[0m[0mdebug[0m] [0m[0m    case CopyPart =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      val copyHeaders =[0m
[0m[[0m[0mdebug[0m] [0m[0m      RawHeader("x-amz-copy-source-server-side-encryption-customer-algorithm", "AES256") ::[0m
[0m[[0m[0mdebug[0m] [0m[0m      RawHeader("x-amz-copy-source-server-side-encryption-customer-key", key) ::[0m
[0m[[0m[0mdebug[0m] [0m[0m      RawHeader([0m
[0m[[0m[0mdebug[0m] [0m[0m        "x-amz-copy-source-server-side-encryption-customer-key-MD5",[0m
[0m[[0m[0mdebug[0m] [0m[0m        md5.getOrElse({[0m
[0m[[0m[0mdebug[0m] [0m[0m          val decodedKey = Base64.decode(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m          val md5 = Md5Utils.md5AsBase64(decodedKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m          md5[0m
[0m[[0m[0mdebug[0m] [0m[0m        })[0m
[0m[[0m[0mdebug[0m] [0m[0m      ) :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers ++: copyHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKey(key: String) = copy(key = key)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMd5(md5: String) = copy(md5 = Some(md5))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m      md5: Option[String] = md5[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): CustomerKeys = new CustomerKeys([0m
[0m[[0m[0mdebug[0m] [0m[0m    key = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    md5 = md5[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ServerSideEncryption.CustomerKeys(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"key=$key," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"md5=$md5" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: CustomerKeys =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.key, that.key) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.md5, that.md5)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(key, md5)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/headers/StorageClass.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.headers[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.HttpHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.RawHeader[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Documentation: http://docs.aws.amazon.com/AmazonS3/latest/dev/storage-class-intro.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class StorageClass private (val storageClass: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def header: HttpHeader = RawHeader("x-amz-storage-class", storageClass)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject StorageClass {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Standard = new StorageClass("STANDARD")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val InfrequentAccess = new StorageClass("STANDARD_IA")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Glacier = new StorageClass("GLACIER")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val ReducedRedundancy = new StorageClass("REDUCED_REDUNDANCY")[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/headers/CannedAcl.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.headers[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.HttpHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.RawHeader[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Documentation: http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class CannedAcl private (val value: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def header: HttpHeader = RawHeader("x-amz-acl", value)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject CannedAcl {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val AuthenticatedRead = new CannedAcl("authenticated-read")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val AwsExecRead = new CannedAcl("aws-exec-read")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val BucketOwnerFullControl = new CannedAcl("bucket-owner-full-control")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val BucketOwnerRead = new CannedAcl("bucket-owner-read")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Private = new CannedAcl("private")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PublicRead = new CannedAcl("public-read")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val PublicReadWrite = new CannedAcl("public-read-write")[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/S3Headers.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.Objects[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.HttpHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.RawHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.headers.{CannedAcl, ServerSideEncryption, StorageClass}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.impl.S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Seq[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MetaHeaders private (val metaHeaders: Map[String, String]) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def headers: Seq[HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    metaHeaders.toIndexedSeq.map { header =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      RawHeader(s"x-amz-meta-${header._1}", header._2)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMetaHeaders(metaHeaders: Map[String, String]) = new MetaHeaders([0m
[0m[[0m[0mdebug[0m] [0m[0m    metaHeaders = metaHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "MetaHeaders(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"metaHeaders=$metaHeaders," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: S3Headers =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.metaHeaders, that.metaHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(metaHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MetaHeaders {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(metaHeaders: Map[String, String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new MetaHeaders(metaHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(metaHeaders: java.util.Map[String, String]) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    apply(metaHeaders.asScala.toMap)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Container for headers used in s3 uploads like acl, storage class,[0m
[0m[[0m[0mdebug[0m] [0m[0m * metadata, server side encryption or custom headers for more advanced use cases.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class S3Headers private (val cannedAcl: Option[CannedAcl] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               val metaHeaders: Option[MetaHeaders] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               val storageClass: Option[StorageClass] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               val customHeaders: Map[String, String] = Map.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                               val serverSideEncryption: Option[ServerSideEncryption] = None) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] val headers: Seq[HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m  cannedAcl.toIndexedSeq.map(_.header) ++[0m
[0m[[0m[0mdebug[0m] [0m[0m  metaHeaders.toIndexedSeq.flatMap(_.headers) ++[0m
[0m[[0m[0mdebug[0m] [0m[0m  storageClass.toIndexedSeq.map(_.header) ++[0m
[0m[[0m[0mdebug[0m] [0m[0m  customHeaders.map { header =>[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader(header._1, header._2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[s3] def headersFor(request: S3Request) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers ++ serverSideEncryption.toIndexedSeq.flatMap(_.headersFor(request))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCannedAcl(cannedAcl: CannedAcl) = copy(cannedAcl = Some(cannedAcl))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withMetaHeaders(metaHeaders: MetaHeaders) = copy(metaHeaders = Some(metaHeaders))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withStorageClass(storageClass: StorageClass) = copy(storageClass = Some(storageClass))[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withCustomHeaders(customHeaders: Map[String, String]) = copy(customHeaders = customHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withServerSideEncryption(serverSideEncryption: ServerSideEncryption) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    copy(serverSideEncryption = Some(serverSideEncryption))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      cannedAcl: Option[CannedAcl] = cannedAcl,[0m
[0m[[0m[0mdebug[0m] [0m[0m      metaHeaders: Option[MetaHeaders] = metaHeaders,[0m
[0m[[0m[0mdebug[0m] [0m[0m      storageClass: Option[StorageClass] = storageClass,[0m
[0m[[0m[0mdebug[0m] [0m[0m      customHeaders: Map[String, String] = customHeaders,[0m
[0m[[0m[0mdebug[0m] [0m[0m      serverSideEncryption: Option[ServerSideEncryption] = serverSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): S3Headers = new S3Headers([0m
[0m[[0m[0mdebug[0m] [0m[0m    cannedAcl = cannedAcl,[0m
[0m[[0m[0mdebug[0m] [0m[0m    metaHeaders = metaHeaders,[0m
[0m[[0m[0mdebug[0m] [0m[0m    storageClass = storageClass,[0m
[0m[[0m[0mdebug[0m] [0m[0m    customHeaders = customHeaders,[0m
[0m[[0m[0mdebug[0m] [0m[0m    serverSideEncryption = serverSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "S3Headers(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"cannedAcl=$cannedAcl," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"metaHeaders=$metaHeaders," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"storageClass=$storageClass," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"customHeaders=$customHeaders," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"serverSideEncryption=$serverSideEncryption" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: S3Headers =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.cannedAcl, that.cannedAcl) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.metaHeaders, that.metaHeaders) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.storageClass, that.storageClass) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.customHeaders, that.customHeaders) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.serverSideEncryption, that.serverSideEncryption)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(cannedAcl, metaHeaders, storageClass, customHeaders, serverSideEncryption)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Convenience apply methods for creation of canned acl, meta, storage class or custom headers.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3Headers {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply() = new S3Headers()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create() = new S3Headers()[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/S3Attributes.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes.Attribute[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Akka Stream attributes that are used when materializing S3 stream blueprints.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3Attributes {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Settings to use for the S3 stream[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def settings(settings: S3Settings): Attributes = Attributes(S3SettingsValue(settings))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Config path which will be used to resolve required S3 settings[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def settingsPath(path: String): Attributes = Attributes(S3SettingsPath(path))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class S3SettingsPath private (val path: String) extends Attribute[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3SettingsPath {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val Default = S3SettingsPath(S3Settings.ConfigPath)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(path: String) = new S3SettingsPath(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class S3SettingsValue private (val settings: S3Settings) extends Attribute[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3SettingsValue {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(settings: S3Settings) = new S3SettingsValue(settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/scaladsl/S3.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.ByteRange[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, Materializer}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.headers.{CannedAcl, ServerSideEncryption}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.impl._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{RunnableGraph, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Factory of S3 operations.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mobject S3 {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val MinChunkSize: Int = 5242880[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Use this for a low level access to S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param method the [[akka.http.scaladsl.model.HttpMethod HttpMethod]] to use when making the request[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a raw HTTP response from S3[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def request(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m              key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m              method: HttpMethod = HttpMethods.GET,[0m
[0m[[0m[0mdebug[0m] [0m[0m              versionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m              s3Headers: S3Headers = S3Headers()): Source[HttpResponse, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.request(S3Location(bucket, key), method, versionId = versionId, s3Headers = s3Headers.headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the metadata for a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse the server side encryption to use[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] containing an [[scala.Option]] that will be [[scala.None]] in case the object does not exist[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getObjectMetadata([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: Option[ServerSideEncryption] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Option[ObjectMetadata], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.getObjectMetadata(bucket, key, versionId, sse)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param versionId optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] that will emit [[akka.Done]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObject(bucket: String, key: String, versionId: Option[String] = None): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteObject(S3Location(bucket, key), versionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Deletes a S3 Objects which contain given prefix[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param prefix optional s3 objects prefix[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return A [[akka.stream.scaladsl.Source Source]] that will emit [[akka.Done]] when operation is completed[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObjectsByPrefix(bucket: String, prefix: Option[String]): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteObjectsByPrefix(bucket, prefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object, use this for small files and [[multipartUpload]] for bigger ones[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param data a [[Stream]] of [[ByteString]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentLength the number of bytes that will be uploaded (required!)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.scaladsl.Source Source]] containing the [[ObjectMetadata]] of the uploaded S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def putObject(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentLength: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m                s3Headers: S3Headers): Source[ObjectMetadata, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.putObject(S3Location(bucket, key), contentType, data, contentLength, s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Downloads a S3 Object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param range [optional] the [[akka.http.scaladsl.model.headers.ByteRange ByteRange]] you want to download[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sse [optional] the server side encryption used on upload[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The source will emit an empty [[scala.Option Option]] if an object can not be found.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         Otherwise [[scala.Option Option]] will contain a tuple of object's data and metadata.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      range: Option[ByteRange] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: Option[ServerSideEncryption] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Option[(Source[ByteString, NotUsed], ObjectMetadata)], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.download(S3Location(bucket, key), range, versionId, sse)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Will return a source of object metadata for a given bucket with optional prefix using version 2 of the List Bucket API.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This will automatically page through all keys with the given parameters.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * The `alpakka.s3.list-bucket-api-version` can be set to 1 to use the older API version 1[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/v2-RESTBucketGET.html  (version 1 API)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html (version 1 API)[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket Which bucket that you list object metadata for[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param prefix Prefix of the keys you want to list under passed bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.scaladsl.Source Source]] of [[ListBucketResultContents]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listBucket(bucket: String, prefix: Option[String]): Source[ListBucketResultContents, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.listBucket(bucket, prefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object by making multiple requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.scaladsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param metaHeaders any meta-headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param cannedAcl a [[CannedAcl]], defaults to [[CannedAcl.Private]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of the requests sent to S3, minimum [[MinChunkSize]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkingParallelism the number of parallel requests used for the upload, defaults to 4[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.scaladsl.Sink Sink]] that accepts [[ByteString]]'s and materializes to a [[scala.concurrent.Future Future]] of [[MultipartUploadResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m      metaHeaders: MetaHeaders = MetaHeaders(Map()),[0m
[0m[[0m[0mdebug[0m] [0m[0m      cannedAcl: CannedAcl = CannedAcl.Private,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkingParallelism: Int = 4,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: Option[ServerSideEncryption] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, Future[MultipartUploadResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val s3Headers = S3Headers().withCannedAcl(cannedAcl).withMetaHeaders(metaHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .multipartUpload([0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Location(bucket, key),[0m
[0m[[0m[0mdebug[0m] [0m[0m        contentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m        sse.map(s3Headers.withServerSideEncryption).getOrElse(s3Headers),[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkingParallelism[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a S3 Object by making multiple requests[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucket the s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param key the s3 object key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType an optional [[akka.http.scaladsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of the requests sent to S3, minimum [[MinChunkSize]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkingParallelism the number of parallel requests used for the upload, defaults to 4[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a [[akka.stream.scaladsl.Sink Sink]] that accepts [[akka.util.ByteString ByteString]]'s and materializes to a [[scala.concurrent.Future Future]] of [[MultipartUploadResult]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUploadWithHeaders([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkingParallelism: Int = 4,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers = S3Headers()[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, Future[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .multipartUpload([0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Location(bucket, key),[0m
[0m[[0m[0mdebug[0m] [0m[0m        contentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m        s3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkingParallelism[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Copy an S3 object from source bucket to target bucket using multi part copy upload.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceBucket source s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceKey    source s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetBucket target s3 bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param targetKey    target s3 key[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param sourceVersionId optional version id of source object, if the versioning is enabled in source bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param contentType  an optional [[akka.http.scaladsl.model.ContentType ContentType]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param s3Headers any headers you want to add[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkSize the size of the requests sent to S3, minimum [[MinChunkSize]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param chunkingParallelism the number of parallel requests used for the upload, defaults to 4[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return a runnable graph which upon materialization will return a [[scala.concurrent.Future Future ]] containing the results of the copy operation.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy([0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      targetBucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      targetKey: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceVersionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers = S3Headers(),[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkingParallelism: Int = 4[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): RunnableGraph[Future[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream[0m
[0m[[0m[0mdebug[0m] [0m[0m      .multipartCopy([0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Location(sourceBucket, sourceKey),[0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Location(targetBucket, targetKey),[0m
[0m[[0m[0mdebug[0m] [0m[0m        sourceVersionId,[0m
[0m[[0m[0mdebug[0m] [0m[0m        contentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m        s3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkingParallelism[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create new bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[scala.concurrent.Future Future]] with type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucket(bucketName: String)(implicit mat: Materializer, attr: Attributes = Attributes()): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.makeBucket(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Create new bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.scaladsl.Source Source]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucketSource(bucketName: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.makeBucketSource(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketDELETE.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[scala.concurrent.Future Future]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucket(bucketName: String)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                       attributes: Attributes = Attributes()): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteBucket(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Delete bucket with a given name[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketDELETE.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.scaladsl.Source Source]] of type [[Done]] as API doesn't return any additional information[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucketSource(bucketName: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.deleteBucketSource(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   *   Checks whether the bucket exits and user has rights to perform ListBucket operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[scala.concurrent.Future Future]] of type [[BucketAccess]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExists(bucketName: String)(implicit mat: Materializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                              attributes: Attributes = Attributes()): Future[BucketAccess] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.checkIfBucketExists(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   *   Checks whether the bucket exits and user has rights to perform ListBucket operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param bucketName bucket name[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return [[akka.stream.scaladsl.Source Source]] of type [[BucketAccess]][0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExistsSource(bucketName: String): Source[BucketAccess, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    S3Stream.checkIfBucketExistsSource(bucketName)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/MemoryBuffer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{Attributes, FlowShape, Inlet, Outlet}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.{GraphStage, GraphStageLogic, InHandler, OutHandler}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Buffers the complete incoming stream into memory, which can then be read several times afterwards.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The stage waits for the incoming stream to complete. After that, it emits a single Chunk item on its output. The Chunk[0m
[0m[[0m[0mdebug[0m] [0m[0m * contains a `ByteString` source that can be materialized multiple times, and the total size of the file.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param maxSize Maximum size to buffer[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final class MemoryBuffer(maxSize: Int) extends GraphStage[FlowShape[ByteString, Chunk]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in = Inlet[ByteString]("MemoryBuffer.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out = Outlet[Chunk]("MemoryBuffer.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape.of(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(attr: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with InHandler with OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      private var buffer = ByteString.empty[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = if (isClosed(in)) emit() else pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val elem = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (buffer.size + elem.size > maxSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          failStage(new IllegalStateException("Buffer size of " + maxSize + " bytes exceeded."))[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m          buffer ++= elem[0m
[0m[[0m[0mdebug[0m] [0m[0m          pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (isAvailable(out)) emit()[0m
[0m[[0m[0mdebug[0m] [0m[0m        completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def emit(): Unit = emit(out, Chunk(Source.single(buffer), buffer.size), () => completeStage())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/S3Request.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] sealed trait S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object GetObject extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object HeadObject extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object PutObject extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object InitiateMultipartUpload extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object UploadPart extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] case object CopyPart extends S3Request[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/Chunk.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class Chunk(data: Source[ByteString, NotUsed], size: Int)[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/SetupStage.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{Future, Promise}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupSinkStage[T, M](factory: ActorMaterializer => Attributes => Sink[T, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SinkShape[T], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[T]("SetupSinkStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = SinkShape(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subOutlet = new SubSourceOutlet[T]("SetupSinkStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    subOutlet.setHandler(delegateToInlet(() => pull(in), () => cancel(in)))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(in, delegateToSubOutlet(() => grab(in), subOutlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val sink = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = Source.fromGraph(subOutlet.source).runWith(sink.withAttributes(attributes))(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupFlowStage[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[FlowShape[T, U], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val in = Inlet[T]("SetupFlowStage.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[U]("SetupFlowStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[U]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subOutlet = new SubSourceOutlet[T]("SetupFlowStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: U), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    subOutlet.setHandler(delegateToInlet(() => pull(in), () => cancel(in)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(in, delegateToSubOutlet(() => grab(in), subOutlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val flow = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = Source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .fromGraph(subOutlet.source)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .viaMat(flow.withAttributes(attributes))(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate final class SetupSourceStage[T, M](factory: ActorMaterializer => Attributes => Source[T, M])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStageWithMaterializedValue[SourceShape[T], Future[M]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val out = Outlet[T]("SetupSourceStage.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = SourceShape(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogicAndMaterializedValue(inheritedAttributes: Attributes): (GraphStageLogic, Future[M]) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val matPromise = Promise[M][0m
[0m[[0m[0mdebug[0m] [0m[0m    (createStageLogic(matPromise), matPromise.future)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createStageLogic(matPromise: Promise[M]) = new GraphStageLogic(shape) {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import SetupStage._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val subInlet = new SubSinkInlet[T]("SetupSourceStage")[0m
[0m[[0m[0mdebug[0m] [0m[0m    subInlet.setHandler(delegateToOutlet(push(out, _: T), () => complete(out), fail(out, _), subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m    setHandler(out, delegateToSubInlet(subInlet))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def preStart(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val source = factory(actorMaterializer(materializer))(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      val mat = source[0m
[0m[[0m[0mdebug[0m] [0m[0m        .withAttributes(attributes)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .to(Sink.fromGraph(subInlet.sink))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .run()(subFusingMaterializer)[0m
[0m[[0m[0mdebug[0m] [0m[0m      matPromise.success(mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mprivate object SetupStage {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubOutlet[T](grab: () => T, subOutlet: GraphStageLogic#SubSourceOutlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.push(grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subOutlet.fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToOutlet[T](push: T => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          complete: () => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          fail: Throwable => Unit,[0m
[0m[[0m[0mdebug[0m] [0m[0m                          subInlet: GraphStageLogic#SubSinkInlet[T]) = new InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPush(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      push(subInlet.grab())[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      complete()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onUpstreamFailure(ex: Throwable): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      fail(ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToSubInlet[T](subInlet: GraphStageLogic#SubSinkInlet[T]) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      subInlet.cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def delegateToInlet(pull: () => Unit, cancel: () => Unit) = new OutHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onPull(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      pull()[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def onDownstreamFinish(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m      cancel()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def actorMaterializer(mat: Materializer): ActorMaterializer = mat match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case am: ActorMaterializer => am[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => throw new Error("ActorMaterializer required")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object Setup {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def sink[T, M](factory: ActorMaterializer => Attributes => Sink[T, M]): Sink[T, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Sink.fromGraph(new SetupSinkStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def flow[T, U, M](factory: ActorMaterializer => Attributes => Flow[T, U, M]): Flow[T, U, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow.fromGraph(new SetupFlowStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def source[T, M](factory: ActorMaterializer => Attributes => Source[T, M]): Source[T, Future[M]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromGraph(new SetupSourceStage(factory))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/Marshalling.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.URLEncoder[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.Instant[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.marshallers.xml.ScalaXmlSupport[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{ContentTypes, HttpCharsets, MediaTypes, Uri}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.unmarshalling.{FromEntityUnmarshaller, Unmarshaller}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.ListBucketResultContents[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.Try[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.xml.NodeSeq[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object Marshalling {[0m
[0m[[0m[0mdebug[0m] [0m[0m  import ScalaXmlSupport._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val multipartUploadUnmarshaller: FromEntityUnmarshaller[MultipartUpload] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    nodeSeqUnmarshaller(MediaTypes.`application/xml`, ContentTypes.`application/octet-stream`) map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NodeSeq.Empty => throw Unmarshaller.NoContentException[0m
[0m[[0m[0mdebug[0m] [0m[0m      case x =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        MultipartUpload(S3Location((x \ "Bucket").text, (x \ "Key").text), (x \ "UploadId").text)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val completeMultipartUploadResultUnmarshaller: FromEntityUnmarshaller[CompleteMultipartUploadResult] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    nodeSeqUnmarshaller(MediaTypes.`application/xml` withCharset HttpCharsets.`UTF-8`) map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NodeSeq.Empty => throw Unmarshaller.NoContentException[0m
[0m[[0m[0mdebug[0m] [0m[0m      case x =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        CompleteMultipartUploadResult([0m
[0m[[0m[0mdebug[0m] [0m[0m          Try(Uri((x \ "Location").text))[0m
[0m[[0m[0mdebug[0m] [0m[0m            .getOrElse(Uri((x \ "Location").text.split("/").map(s => URLEncoder.encode(s, "utf-8")).mkString("/"))),[0m
[0m[[0m[0mdebug[0m] [0m[0m          (x \ "Bucket").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m          (x \ "Key").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m          (x \ "ETag").text.drop(1).dropRight(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val isTruncated = "IsTruncated"[0m
[0m[[0m[0mdebug[0m] [0m[0m  val apiV2ContinuationToken = "NextContinuationToken"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val listBucketResultUnmarshaller: FromEntityUnmarshaller[ListBucketResult] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    nodeSeqUnmarshaller(MediaTypes.`application/xml` withCharset HttpCharsets.`UTF-8`).map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NodeSeq.Empty => throw Unmarshaller.NoContentException[0m
[0m[[0m[0mdebug[0m] [0m[0m      case x =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val truncated = (x \ isTruncated).text == "true"[0m
[0m[[0m[0mdebug[0m] [0m[0m        val continuation = if (truncated) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          Some(x \ apiV2ContinuationToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .filter(_.nonEmpty)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .orElse((x \\ "Contents" \ "Key").lastOption)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .map(_.text)[0m
[0m[[0m[0mdebug[0m] [0m[0m        } else None[0m
[0m[[0m[0mdebug[0m] [0m[0m        ListBucketResult([0m
[0m[[0m[0mdebug[0m] [0m[0m          truncated,[0m
[0m[[0m[0mdebug[0m] [0m[0m          continuation,[0m
[0m[[0m[0mdebug[0m] [0m[0m          (x \\ "Contents").map { c =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            ListBucketResultContents([0m
[0m[[0m[0mdebug[0m] [0m[0m              (x \ "Name").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m              (c \ "Key").text,[0m
[0m[[0m[0mdebug[0m] [0m[0m              (c \ "ETag").text.drop(1).dropRight(1),[0m
[0m[[0m[0mdebug[0m] [0m[0m              (c \ "Size").text.toLong,[0m
[0m[[0m[0mdebug[0m] [0m[0m              Instant.parse((c \ "LastModified").text),[0m
[0m[[0m[0mdebug[0m] [0m[0m              (c \ "StorageClass").text[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  implicit val copyPartResultUnmarshaller: FromEntityUnmarshaller[CopyPartResult] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    nodeSeqUnmarshaller(MediaTypes.`application/xml`, ContentTypes.`application/octet-stream`) map {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case NodeSeq.Empty => throw Unmarshaller.NoContentException[0m
[0m[[0m[0mdebug[0m] [0m[0m      case x =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val lastModified = Instant.parse((x \ "LastModified").text)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val eTag = (x \ "ETag").text[0m
[0m[[0m[0mdebug[0m] [0m[0m        CopyPartResult(lastModified, eTag.dropRight(1).drop(1))[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/DiskBuffer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.io.{File, FileOutputStream}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.BufferOverflowException[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.Files[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.atomic.AtomicInteger[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.ActorAttributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.FlowShape[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Inlet[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Outlet[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.FileIO[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.GraphStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.GraphStageLogic[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.InHandler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.OutHandler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.file.Path[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Buffers the complete incoming stream into a file, which can then be read several times afterwards.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * The stage waits for the incoming stream to complete. After that, it emits a single Chunk item on its output. The Chunk[0m
[0m[[0m[0mdebug[0m] [0m[0m * contains a bytestream source that can be materialized multiple times, and the total size of the file.[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param maxMaterializations Number of expected materializations for the completed chunk. After this, the temp file is deleted.[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param maxSize Maximum size on disk to buffer[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final class DiskBuffer(maxMaterializations: Int, maxSize: Int, tempPath: Option[Path])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends GraphStage[FlowShape[ByteString, Chunk]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(maxMaterializations > 0, "maxMaterializations should be at least 1")[0m
[0m[[0m[0mdebug[0m] [0m[0m  require(maxSize > 0, "maximumSize should be at least 1")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val in = Inlet[ByteString]("DiskBuffer.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m  val out = Outlet[Chunk]("DiskBuffer.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m  override val shape = FlowShape.of(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def initialAttributes =[0m
[0m[[0m[0mdebug[0m] [0m[0m    super.initialAttributes and Attributes.name("DiskBuffer") and ActorAttributes.IODispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def createLogic(attr: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new GraphStageLogic(shape) with OutHandler with InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val path: File = tempPath[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map(dir => Files.createTempFile(dir, "s3-buffer-", ".bin"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .getOrElse(Files.createTempFile("s3-buffer-", ".bin"))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .toFile[0m
[0m[[0m[0mdebug[0m] [0m[0m      path.deleteOnExit()[0m
[0m[[0m[0mdebug[0m] [0m[0m      var length = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m      val pathOut = new FileOutputStream(path)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPull(): Unit = if (isClosed(in)) emit() else pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val elem = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m        length += elem.size[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (length > maxSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw new BufferOverflowException()[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        pathOut.write(elem.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m        pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def onUpstreamFinish(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (isAvailable(out)) emit()[0m
[0m[[0m[0mdebug[0m] [0m[0m        completeStage()[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      override def postStop(): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m        // close stream even if we didn't emit[0m
[0m[[0m[0mdebug[0m] [0m[0m        try { pathOut.close() } catch { case x: Throwable => () }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      private def emit(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m        pathOut.close()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val deleteCounter = new AtomicInteger(maxMaterializations)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val src = FileIO.fromPath(path.toPath, 65536).mapMaterializedValue { f =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (deleteCounter.decrementAndGet() <= 0)[0m
[0m[[0m[0mdebug[0m] [0m[0m            f.onComplete { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              path.delete()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            }(ExecutionContexts.sameThreadExecutionContext)[0m
[0m[[0m[0mdebug[0m] [0m[0m          NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        emit(out, Chunk(src, length), () => completeStage())[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/SplitAfterSize.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.SubFlow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.GraphStage[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.FlowShape[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Inlet[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Outlet[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.GraphStageLogic[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.OutHandler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.stage.InHandler[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.annotation.tailrec[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * Splits up a byte stream source into sub-flows of a minimum size. Does not attempt to create chunks of an exact size.[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object SplitAfterSize {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[I, M](minChunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                  maxChunkSize: Int)(in: Flow[I, ByteString, M]): SubFlow[ByteString, M, in.Repr, in.Closed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    require(minChunkSize < maxChunkSize, "the min chunk size must be smaller than the max chunk size")[0m
[0m[[0m[0mdebug[0m] [0m[0m    in.via(insertMarkers(minChunkSize, maxChunkSize)).splitWhen(_ == NewStream).collect { case bs: ByteString => bs }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private case object NewStream[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def insertMarkers(minChunkSize: Long, maxChunkSize: Int) = new GraphStage[FlowShape[ByteString, Any]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val in = Inlet[ByteString]("SplitAfterSize.in")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val out = Outlet[Any]("SplitAfterSize.out")[0m
[0m[[0m[0mdebug[0m] [0m[0m    override val shape = FlowShape.of(in, out)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def createLogic(inheritedAttributes: Attributes): GraphStageLogic =[0m
[0m[[0m[0mdebug[0m] [0m[0m      new GraphStageLogic(shape) with OutHandler with InHandler {[0m
[0m[[0m[0mdebug[0m] [0m[0m        var count: Int = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPull(): Unit = pull(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        override def onPush(): Unit = {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val elem = grab(in)[0m
[0m[[0m[0mdebug[0m] [0m[0m          count += elem.size[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (count > maxChunkSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            splitElement(elem, elem.size - (count - maxChunkSize))[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else if (count >= minChunkSize) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            count = 0[0m
[0m[[0m[0mdebug[0m] [0m[0m            emitMultiple(out, elem :: NewStream :: Nil)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else emit(out, elem)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        @tailrec private def splitElement(elem: ByteString, splitPos: Int): Unit =[0m
[0m[[0m[0mdebug[0m] [0m[0m          if (elem.size > splitPos) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            val (part1, rest) = elem.splitAt(splitPos)[0m
[0m[[0m[0mdebug[0m] [0m[0m            emitMultiple(out, part1 :: NewStream :: Nil)[0m
[0m[[0m[0mdebug[0m] [0m[0m            splitElement(rest, maxChunkSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m          } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m            count = elem.size[0m
[0m[[0m[0mdebug[0m] [0m[0m            emit(out, elem)[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        setHandlers(in, out, this)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/auth/package.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.security.MessageDigest[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage object auth {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val Digits = "0123456789abcdef".toCharArray()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[impl] def encodeHex(bytes: Array[Byte]): String = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val length = bytes.length[0m
[0m[[0m[0mdebug[0m] [0m[0m    val out = new Array[Char](length * 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m    for (i <- 0 to length - 1) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val b = bytes(i)[0m
[0m[[0m[0mdebug[0m] [0m[0m      out(i * 2) = Digits((b >> 4) & 0xF)[0m
[0m[[0m[0mdebug[0m] [0m[0m      out(i * 2 + 1) = Digits(b & 0xF)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    new String(out)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[impl] def encodeHex(bytes: ByteString): String = encodeHex(bytes.toArray)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[impl] def digest(algorithm: String = "SHA-256"): Flow[ByteString, ByteString, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[ByteString][0m
[0m[[0m[0mdebug[0m] [0m[0m      .fold(MessageDigest.getInstance(algorithm)) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (digest, bytes) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          digest.update(bytes.asByteBuffer)[0m
[0m[[0m[0mdebug[0m] [0m[0m          digest[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(d => ByteString(d.digest()))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/auth/SigningKey.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl.auth[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.{LocalDate, ZonedDateTime}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.format.DateTimeFormatter[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.crypto.Mac[0m
[0m[[0m[0mdebug[0m] [0m[0mimport javax.crypto.spec.SecretKeySpec[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.amazonaws.auth.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m  AWSCredentials => AmzAWSCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m  AWSSessionCredentials => AmzAWSSessionCredentials[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class CredentialScope(date: LocalDate, awsRegion: String, awsService: String) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val formattedDate: String = date.format(DateTimeFormatter.BASIC_ISO_DATE)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def scopeString = s"$formattedDate/$awsRegion/$awsService/aws4_request"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class SigningKey(requestDate: ZonedDateTime,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                       credProvider: AWSCredentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                       scope: CredentialScope,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                       algorithm: String = "HmacSHA256") {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val credentials: AmzAWSCredentials = credProvider.getCredentials[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val rawKey = new SecretKeySpec(s"AWS4${credentials.getAWSSecretKey}".getBytes, algorithm)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val sessionToken: Option[String] = credentials match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case c: AmzAWSSessionCredentials => Some(c.getSessionToken)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => None[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def signature(message: Array[Byte]): Array[Byte] = signWithKey(key, message)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def hexEncodedSignature(message: Array[Byte]): String = encodeHex(signature(message))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def credentialString: String = s"${credentials.getAWSAccessKeyId}/${scope.scopeString}"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val key: SecretKeySpec =[0m
[0m[[0m[0mdebug[0m] [0m[0m    wrapSignature(dateRegionServiceKey, "aws4_request".getBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val dateRegionServiceKey: SecretKeySpec =[0m
[0m[[0m[0mdebug[0m] [0m[0m    wrapSignature(dateRegionKey, scope.awsService.getBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val dateRegionKey: SecretKeySpec =[0m
[0m[[0m[0mdebug[0m] [0m[0m    wrapSignature(dateKey, scope.awsRegion.getBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val dateKey: SecretKeySpec =[0m
[0m[[0m[0mdebug[0m] [0m[0m    wrapSignature(rawKey, scope.formattedDate.getBytes)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def wrapSignature(signature: SecretKeySpec, message: Array[Byte]): SecretKeySpec =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new SecretKeySpec(signWithKey(signature, message), algorithm)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def signWithKey(key: SecretKeySpec, message: Array[Byte]): Array[Byte] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val mac = Mac.getInstance(algorithm)[0m
[0m[[0m[0mdebug[0m] [0m[0m    mac.init(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m    mac.doFinal(message)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/auth/CanonicalRequest.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl.auth[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.Uri.{Path, Query}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{HttpHeader, HttpRequest}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m// Documentation: http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class CanonicalRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m    method: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    uri: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    queryString: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    headerString: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    signedHeaders: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    hashedPayload: String[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def canonicalString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"$method\n$uri\n$queryString\n$headerString\n\n$signedHeaders\n$hashedPayload"[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object CanonicalRequest {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def from(request: HttpRequest): CanonicalRequest = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val hashedBody =[0m
[0m[[0m[0mdebug[0m] [0m[0m      request.headers[0m
[0m[[0m[0mdebug[0m] [0m[0m        .collectFirst { case header if header.is("x-amz-content-sha256") => header.value }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .getOrElse("")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    CanonicalRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m      request.method.value,[0m
[0m[[0m[0mdebug[0m] [0m[0m      pathEncode(request.uri.path),[0m
[0m[[0m[0mdebug[0m] [0m[0m      canonicalQueryString(request.uri.query()),[0m
[0m[[0m[0mdebug[0m] [0m[0m      canonicalHeaderString(request.headers),[0m
[0m[[0m[0mdebug[0m] [0m[0m      signedHeadersString(request.headers),[0m
[0m[[0m[0mdebug[0m] [0m[0m      hashedBody[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // https://tools.ietf.org/html/rfc3986#section-2.3[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isUnreservedCharacter(c: Char): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    c.isLetterOrDigit || c == '-' || c == '.' || c == '_' || c == '~'[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // https://tools.ietf.org/html/rfc3986#section-2.2[0m
[0m[[0m[0mdebug[0m] [0m[0m  // Excludes "/" as it is an exception according to spec.[0m
[0m[[0m[0mdebug[0m] [0m[0m  val reservedCharacters: String = ":?#[]@!$&'()*+,;="[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def isReservedCharacter(c: Char): Boolean =[0m
[0m[[0m[0mdebug[0m] [0m[0m    reservedCharacters.contains(c)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def canonicalQueryString(query: Query): String = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def uriEncode(s: String): String = s.flatMap {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case c if isUnreservedCharacter(c) => c.toString[0m
[0m[[0m[0mdebug[0m] [0m[0m      case c => "%" + c.toHexString.toUpperCase[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    query[0m
[0m[[0m[0mdebug[0m] [0m[0m      .sortBy { case (name, _) => name }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { case (name, value) => s"${uriEncode(name)}=${uriEncode(value)}" }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mkString("&")[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def canonicalHeaderString(headers: Seq[HttpHeader]): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers[0m
[0m[[0m[0mdebug[0m] [0m[0m      .groupBy(_.lowercaseName)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (name, headers) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          name -> headers[0m
[0m[[0m[0mdebug[0m] [0m[0m            .map(header => header.value.replaceAll("\\s+", " ").trim)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .mkString(",")[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toList[0m
[0m[[0m[0mdebug[0m] [0m[0m      .sortBy { case (name, _) => name }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { case (name, value) => s"$name:$value" }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mkString("\n")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def signedHeadersString(headers: Seq[HttpHeader]): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    headers.map(_.lowercaseName).distinct.sorted.mkString(";")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def pathEncode(path: Path): String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (path.isEmpty) "/"[0m
[0m[[0m[0mdebug[0m] [0m[0m    else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      path.toString.flatMap {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case c if isReservedCharacter(c) => "%" + c.toHexString.toUpperCase[0m
[0m[[0m[0mdebug[0m] [0m[0m        case c => c.toString[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/auth/Signer.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl.auth[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.security.MessageDigest[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.format.DateTimeFormatter[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.ZonedDateTime[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.RawHeader[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{HttpHeader, HttpRequest}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object Signer {[0m
[0m[[0m[0mdebug[0m] [0m[0m  private val dateFormatter = DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmssX")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def signedRequest(request: HttpRequest, key: SigningKey): Source[HttpRequest, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val hashedBody = request.entity.dataBytes.via(digest()).map(hash => encodeHex(hash.toArray))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    hashedBody[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map { hb =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val headersToAdd = Vector(RawHeader("x-amz-date", key.requestDate.format(dateFormatter)),[0m
[0m[[0m[0mdebug[0m] [0m[0m                                  RawHeader("x-amz-content-sha256", hb)) ++ sessionHeader(key)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val reqWithHeaders = request.withHeaders(request.headers ++ headersToAdd)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val cr = CanonicalRequest.from(reqWithHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m        val authHeader = authorizationHeader("AWS4-HMAC-SHA256", key, key.requestDate, cr)[0m
[0m[[0m[0mdebug[0m] [0m[0m        reqWithHeaders.withHeaders(reqWithHeaders.headers :+ authHeader)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def sessionHeader(key: SigningKey): Option[HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    key.sessionToken.map(RawHeader("X-Amz-Security-Token", _))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def authorizationHeader(algorithm: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        key: SigningKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        requestDate: ZonedDateTime,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        canonicalRequest: CanonicalRequest): HttpHeader =[0m
[0m[[0m[0mdebug[0m] [0m[0m    RawHeader("Authorization", authorizationString(algorithm, key, requestDate, canonicalRequest))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def authorizationString(algorithm: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        key: SigningKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        requestDate: ZonedDateTime,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                        canonicalRequest: CanonicalRequest): String = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sign = key.hexEncodedSignature(stringToSign(algorithm, key, requestDate, canonicalRequest).getBytes())[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"$algorithm Credential=${key.credentialString}, SignedHeaders=${canonicalRequest.signedHeaders}, Signature=$sign"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def stringToSign(algorithm: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   signingKey: SigningKey,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   requestDate: ZonedDateTime,[0m
[0m[[0m[0mdebug[0m] [0m[0m                   canonicalRequest: CanonicalRequest): String = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val digest = MessageDigest.getInstance("SHA-256")[0m
[0m[[0m[0mdebug[0m] [0m[0m    val hashedRequest = encodeHex(digest.digest(canonicalRequest.canonicalString.getBytes()))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val date = requestDate.format(dateFormatter)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val scope = signingKey.scope.scopeString[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"$algorithm\n$date\n$scope\n$hashedRequest"[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/S3Stream.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.InetSocketAddress[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.time.{Instant, ZoneOffset, ZonedDateTime}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.actor.ActorSystem[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.dispatch.ExecutionContexts[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Seq[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.util.{Failure, Success}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.{ClientTransport, Http}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.StatusCodes.{NoContent, NotFound, OK}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  `Content-Length`,[0m
[0m[[0m[0mdebug[0m] [0m[0m  `Content-Type`,[0m
[0m[[0m[0mdebug[0m] [0m[0m  BasicHttpCredentials,[0m
[0m[[0m[0mdebug[0m] [0m[0m  ByteRange,[0m
[0m[[0m[0mdebug[0m] [0m[0m  CustomHeader[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{headers => http, _}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.settings.{ClientConnectionSettings, ConnectionPoolSettings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.BucketAccess.{AccessDenied, AccessGranted, NotExists}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.{ActorMaterializer, Attributes, Materializer}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.impl.auth.{CredentialScope, Signer, SigningKey}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.headers.ServerSideEncryption[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Keep, RunnableGraph, Sink, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] final case class S3Location(bucket: String, key: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class MultipartUpload(s3Location: S3Location, uploadId: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] sealed trait UploadPartResponse {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload: MultipartUpload[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def index: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class SuccessfulUploadPart(multipartUpload: MultipartUpload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                 index: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                 etag: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends UploadPartResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class FailedUploadPart(multipartUpload: MultipartUpload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             index: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             exception: Throwable)[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends UploadPartResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class FailedUpload(reasons: Seq[Throwable])[0m
[0m[[0m[0mdebug[0m] [0m[0m    extends Exception(reasons.map(_.getMessage).mkString(", "))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class CompleteMultipartUploadResult(location: Uri,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                          bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                          key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                          etag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                                          versionId: Option[String] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class ListBucketResult(isTruncated: Boolean,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             continuationToken: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                             contents: Seq[ListBucketResultContents])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class CopyPartResult(lastModified: Instant, eTag: String)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class CopyPartition(partNumber: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          sourceLocation: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          range: Option[ByteRange.Slice] = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] final case class MultipartCopy(multipartUpload: MultipartUpload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                                          copyPartition: CopyPartition)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[s3] object S3Stream {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  import HttpRequests._[0m
[0m[[0m[0mdebug[0m] [0m[0m  import Marshalling._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val MinChunkSize: Int = 5 * 1024 * 1024 //in bytes[0m
[0m[[0m[0mdebug[0m] [0m[0m  val MaxChunkSize: Int = 10 * 1024 * 1024 //in bytes[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  // def because tokens can expire[0m
[0m[[0m[0mdebug[0m] [0m[0m  def signingKey(implicit settings: S3Settings) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val requestDate = ZonedDateTime.now(ZoneOffset.UTC)[0m
[0m[[0m[0mdebug[0m] [0m[0m    SigningKey([0m
[0m[[0m[0mdebug[0m] [0m[0m      requestDate,[0m
[0m[[0m[0mdebug[0m] [0m[0m      settings.credentialsProvider,[0m
[0m[[0m[0mdebug[0m] [0m[0m      CredentialScope(requestDate.toLocalDate, settings.s3RegionProvider.getRegion, "s3")[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def download([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      range: Option[ByteRange],[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: Option[ServerSideEncryption][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[Option[(Source[ByteString, NotUsed], ObjectMetadata)], NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val s3Headers = sse.toIndexedSeq.flatMap(_.headersFor(GetObject))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup.source { implicit mat => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      request(s3Location, rangeOption = range, versionId = versionId, s3Headers = s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map(response => response.withEntity(response.entity.withoutSizeLimit))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mapAsync(parallelism = 1)(entityForSuccess)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (entity, headers) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Option((entity.dataBytes.mapMaterializedValue(_ => NotUsed), computeMetaData(headers, entity)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .recover[Option[(Source[ByteString, NotUsed], ObjectMetadata)]] {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case e: S3Exception if e.code == "NoSuchKey" => None[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }.mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listBucket(bucket: String, prefix: Option[String] = None): Source[ListBucketResultContents, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    sealed trait ListBucketState[0m
[0m[[0m[0mdebug[0m] [0m[0m    case object Starting extends ListBucketState[0m
[0m[[0m[0mdebug[0m] [0m[0m    case class Running(continuationToken: String) extends ListBucketState[0m
[0m[[0m[0mdebug[0m] [0m[0m    case object Finished extends ListBucketState[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    def listBucketCall([0m
[0m[[0m[0mdebug[0m] [0m[0m        token: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m    )(implicit mat: ActorMaterializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m      attr: Attributes): Future[Option[(ListBucketState, Seq[ListBucketResultContents])]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      signAndGetAs[ListBucketResult](HttpRequests.listBucket(bucket, prefix, token))[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map { (res: ListBucketResult) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          Some([0m
[0m[[0m[0mdebug[0m] [0m[0m            res.continuationToken[0m
[0m[[0m[0mdebug[0m] [0m[0m              .fold[(ListBucketState, Seq[ListBucketResultContents])]((Finished, res.contents))([0m
[0m[[0m[0mdebug[0m] [0m[0m                t => (Running(t), res.contents)[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Source[0m
[0m[[0m[0mdebug[0m] [0m[0m          .unfoldAsync[ListBucketState, Seq[ListBucketResultContents]](Starting) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Finished => Future.successful(None)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Starting => listBucketCall(None)[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Running(token) => listBucketCall(Some(token))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getObjectMetadata(bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        versionId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        sse: Option[ServerSideEncryption]): Source[Option[ObjectMetadata], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { implicit mat => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        val s3Headers = sse.toIndexedSeq.flatMap(_.headersFor(HeadObject))[0m
[0m[[0m[0mdebug[0m] [0m[0m        request(S3Location(bucket, key), HttpMethods.HEAD, versionId = versionId, s3Headers = s3Headers).flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(OK, headers, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m              entity.withoutSizeLimit().discardBytes().future().map { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Some(computeMetaData(headers, entity))[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(NotFound, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture(entity.discardBytes().future().map(_ => None))[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObject(s3Location: S3Location, versionId: Option[String]): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { implicit mat => _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        request(s3Location, HttpMethods.DELETE, versionId = versionId).flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(NoContent, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture(entity.discardBytes().future().map(_ => Done))[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteObjectsByPrefix(bucket: String, prefix: Option[String]): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    listBucket(bucket, prefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMapConcat([0m
[0m[[0m[0mdebug[0m] [0m[0m        listBucketResultContents => deleteObject(S3Location(bucket, listBucketResultContents.key), versionId = None)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def putObject(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                data: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                contentLength: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m                s3Headers: S3Headers): Source[ObjectMetadata, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // TODO can we take in a Source[ByteString, NotUsed] without forcing chunking[0m
[0m[[0m[0mdebug[0m] [0m[0m    // chunked requests are causing S3 to think this is a multipart upload[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val headers = s3Headers.headersFor(PutObject)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val req = uploadRequest(s3Location, data, contentLength, contentType, headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        signAndRequest(req)[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case HttpResponse(OK, h, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m                entity.discardBytes().future().map { _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  ObjectMetadata(h :+ `Content-Length`(entity.contentLengthOption.getOrElse(0)))[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m                Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def request(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m              method: HttpMethod = HttpMethods.GET,[0m
[0m[[0m[0mdebug[0m] [0m[0m              rangeOption: Option[ByteRange] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m              versionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m              s3Headers: Seq[HttpHeader] = Seq.empty): Source[HttpResponse, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m        signAndRequest(requestHeaders(getDownloadRequest(s3Location, method, s3Headers, versionId), rangeOption))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def requestHeaders(downloadRequest: HttpRequest, rangeOption: Option[ByteRange]): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    rangeOption match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(range) => downloadRequest.addHeader(http.Range(range))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case _ => downloadRequest[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucketSource(bucket: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketManagementRequest[Done]([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket = bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m      method = HttpMethods.PUT,[0m
[0m[[0m[0mdebug[0m] [0m[0m      process = processBucketLifecycleResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def makeBucket(bucket: String)(implicit mat: Materializer, attr: Attributes): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    makeBucketSource(bucket).withAttributes(attr).runWith(Sink.ignore)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucketSource(bucket: String): Source[Done, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketManagementRequest[Done]([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket = bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m      method = HttpMethods.DELETE,[0m
[0m[[0m[0mdebug[0m] [0m[0m      process = processBucketLifecycleResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteBucket(bucket: String)(implicit mat: Materializer, attr: Attributes): Future[Done] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteBucketSource(bucket).withAttributes(attr).runWith(Sink.ignore)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExistsSource(bucketName: String): Source[BucketAccess, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketManagementRequest[BucketAccess]([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket = bucketName,[0m
[0m[[0m[0mdebug[0m] [0m[0m      method = HttpMethods.HEAD,[0m
[0m[[0m[0mdebug[0m] [0m[0m      process = processCheckIfExistsResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def checkIfBucketExists(bucket: String)(implicit mat: Materializer, attr: Attributes): Future[BucketAccess] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    checkIfBucketExistsSource(bucket).withAttributes(attr).runWith(Sink.head)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def bucketManagementRequest[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      method: HttpMethod,[0m
[0m[[0m[0mdebug[0m] [0m[0m      process: (HttpResponse, Materializer) => Future[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Source[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys: ActorSystem = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf: S3Settings = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val location = S3Location(bucket = bucket, key = "")[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        signAndRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m          requestHeaders([0m
[0m[[0m[0mdebug[0m] [0m[0m            HttpRequests.bucketManagementRequest(location, method),[0m
[0m[[0m[0mdebug[0m] [0m[0m            None[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m        ).mapAsync(1) { response =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          process(response, mat)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def processBucketLifecycleResponse(response: HttpResponse, materializer: Materializer): Future[Done] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import materializer.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val mat: Materializer = materializer[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    response match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case HttpResponse(status, _, entity, _) if status.isSuccess() =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        entity.discardBytes().future()[0m
[0m[[0m[0mdebug[0m] [0m[0m      case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def processCheckIfExistsResponse(response: HttpResponse, materializer: Materializer): Future[BucketAccess] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import materializer.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val mat: Materializer = materializer[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    response match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case code @ HttpResponse(StatusCodes.NotFound | StatusCodes.Forbidden | StatusCodes.OK, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        entity[0m
[0m[[0m[0mdebug[0m] [0m[0m          .discardBytes()[0m
[0m[[0m[0mdebug[0m] [0m[0m          .future()[0m
[0m[[0m[0mdebug[0m] [0m[0m          .map([0m
[0m[[0m[0mdebug[0m] [0m[0m            _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              code.status match {[0m
[0m[[0m[0mdebug[0m] [0m[0m                case StatusCodes.NotFound => NotExists[0m
[0m[[0m[0mdebug[0m] [0m[0m                case StatusCodes.Forbidden => AccessDenied[0m
[0m[[0m[0mdebug[0m] [0m[0m                case StatusCodes.OK => AccessGranted[0m
[0m[[0m[0mdebug[0m] [0m[0m                case other => throw new IllegalArgumentException(s"received status $other")[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          )[0m
[0m[[0m[0mdebug[0m] [0m[0m      case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Uploads a stream of ByteStrings to a specified location as a multipart upload.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartUpload([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkingParallelism: Int = 4[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[ByteString, Future[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    chunkAndRequest(s3Location, contentType, s3Headers, chunkSize)(chunkingParallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(completionSink(s3Location, s3Headers.serverSideEncryption))(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def initiateMultipartUpload(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      s3Headers: Seq[HttpHeader]): Source[MultipartUpload, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        val req = initiateMultipartUploadRequest(s3Location, contentType, s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        signAndRequest(req).flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(status, _, entity, _) if status.isSuccess() =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture(Unmarshal(entity).to[MultipartUpload])[0m
[0m[[0m[0mdebug[0m] [0m[0m          case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Source.fromFuture {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def multipartCopy([0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceLocation: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      targetLocation: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceVersionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType = ContentTypes.`application/octet-stream`,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int = MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkingParallelism: Int = 4[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): RunnableGraph[Future[MultipartUploadResult]] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // Pre step get source meta to get content length (size of the object)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val eventualMaybeObjectSize =[0m
[0m[[0m[0mdebug[0m] [0m[0m      getObjectMetadata(sourceLocation.bucket, sourceLocation.key, sourceVersionId, s3Headers.serverSideEncryption)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map(_.map(_.contentLength))[0m
[0m[[0m[0mdebug[0m] [0m[0m    val eventualPartitions =[0m
[0m[[0m[0mdebug[0m] [0m[0m      eventualMaybeObjectSize.map(_.map(createPartitions(chunkSize, sourceLocation)).getOrElse(Nil))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // Multipart copy upload requests (except for the completion api) are created here.[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  The initial copy upload request gets executed within this function as well.[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  The individual copy upload part requests are created.[0m
[0m[[0m[0mdebug[0m] [0m[0m    val copyRequests =[0m
[0m[[0m[0mdebug[0m] [0m[0m      createCopyRequests(targetLocation, sourceVersionId, contentType, s3Headers, eventualPartitions)([0m
[0m[[0m[0mdebug[0m] [0m[0m        chunkingParallelism[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // The individual copy upload part requests are processed here[0m
[0m[[0m[0mdebug[0m] [0m[0m    processUploadCopyPartRequests(copyRequests)(chunkingParallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .toMat(completionSink(targetLocation, s3Headers.serverSideEncryption))(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def computeMetaData(headers: Seq[HttpHeader], entity: ResponseEntity): ObjectMetadata =[0m
[0m[[0m[0mdebug[0m] [0m[0m    ObjectMetadata([0m
[0m[[0m[0mdebug[0m] [0m[0m      headers ++[0m
[0m[[0m[0mdebug[0m] [0m[0m      Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m        `Content-Length`(entity.contentLengthOption.getOrElse(0)),[0m
[0m[[0m[0mdebug[0m] [0m[0m        `Content-Type`(entity.contentType),[0m
[0m[[0m[0mdebug[0m] [0m[0m        CustomContentTypeHeader(entity.contentType)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  //`Content-Type` header is by design not accessible as header. So need to have a custom[0m
[0m[[0m[0mdebug[0m] [0m[0m  //header implementation to expose that[0m
[0m[[0m[0mdebug[0m] [0m[0m  private case class CustomContentTypeHeader(contentType: ContentType) extends CustomHeader {[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def name(): String = "Content-Type"[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def value(): String = contentType.value[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def renderInRequests(): Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m    override def renderInResponses(): Boolean = true[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def completeMultipartUpload(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      parts: Seq[SuccessfulUploadPart],[0m
[0m[[0m[0mdebug[0m] [0m[0m                                      sse: Option[ServerSideEncryption])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit mat: ActorMaterializer,[0m
[0m[[0m[0mdebug[0m] [0m[0m      attr: Attributes[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[CompleteMultipartUploadResult] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    def populateResult(result: CompleteMultipartUploadResult,[0m
[0m[[0m[0mdebug[0m] [0m[0m                       headers: Seq[HttpHeader]): CompleteMultipartUploadResult = {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val versionId = headers.find(_.lowercaseName() == "x-amz-version-id").map(_.value())[0m
[0m[[0m[0mdebug[0m] [0m[0m      result.copy(versionId = versionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val headers = sse.toIndexedSeq.flatMap(_.headersFor(UploadPart))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source[0m
[0m[[0m[0mdebug[0m] [0m[0m      .fromFuture([0m
[0m[[0m[0mdebug[0m] [0m[0m        completeMultipartUploadRequest(parts.head.multipartUpload, parts.map(p => p.index -> p.etag), headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMapConcat(signAndGetAs[CompleteMultipartUploadResult](_, populateResult(_, _)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .runWith(Sink.head)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Initiates a multipart upload. Returns a source of the initiated upload with upload part indicess[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def initiateUpload(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                             s3Headers: Seq[HttpHeader]): Source[(MultipartUpload, Int), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source[0m
[0m[[0m[0mdebug[0m] [0m[0m      .single(s3Location)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMapConcat(initiateMultipartUpload(_, contentType, s3Headers))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapConcat(r => Stream.continually(r))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .zip(Source.fromIterator(() => Iterator.from(1)))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val atLeastOneByteString = Flow[ByteString].orElse(Source.single(ByteString.empty))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createRequests([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m      parallelism: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[ByteString, (HttpRequest, (MultipartUpload, Int)), NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    assert([0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize >= MinChunkSize,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s"Chunk size must be at least 5 MB = $MinChunkSize bytes (was $chunkSize bytes). See http://docs.aws.amazon.com/AmazonS3/latest/API/mpUploadUploadPart.html"[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // First step of the multi part upload process is made.[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  The response is then used to construct the subsequent individual upload part requests[0m
[0m[[0m[0mdebug[0m] [0m[0m    val requestInfo: Source[(MultipartUpload, Int), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      initiateUpload(s3Location, contentType, s3Headers.headersFor(InitiateMultipartUpload))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val headers = s3Headers.serverSideEncryption.toIndexedSeq.flatMap(_.headersFor(UploadPart))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        SplitAfterSize(chunkSize, MaxChunkSize)(atLeastOneByteString)[0m
[0m[[0m[0mdebug[0m] [0m[0m          .via(getChunkBuffer(chunkSize)) //creates the chunks[0m
[0m[[0m[0mdebug[0m] [0m[0m          .concatSubstreams[0m
[0m[[0m[0mdebug[0m] [0m[0m          .zipWith(requestInfo) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (chunkedPayload, (uploadInfo, chunkIndex)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              //each of the payload requests are created[0m
[0m[[0m[0mdebug[0m] [0m[0m              val partRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m                uploadPartRequest(uploadInfo, chunkIndex, chunkedPayload.data, chunkedPayload.size, headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m              (partRequest, (uploadInfo, chunkIndex))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMapConcat { case (req, info) => Signer.signedRequest(req, signingKey).zip(Source.single(info)) }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def getChunkBuffer(chunkSize: Int)(implicit settings: S3Settings) = settings.bufferType match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case MemoryBufferType =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      new MemoryBuffer(chunkSize * 2)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case d: DiskBufferType =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      new DiskBuffer(2, chunkSize * 2, d.path)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def poolSettings(implicit settings: S3Settings, system: ActorSystem) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    settings.forwardProxy.map(proxy => {[0m
[0m[[0m[0mdebug[0m] [0m[0m      val address = InetSocketAddress.createUnresolved(proxy.host, proxy.port)[0m
[0m[[0m[0mdebug[0m] [0m[0m      val transport = proxy.credentials.fold(ClientTransport.httpsProxy(address))([0m
[0m[[0m[0mdebug[0m] [0m[0m        c => ClientTransport.httpsProxy(address, BasicHttpCredentials(c.username, c.password))[0m
[0m[[0m[0mdebug[0m] [0m[0m      )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      ConnectionPoolSettings(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .withConnectionSettings([0m
[0m[[0m[0mdebug[0m] [0m[0m          ClientConnectionSettings(system)[0m
[0m[[0m[0mdebug[0m] [0m[0m            .withTransport(transport)[0m
[0m[[0m[0mdebug[0m] [0m[0m        )[0m
[0m[[0m[0mdebug[0m] [0m[0m    })[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def singleRequest(req: HttpRequest)(implicit settings: S3Settings, system: ActorSystem) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    poolSettings.fold(Http().singleRequest(req))(s => Http().singleRequest(req, settings = s))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def superPool[T](implicit settings: S3Settings, sys: ActorSystem) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    poolSettings.fold(Http().superPool[T]())(s => Http().superPool[T](settings = s))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def chunkAndRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      chunkSize: Int[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(parallelism: Int): Flow[ByteString, UploadPartResponse, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // Multipart upload requests (except for the completion api) are created here.[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  The initial upload request gets executed within this function as well.[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  The individual upload part requests are created.[0m
[0m[[0m[0mdebug[0m] [0m[0m    val requestFlow = createRequests(s3Location, contentType, s3Headers, chunkSize, parallelism)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    // The individual upload part requests are processed here[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flow { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        requestFlow[0m
[0m[[0m[0mdebug[0m] [0m[0m          .via(superPool[(MultipartUpload, Int)])[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapAsync(parallelism) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (Success(r), (upload, index)) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              if (r.status.isFailure()) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                Unmarshal(r.entity).to[String].map { errorBody =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  FailedUploadPart([0m
[0m[[0m[0mdebug[0m] [0m[0m                    upload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    index,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    new RuntimeException([0m
[0m[[0m[0mdebug[0m] [0m[0m                      s"Upload part $index request failed. Response header: ($r), response body: ($errorBody)."[0m
[0m[[0m[0mdebug[0m] [0m[0m                    )[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                r.entity.dataBytes.runWith(Sink.ignore)[0m
[0m[[0m[0mdebug[0m] [0m[0m                val etag = r.headers.find(_.lowercaseName() == "etag").map(_.value)[0m
[0m[[0m[0mdebug[0m] [0m[0m                etag[0m
[0m[[0m[0mdebug[0m] [0m[0m                  .map(t => Future.successful(SuccessfulUploadPart(upload, index, t)))[0m
[0m[[0m[0mdebug[0m] [0m[0m                  .getOrElse([0m
[0m[[0m[0mdebug[0m] [0m[0m                    Future[0m
[0m[[0m[0mdebug[0m] [0m[0m                      .successful(FailedUploadPart(upload, index, new RuntimeException(s"Cannot find etag in ${r}")))[0m
[0m[[0m[0mdebug[0m] [0m[0m                  )[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (Failure(e), (upload, index)) => Future.successful(FailedUploadPart(upload, index, e))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def completionSink([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sse: Option[ServerSideEncryption][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[UploadPartResponse, Future[MultipartUploadResult]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .sink { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        import sys.dispatcher[0m
[0m[[0m[0mdebug[0m] [0m[0m        Sink[0m
[0m[[0m[0mdebug[0m] [0m[0m          .seq[UploadPartResponse][0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapMaterializedValue { responseFuture: Future[Seq[UploadPartResponse]] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            responseFuture[0m
[0m[[0m[0mdebug[0m] [0m[0m              .flatMap { responses: Seq[UploadPartResponse] =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val successes = responses.collect { case r: SuccessfulUploadPart => r }[0m
[0m[[0m[0mdebug[0m] [0m[0m                val failures = responses.collect { case r: FailedUploadPart => r }[0m
[0m[[0m[0mdebug[0m] [0m[0m                if (responses.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Future.failed(new RuntimeException("No Responses"))[0m
[0m[[0m[0mdebug[0m] [0m[0m                } else if (failures.isEmpty) {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Future.successful(successes.sortBy(_.index))[0m
[0m[[0m[0mdebug[0m] [0m[0m                } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m                  Future.failed(FailedUpload(failures.map(_.exception)))[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m              .flatMap(completeMultipartUpload(s3Location, _, sse))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapMaterializedValue(_.map(r => MultipartUploadResult(r.location, r.bucket, r.key, r.etag, r.versionId)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_.flatMap(identity)(ExecutionContexts.sameThreadExecutionContext))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def signAndGetAs[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      request: HttpRequest[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit um: Unmarshaller[ResponseEntity, T], mat: ActorMaterializer, attr: Attributes): Future[T] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m    for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      response <- signAndRequest(request).runWith(Sink.head)[0m
[0m[[0m[0mdebug[0m] [0m[0m      (entity, _) <- entityForSuccess(response)[0m
[0m[[0m[0mdebug[0m] [0m[0m      t <- Unmarshal(entity).to[T][0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield t[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def signAndGetAs[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      request: HttpRequest,[0m
[0m[[0m[0mdebug[0m] [0m[0m      f: (T, Seq[HttpHeader]) => T[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit um: Unmarshaller[ResponseEntity, T], mat: ActorMaterializer, attr: Attributes): Source[T, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m    signAndRequest(request)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapAsync(parallelism = 1)(entityForSuccess)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapAsync(parallelism = 1) {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case (entity, headers) => Unmarshal(entity).to[T].map((_, headers))[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(f.tupled)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def signAndRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m      request: HttpRequest,[0m
[0m[[0m[0mdebug[0m] [0m[0m      retries: Int = 3[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit sys: ActorSystem, attr: Attributes): Source[HttpResponse, NotUsed] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Signer[0m
[0m[[0m[0mdebug[0m] [0m[0m      .signedRequest(request, signingKey)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapAsync(parallelism = 1)(req => singleRequest(req))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case HttpResponse(status, _, _, _) if (retries > 0) && (500 to 599 contains status.intValue()) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          signAndRequest(request, retries - 1)[0m
[0m[[0m[0mdebug[0m] [0m[0m        case res => Source.single(res)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def entityForSuccess([0m
[0m[[0m[0mdebug[0m] [0m[0m      resp: HttpResponse[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit mat: Materializer): Future[(ResponseEntity, Seq[HttpHeader])] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m    resp match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case HttpResponse(status, headers, entity, _) if status.isSuccess() && !status.isRedirection() =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Future.successful((entity, headers))[0m
[0m[[0m[0mdebug[0m] [0m[0m      case HttpResponse(_, _, entity, _) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m          throw new S3Exception(err)[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[impl] def createPartitions(chunkSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                                     sourceLocation: S3Location)(objectSize: Long): List[CopyPartition] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    if (objectSize <= 0 || objectSize < chunkSize) CopyPartition(1, sourceLocation) :: Nil[0m
[0m[[0m[0mdebug[0m] [0m[0m    else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      ((0L until objectSize by chunkSize).toList :+ objectSize)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .sliding(2)[0m
[0m[[0m[0mdebug[0m] [0m[0m        .toList[0m
[0m[[0m[0mdebug[0m] [0m[0m        .zipWithIndex[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (ls, index) => CopyPartition(index + 1, sourceLocation, Some(ByteRange(ls.head, ls.last)))[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def createCopyRequests([0m
[0m[[0m[0mdebug[0m] [0m[0m      location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      sourceVersionId: Option[String],[0m
[0m[[0m[0mdebug[0m] [0m[0m      contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Headers: S3Headers,[0m
[0m[[0m[0mdebug[0m] [0m[0m      partitions: Source[List[CopyPartition], NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  )(parallelism: Int) = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val requestInfo: Source[(MultipartUpload, Int), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m      initiateUpload(location, contentType, s3Headers.headersFor(InitiateMultipartUpload))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val headers = s3Headers.serverSideEncryption.toIndexedSeq.flatMap(_.headersFor(CopyPart))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup[0m
[0m[[0m[0mdebug[0m] [0m[0m      .source { mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m        implicit val conf = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m        requestInfo[0m
[0m[[0m[0mdebug[0m] [0m[0m          .zipWith(partitions) {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case ((upload, _), ls) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              ls.map { cp =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                val multipartCopy = MultipartCopy(upload, cp)[0m
[0m[[0m[0mdebug[0m] [0m[0m                val request = uploadCopyPartRequest(multipartCopy, sourceVersionId, headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m                (request, multipartCopy)[0m
[0m[[0m[0mdebug[0m] [0m[0m              }[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m          .mapConcat(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m          .flatMapConcat {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case (req, info) => Signer.signedRequest(req, signingKey).zip(Source.single(info))[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .mapMaterializedValue(_ => NotUsed)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def processUploadCopyPartRequests([0m
[0m[[0m[0mdebug[0m] [0m[0m      requests: Source[(HttpRequest, MultipartCopy), NotUsed][0m
[0m[[0m[0mdebug[0m] [0m[0m  )(parallelism: Int) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Setup.source { implicit mat => implicit attr =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      import mat.executionContext[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit val sys = mat.system[0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit val settings = resolveSettings()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m      requests[0m
[0m[[0m[0mdebug[0m] [0m[0m        .via(superPool[MultipartCopy])[0m
[0m[[0m[0mdebug[0m] [0m[0m        .map {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (Success(r), multipartCopy) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            val entity = r.entity[0m
[0m[[0m[0mdebug[0m] [0m[0m            val upload = multipartCopy.multipartUpload[0m
[0m[[0m[0mdebug[0m] [0m[0m            val index = multipartCopy.copyPartition.partNumber[0m
[0m[[0m[0mdebug[0m] [0m[0m            import StatusCodes._[0m
[0m[[0m[0mdebug[0m] [0m[0m            r.status match {[0m
[0m[[0m[0mdebug[0m] [0m[0m              case OK =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Unmarshal(entity).to[CopyPartResult].map(cp => SuccessfulUploadPart(upload, index, cp.eTag))[0m
[0m[[0m[0mdebug[0m] [0m[0m              case statusCode: StatusCode =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                Unmarshal(entity).to[String].map { err =>[0m
[0m[[0m[0mdebug[0m] [0m[0m                  val response = Option(err).getOrElse(s"Failed to upload part into S3, status code was: $statusCode")[0m
[0m[[0m[0mdebug[0m] [0m[0m                  throw new S3Exception(response)[0m
[0m[[0m[0mdebug[0m] [0m[0m                }[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m          case (Failure(ex), multipartCopy) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            Future.successful([0m
[0m[[0m[0mdebug[0m] [0m[0m              FailedUploadPart(multipartCopy.multipartUpload, multipartCopy.copyPartition.partNumber, ex)[0m
[0m[[0m[0mdebug[0m] [0m[0m            )[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        .mapAsync(parallelism)(identity)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def resolveSettings()(implicit attr: Attributes, sys: ActorSystem) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    attr[0m
[0m[[0m[0mdebug[0m] [0m[0m      .get[S3SettingsValue][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.settings)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse {[0m
[0m[[0m[0mdebug[0m] [0m[0m        val configPath = attr.get[S3SettingsPath](S3SettingsPath.Default).path[0m
[0m[[0m[0mdebug[0m] [0m[0m        S3Ext(sys).settings(configPath)[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/impl/HttpRequests.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3.impl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.net.URLDecoder[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.nio.charset.StandardCharsets[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.marshallers.xml.ScalaXmlSupport._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.marshalling.Marshal[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.Uri.{Authority, Query}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers.{Host, RawHeader}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{ContentTypes, RequestEntity, _}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.s3.{ApiVersion, S3Settings}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.util.ByteString[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Seq[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.{ExecutionContext, Future}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Internal Api[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m@InternalApi private[impl] object HttpRequests {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def listBucket([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      prefix: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m      continuationToken: Option[String] = None[0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit conf: S3Settings): HttpRequest = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val (listType, continuationTokenName) = conf.listBucketApiVersion match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ApiVersion.ListBucketVersion1 => (None, "marker")[0m
[0m[[0m[0mdebug[0m] [0m[0m      case ApiVersion.ListBucketVersion2 => (Some("2"), "continuation-token")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val query = Query([0m
[0m[[0m[0mdebug[0m] [0m[0m      Seq([0m
[0m[[0m[0mdebug[0m] [0m[0m        "list-type" -> listType,[0m
[0m[[0m[0mdebug[0m] [0m[0m        "prefix" -> prefix,[0m
[0m[[0m[0mdebug[0m] [0m[0m        continuationTokenName -> continuationToken[0m
[0m[[0m[0mdebug[0m] [0m[0m      ).collect { case (k, Some(v)) => k -> v }.toMap[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    HttpRequest(HttpMethods.GET)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withHeaders(Host(requestAuthority(bucket, conf.s3RegionProvider.getRegion)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withUri(requestUri(bucket, None).withQuery(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getDownloadRequest(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         method: HttpMethod = HttpMethods.GET,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         s3Headers: Seq[HttpHeader] = Seq.empty,[0m
[0m[[0m[0mdebug[0m] [0m[0m                         versionId: Option[String] = None)(implicit conf: S3Settings): HttpRequest = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val query = versionId[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(vId => Query("versionId" -> URLDecoder.decode(vId, StandardCharsets.UTF_8.toString)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(Query())[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request(s3Location, method, _.withQuery(query))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withDefaultHeaders(s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def bucketManagementRequest([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      method: HttpMethod,[0m
[0m[[0m[0mdebug[0m] [0m[0m      headers: Seq[HttpHeader] = Seq.empty[HttpHeader][0m
[0m[[0m[0mdebug[0m] [0m[0m  )(implicit conf: S3Settings): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request(s3Location = s3Location, method = method)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withDefaultHeaders(headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def uploadRequest(s3Location: S3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    payload: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    contentLength: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    contentType: ContentType,[0m
[0m[[0m[0mdebug[0m] [0m[0m                    s3Headers: Seq[HttpHeader])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit conf: S3Settings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request([0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      HttpMethods.PUT[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).withDefaultHeaders(s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withEntity(HttpEntity(contentType, contentLength, payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def initiateMultipartUploadRequest(s3Location: S3Location, contentType: ContentType, s3Headers: Seq[HttpHeader])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit conf: S3Settings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request(s3Location, HttpMethods.POST, _.withQuery(Query("uploads")))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withDefaultHeaders(s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withEntity(HttpEntity.empty(contentType))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def uploadPartRequest(upload: MultipartUpload,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        partNumber: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        payload: Source[ByteString, _],[0m
[0m[[0m[0mdebug[0m] [0m[0m                        payloadSize: Int,[0m
[0m[[0m[0mdebug[0m] [0m[0m                        s3Headers: Seq[HttpHeader] = Seq.empty)(implicit conf: S3Settings): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request([0m
[0m[[0m[0mdebug[0m] [0m[0m      upload.s3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      HttpMethods.PUT,[0m
[0m[[0m[0mdebug[0m] [0m[0m      _.withQuery(Query("partNumber" -> partNumber.toString, "uploadId" -> upload.uploadId))[0m
[0m[[0m[0mdebug[0m] [0m[0m    ).withDefaultHeaders(s3Headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withEntity(HttpEntity(ContentTypes.`application/octet-stream`, payloadSize, payload))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def completeMultipartUploadRequest(upload: MultipartUpload, parts: Seq[(Int, String)], headers: Seq[HttpHeader])([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit ec: ExecutionContext,[0m
[0m[[0m[0mdebug[0m] [0m[0m      conf: S3Settings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Future[HttpRequest] = {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    //Do not let the start PartNumber,ETag and the end PartNumber,ETag be on different lines[0m
[0m[[0m[0mdebug[0m] [0m[0m    //  They tend to get split when this file is formatted by IntelliJ unless http://stackoverflow.com/a/19492318/1216965[0m
[0m[[0m[0mdebug[0m] [0m[0m    // @formatter:off[0m
[0m[[0m[0mdebug[0m] [0m[0m    val payload = <CompleteMultipartUpload>[0m
[0m[[0m[0mdebug[0m] [0m[0m                    {[0m
[0m[[0m[0mdebug[0m] [0m[0m                      parts.map { case (partNumber, etag) => <Part><PartNumber>{ partNumber }</PartNumber><ETag>{ etag }</ETag></Part> }[0m
[0m[[0m[0mdebug[0m] [0m[0m                    }[0m
[0m[[0m[0mdebug[0m] [0m[0m                  </CompleteMultipartUpload>[0m
[0m[[0m[0mdebug[0m] [0m[0m    // @formatter:on[0m
[0m[[0m[0mdebug[0m] [0m[0m    for {[0m
[0m[[0m[0mdebug[0m] [0m[0m      entity <- Marshal(payload).to[RequestEntity][0m
[0m[[0m[0mdebug[0m] [0m[0m    } yield {[0m
[0m[[0m[0mdebug[0m] [0m[0m      s3Request([0m
[0m[[0m[0mdebug[0m] [0m[0m        upload.s3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m        HttpMethods.POST,[0m
[0m[[0m[0mdebug[0m] [0m[0m        _.withQuery(Query("uploadId" -> upload.uploadId))[0m
[0m[[0m[0mdebug[0m] [0m[0m      ).withEntity(entity).withDefaultHeaders(headers)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def uploadCopyPartRequest(multipartCopy: MultipartCopy,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            sourceVersionId: Option[String] = None,[0m
[0m[[0m[0mdebug[0m] [0m[0m                            s3Headers: Seq[HttpHeader] = Seq.empty)(implicit conf: S3Settings): HttpRequest = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val upload = multipartCopy.multipartUpload[0m
[0m[[0m[0mdebug[0m] [0m[0m    val copyPartition = multipartCopy.copyPartition[0m
[0m[[0m[0mdebug[0m] [0m[0m    val range = copyPartition.range[0m
[0m[[0m[0mdebug[0m] [0m[0m    val source = copyPartition.sourceLocation[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sourceHeaderValuePrefix = s"/${source.bucket}/${source.key}"[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sourceHeaderValue = sourceVersionId[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(versionId => s"$sourceHeaderValuePrefix?versionId=$versionId")[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(sourceHeaderValuePrefix)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val sourceHeader = RawHeader("x-amz-copy-source", sourceHeaderValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m    val copyHeaders = range[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(br => Seq(sourceHeader, RawHeader("x-amz-copy-source-range", s"bytes=${br.first}-${br.last - 1}")))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(Seq(sourceHeader))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    val allHeaders = s3Headers ++ copyHeaders[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    s3Request(upload.s3Location,[0m
[0m[[0m[0mdebug[0m] [0m[0m              HttpMethods.PUT,[0m
[0m[[0m[0mdebug[0m] [0m[0m              _.withQuery(Query("partNumber" -> copyPartition.partNumber.toString, "uploadId" -> upload.uploadId)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withDefaultHeaders(allHeaders)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def s3Request(s3Location: S3Location, method: HttpMethod, uriFn: Uri => Uri = identity)([0m
[0m[[0m[0mdebug[0m] [0m[0m      implicit conf: S3Settings[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): HttpRequest =[0m
[0m[[0m[0mdebug[0m] [0m[0m    HttpRequest(method)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withHeaders(Host(requestAuthority(s3Location.bucket, conf.s3RegionProvider.getRegion)))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withUri(uriFn(requestUri(s3Location.bucket, Some(s3Location.key))))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  @throws(classOf[IllegalUriException])[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def requestAuthority(bucket: String, region: String)(implicit conf: S3Settings): Authority =[0m
[0m[[0m[0mdebug[0m] [0m[0m    conf.endpointUrl match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(endpointUrl) => Uri(endpointUrl).authority[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        if (!conf.pathStyleAccess) {[0m
[0m[[0m[0mdebug[0m] [0m[0m          val bucketRegex = "[^a-z0-9\\-\\.]{1,255}|[\\.]{2,}".r[0m
[0m[[0m[0mdebug[0m] [0m[0m          bucketRegex.findFirstIn(bucket) match {[0m
[0m[[0m[0mdebug[0m] [0m[0m            case Some(illegalCharacter) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m              throw IllegalUriException([0m
[0m[[0m[0mdebug[0m] [0m[0m                "Bucket name contains non-LDH characters",[0m
[0m[[0m[0mdebug[0m] [0m[0m                s"""The following character is not allowed: $illegalCharacter[0m
[0m[[0m[0mdebug[0m] [0m[0m                       | This may be solved by setting alpakka.s3.path-style-access to true in the configuration.[0m
[0m[[0m[0mdebug[0m] [0m[0m                 """.stripMargin[0m
[0m[[0m[0mdebug[0m] [0m[0m              )[0m
[0m[[0m[0mdebug[0m] [0m[0m            case None => ()[0m
[0m[[0m[0mdebug[0m] [0m[0m          }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m        region match {[0m
[0m[[0m[0mdebug[0m] [0m[0m          case "us-east-1" =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (conf.pathStyleAccess) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Authority(Uri.Host("s3.amazonaws.com"))[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Authority(Uri.Host(s"$bucket.s3.amazonaws.com"))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m          case _ =>[0m
[0m[[0m[0mdebug[0m] [0m[0m            if (conf.pathStyleAccess) {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Authority(Uri.Host(s"s3-$region.amazonaws.com"))[0m
[0m[[0m[0mdebug[0m] [0m[0m            } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m              Authority(Uri.Host(s"$bucket.s3-$region.amazonaws.com"))[0m
[0m[[0m[0mdebug[0m] [0m[0m            }[0m
[0m[[0m[0mdebug[0m] [0m[0m        }[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private[this] def requestUri(bucket: String, key: Option[String])(implicit conf: S3Settings): Uri = {[0m
[0m[[0m[0mdebug[0m] [0m[0m    val basePath = if (conf.pathStyleAccess) {[0m
[0m[[0m[0mdebug[0m] [0m[0m      Uri.Path / bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m    } else {[0m
[0m[[0m[0mdebug[0m] [0m[0m      Uri.Path.Empty[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    val path = key.fold(basePath) { someKey =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      someKey.split("/").foldLeft(basePath)((acc, p) => acc / p)[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m    val uri = Uri(path = path, authority = requestAuthority(bucket, conf.s3RegionProvider.getRegion))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .withHost(requestAuthority(bucket, conf.s3RegionProvider.getRegion).host)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m    conf.endpointUrl match {[0m
[0m[[0m[0mdebug[0m] [0m[0m      case Some(endpointUri) =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        uri.withScheme(Uri(endpointUri).scheme)[0m
[0m[[0m[0mdebug[0m] [0m[0m      case None =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        uri.withScheme("https")[0m
[0m[[0m[0mdebug[0m] [0m[0m    }[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/s3/src/main/scala/akka/stream/alpakka/s3/model.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.s3[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.{Objects, Optional}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.{DateTime, HttpHeader, Uri}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.http.scaladsl.model.headers._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable.Seq[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.immutable[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.compat.java8.OptionConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class MultipartUploadResult private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val location: Uri,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val etag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val versionId: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getLocation: akka.http.javadsl.model.Uri = akka.http.javadsl.model.Uri.create(location)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getBucket: String = bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getKey: String = key[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getEtag: String = etag[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getVersionId: java.util.Optional[String] = versionId.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withLocation(value: Uri): MultipartUploadResult = copy(location = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBucket(value: String): MultipartUploadResult = copy(bucket = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKey(value: String): MultipartUploadResult = copy(key = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withEtag(value: String): MultipartUploadResult = copy(etag = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withVersionId(value: String): MultipartUploadResult = copy(versionId = Option(value))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      location: Uri = location,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String = bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m      etag: String = etag,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Option[String] = versionId[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MultipartUploadResult = new MultipartUploadResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    location = location,[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucket = bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    etag = etag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    versionId = versionId[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "MultipartUploadResult(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"location=$location," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"bucket=$bucket," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"key=$key," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"etag=$etag," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"versionId=$versionId" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: MultipartUploadResult =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.location, that.location) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.bucket, that.bucket) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.key, that.key) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.etag, that.etag) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.versionId, that.versionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(location, bucket, key, etag, versionId)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MultipartUploadResult {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      location: Uri,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      etag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: Option[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MultipartUploadResult = new MultipartUploadResult([0m
[0m[[0m[0mdebug[0m] [0m[0m    location,[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    etag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    versionId[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      location: akka.http.javadsl.model.Uri,[0m
[0m[[0m[0mdebug[0m] [0m[0m      bucket: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      etag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      versionId: java.util.Optional[String][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): MultipartUploadResult = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    location.asScala(),[0m
[0m[[0m[0mdebug[0m] [0m[0m    bucket,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    etag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    versionId.asScala[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param bucketName The name of the bucket in which this object is stored[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param key The key under which this object is stored[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param eTag Hex encoded MD5 hash of this object's contents, as computed by Amazon S3[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param size The size of this object, in bytes[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param lastModified The date, according to Amazon S3, when this object was last modified[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param storageClass The class of storage used by Amazon S3 to store this object[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ListBucketResultContents private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val eTag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val size: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val lastModified: java.time.Instant,[0m
[0m[[0m[0mdebug[0m] [0m[0m    val storageClass: String[0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getBucketName: String = bucketName[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getKey: String = key[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getETag: String = eTag[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getSize: Long = size[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getLastModified: java.time.Instant = lastModified[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getStorageClass: String = storageClass[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withBucketName(value: String): ListBucketResultContents = copy(bucketName = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withKey(value: String): ListBucketResultContents = copy(key = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withETag(value: String): ListBucketResultContents = copy(eTag = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withSize(value: Long): ListBucketResultContents = copy(size = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withLastModified(value: java.time.Instant): ListBucketResultContents = copy(lastModified = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withStorageClass(value: String): ListBucketResultContents = copy(storageClass = value)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucketName: String = bucketName,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m      eTag: String = eTag,[0m
[0m[[0m[0mdebug[0m] [0m[0m      size: Long = size,[0m
[0m[[0m[0mdebug[0m] [0m[0m      lastModified: java.time.Instant = lastModified,[0m
[0m[[0m[0mdebug[0m] [0m[0m      storageClass: String = storageClass[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ListBucketResultContents = new ListBucketResultContents([0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketName = bucketName,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key = key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    eTag = eTag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    size = size,[0m
[0m[[0m[0mdebug[0m] [0m[0m    lastModified = lastModified,[0m
[0m[[0m[0mdebug[0m] [0m[0m    storageClass = storageClass[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "ListBucketResultContents(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"bucketName=$bucketName," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"key=$key," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"eTag=$eTag," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"size=$size," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"lastModified=$lastModified," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"storageClass=$storageClass" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def equals(other: Any): Boolean = other match {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case that: ListBucketResultContents =>[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.bucketName, that.bucketName) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.key, that.key) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.eTag, that.eTag) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.size, that.size) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.lastModified, that.lastModified) &&[0m
[0m[[0m[0mdebug[0m] [0m[0m      Objects.equals(this.storageClass, that.storageClass)[0m
[0m[[0m[0mdebug[0m] [0m[0m    case _ => false[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def hashCode(): Int =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Objects.hash(bucketName, key, eTag, Long.box(size), lastModified, storageClass)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ListBucketResultContents {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Scala API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      eTag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      size: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m      lastModified: java.time.Instant,[0m
[0m[[0m[0mdebug[0m] [0m[0m      storageClass: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ListBucketResultContents = new ListBucketResultContents([0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketName,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    eTag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    size,[0m
[0m[[0m[0mdebug[0m] [0m[0m    lastModified,[0m
[0m[[0m[0mdebug[0m] [0m[0m    storageClass[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Java API */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create([0m
[0m[[0m[0mdebug[0m] [0m[0m      bucketName: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      key: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      eTag: String,[0m
[0m[[0m[0mdebug[0m] [0m[0m      size: Long,[0m
[0m[[0m[0mdebug[0m] [0m[0m      lastModified: java.time.Instant,[0m
[0m[[0m[0mdebug[0m] [0m[0m      storageClass: String[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): ListBucketResultContents = apply([0m
[0m[[0m[0mdebug[0m] [0m[0m    bucketName,[0m
[0m[[0m[0mdebug[0m] [0m[0m    key,[0m
[0m[[0m[0mdebug[0m] [0m[0m    eTag,[0m
[0m[[0m[0mdebug[0m] [0m[0m    size,[0m
[0m[[0m[0mdebug[0m] [0m[0m    lastModified,[0m
[0m[[0m[0mdebug[0m] [0m[0m    storageClass[0m
[0m[[0m[0mdebug[0m] [0m[0m  )[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * Modelled after com.amazonaws.services.s3.model.ObjectMetadata[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param metadata the raw http headers[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class ObjectMetadata private ([0m
[0m[[0m[0mdebug[0m] [0m[0m    val metadata: Seq[HttpHeader][0m
[0m[[0m[0mdebug[0m] [0m[0m) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val headers: java.util.List[akka.http.javadsl.model.HttpHeader] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    (metadata: immutable.Seq[akka.http.javadsl.model.HttpHeader]).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the hex encoded 128-bit MD5 digest of the associated object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to RFC 1864. This data is used as an integrity check to verify[0m
[0m[[0m[0mdebug[0m] [0m[0m   * that the data received by the caller is the same data that was sent by[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This field represents the hex encoded 128-bit MD5 digest of an object's[0m
[0m[[0m[0mdebug[0m] [0m[0m   * content as calculated by Amazon S3. The ContentMD5 field represents the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * base64 encoded 128-bit MD5 digest as calculated on the caller's side.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The hex encoded MD5 hash of the content for the associated object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         as calculated by Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val eTag: Option[String] = metadata.collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case e: ETag => e.etag.value.drop(1).dropRight(1)[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the hex encoded 128-bit MD5 digest of the associated object[0m
[0m[[0m[0mdebug[0m] [0m[0m   * according to RFC 1864. This data is used as an integrity check to verify[0m
[0m[[0m[0mdebug[0m] [0m[0m   * that the data received by the caller is the same data that was sent by[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This field represents the hex encoded 128-bit MD5 digest of an object's[0m
[0m[[0m[0mdebug[0m] [0m[0m   * content as calculated by Amazon S3. The ContentMD5 field represents the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * base64 encoded 128-bit MD5 digest as calculated on the caller's side.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The hex encoded MD5 hash of the content for the associated object[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         as calculated by Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val getETag: Optional[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    eTag.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the Content-Length HTTP header indicating the size of the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * associated object in bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This field is required when uploading objects to S3, but the AWS S3 Java[0m
[0m[[0m[0mdebug[0m] [0m[0m   * client will automatically set it when working directly with files. When[0m
[0m[[0m[0mdebug[0m] [0m[0m   * uploading directly from a stream, set this field if[0m
[0m[[0m[0mdebug[0m] [0m[0m   * possible. Otherwise the client must buffer the entire stream in[0m
[0m[[0m[0mdebug[0m] [0m[0m   * order to calculate the content length before sending the data to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For more information on the Content-Length HTTP header, see [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The Content-Length HTTP header indicating the size of the[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         associated object in bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see ObjectMetadata#setContentLength(long)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val contentLength: Long =[0m
[0m[[0m[0mdebug[0m] [0m[0m    metadata[0m
[0m[[0m[0mdebug[0m] [0m[0m      .collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m        case cl: `Content-Length` => cl.length[0m
[0m[[0m[0mdebug[0m] [0m[0m      }[0m
[0m[[0m[0mdebug[0m] [0m[0m      .getOrElse(0)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the Content-Length HTTP header indicating the size of the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * associated object in bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * This field is required when uploading objects to S3, but the AWS S3 Java[0m
[0m[[0m[0mdebug[0m] [0m[0m   * client will automatically set it when working directly with files. When[0m
[0m[[0m[0mdebug[0m] [0m[0m   * uploading directly from a stream, set this field if[0m
[0m[[0m[0mdebug[0m] [0m[0m   * possible. Otherwise the client must buffer the entire stream in[0m
[0m[[0m[0mdebug[0m] [0m[0m   * order to calculate the content length before sending the data to[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Amazon S3.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For more information on the Content-Length HTTP header, see[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The Content-Length HTTP header indicating the size of the[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         associated object in bytes.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see ObjectMetadata#setContentLength(long)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getContentLength: Long =[0m
[0m[[0m[0mdebug[0m] [0m[0m    contentLength[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the Content-Type HTTP header, which indicates the type of content[0m
[0m[[0m[0mdebug[0m] [0m[0m   * stored in the associated object. The value of this header is a standard[0m
[0m[[0m[0mdebug[0m] [0m[0m   * MIME type.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * When uploading files, the AWS S3 Java client will attempt to determine[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the correct content type if one hasn't been set yet. Users are[0m
[0m[[0m[0mdebug[0m] [0m[0m   * responsible for ensuring a suitable content type is set when uploading[0m
[0m[[0m[0mdebug[0m] [0m[0m   * streams. If no content type is provided and cannot be determined by[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the filename, the default content type, "application/octet-stream", will[0m
[0m[[0m[0mdebug[0m] [0m[0m   * be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For more information on the Content-Type header, see[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The HTTP Content-Type header, indicating the type of content[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         stored in the associated S3 object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see ObjectMetadata#setContentType(String)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val contentType: Option[String] = metadata.collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case ct: `Content-Type` => ct.value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the Content-Type HTTP header, which indicates the type of content[0m
[0m[[0m[0mdebug[0m] [0m[0m   * stored in the associated object. The value of this header is a standard[0m
[0m[[0m[0mdebug[0m] [0m[0m   * MIME type.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * When uploading files, the AWS S3 Java client will attempt to determine[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the correct content type if one hasn't been set yet. Users are[0m
[0m[[0m[0mdebug[0m] [0m[0m   * responsible for ensuring a suitable content type is set when uploading[0m
[0m[[0m[0mdebug[0m] [0m[0m   * streams. If no content type is provided and cannot be determined by[0m
[0m[[0m[0mdebug[0m] [0m[0m   * the filename, the default content type, "application/octet-stream", will[0m
[0m[[0m[0mdebug[0m] [0m[0m   * be used.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * <p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   * For more information on the Content-Type header, see[0m
[0m[[0m[0mdebug[0m] [0m[0m   * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17]][0m
[0m[[0m[0mdebug[0m] [0m[0m   * </p>[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The HTTP Content-Type header, indicating the type of content[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         stored in the associated S3 object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @see ObjectMetadata#setContentType(String)[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getContentType: Optional[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    contentType.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the value of the Last-Modified header, indicating the date[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and time at which Amazon S3 last recorded a modification to the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * associated object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The date and time at which Amazon S3 last recorded a modification[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         to the associated object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val lastModified: DateTime = metadata.collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case ct: `Last-Modified` => ct.date[0m
[0m[[0m[0mdebug[0m] [0m[0m  }.get[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the value of the Last-Modified header, indicating the date[0m
[0m[[0m[0mdebug[0m] [0m[0m   * and time at which Amazon S3 last recorded a modification to the[0m
[0m[[0m[0mdebug[0m] [0m[0m   * associated object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return The date and time at which Amazon S3 last recorded a modification[0m
[0m[[0m[0mdebug[0m] [0m[0m   *         to the associated object.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getLastModified: DateTime =[0m
[0m[[0m[0mdebug[0m] [0m[0m    lastModified[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the optional Cache-Control header[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val cacheControl: Option[String] = metadata.collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case c: `Cache-Control` => c.value[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the optional Cache-Control header[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getCacheControl: Optional[String] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    cacheControl.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the value of the version id header. The version id will only be available[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if the versioning is enabled in the bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  lazy val versionId: Option[String] = metadata.collectFirst {[0m
[0m[[0m[0mdebug[0m] [0m[0m    case v if v.lowercaseName() == "x-amz-version-id" => v.value()[0m
[0m[[0m[0mdebug[0m] [0m[0m  }[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Gets the value of the version id header. The version id will only be available[0m
[0m[[0m[0mdebug[0m] [0m[0m   * if the versioning is enabled in the bucket[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @return optional version id of the object[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def getVersionId: Optional[String] = versionId.asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mobject ObjectMetadata {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(metadata: Seq[HttpHeader]) = new ObjectMetadata(metadata)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m * While checking for bucket access those responses are available[0m
[0m[[0m[0mdebug[0m] [0m[0m * 1) AccessDenied - User does have permission to perform ListBucket operation, so bucket exits[0m
[0m[[0m[0mdebug[0m] [0m[0m * 2) AccessGranted - User doesn't have rights to perform ListBucket but bucket exits[0m
[0m[[0m[0mdebug[0m] [0m[0m * 3) NotExists - Bucket doesn't exit[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @see https://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketHEAD.html[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0msealed class BucketAccess[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject BucketAccess {[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object AccessDenied extends BucketAccess[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object AccessGranted extends BucketAccess[0m
[0m[[0m[0mdebug[0m] [0m[0m  case object NotExists extends BucketAccess[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  val accessDenied: BucketAccess = AccessDenied[0m
[0m[[0m[0mdebug[0m] [0m[0m  val accessGranted: BucketAccess = AccessGranted[0m
[0m[[0m[0mdebug[0m] [0m[0m  val notExists: BucketAccess = NotExists[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
