[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/javadsl/MongoFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.DocumentUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.scaladsl.MongoFlow.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultDeleteOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertManyOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertOneOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Flow[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.model.{DeleteOptions, InsertManyOptions, InsertOneOptions, UpdateOptions}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.result.{DeleteResult, UpdateResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.reactivestreams.client.MongoCollection[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.bson.conversions.Bson[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T]): Flow[T, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    insertOne(collection, DefaultInsertOneOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T], options: InsertOneOptions): Flow[T, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MongoFlow.insertOne(collection, options).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will insert batches of documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T]): Flow[java.util.List[T], java.util.List[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    insertMany(collection, DefaultInsertManyOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will insert batches of documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: InsertManyOptions): Flow[java.util.List[T], java.util.List[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    akka.stream.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m      .Flow[java.util.List[T]][0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asScala)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .via(scaladsl.MongoFlow.insertMany(collection, options))[0m
[0m[[0m[0mdebug[0m] [0m[0m      .map(_.asJava)[0m
[0m[[0m[0mdebug[0m] [0m[0m      .asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will update documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, akka.japi.Pair[UpdateResult, DocumentUpdate], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateOne(collection, DefaultUpdateOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will update documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m      options: UpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, akka.japi.Pair[UpdateResult, DocumentUpdate], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MongoFlow.updateOne(collection, options).map(fromTupleToPair).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T][0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, akka.japi.Pair[UpdateResult, DocumentUpdate], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateMany(collection, DefaultUpdateOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m      options: UpdateOptions = DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, akka.japi.Pair[UpdateResult, DocumentUpdate], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MongoFlow.updateMany(collection, options).map(fromTupleToPair).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T]): Flow[Bson, akka.japi.Pair[DeleteResult, Bson], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteOne(collection, DefaultDeleteOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: DeleteOptions): Flow[Bson, akka.japi.Pair[DeleteResult, Bson], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MongoFlow.deleteOne(collection, options).map(fromTupleToPair).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T]): Flow[Bson, akka.japi.Pair[DeleteResult, Bson], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteMany(collection, DefaultDeleteOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Flow Flow]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: DeleteOptions): Flow[Bson, akka.japi.Pair[DeleteResult, Bson], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    scaladsl.MongoFlow.deleteMany(collection, options).map(fromTupleToPair).asJava[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def fromTupleToPair[T, R] = (akka.japi.Pair.create[T, R] _).tupled[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/javadsl/MongoSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.reactivestreams.Publisher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create[T](query: Publisher[T]): Source[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromPublisher(query)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/javadsl/MongoSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.javadsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport java.util.concurrent.CompletionStage[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.{Done, NotUsed}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.DocumentUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.scaladsl.MongoFlow.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultDeleteOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertManyOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertOneOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.javadsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.model.{DeleteOptions, InsertManyOptions, InsertOneOptions, UpdateOptions}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.reactivestreams.client.MongoCollection[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.bson.conversions.Bson[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T]): Sink[T, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    insertOne(collection, DefaultInsertOneOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T], options: InsertOneOptions): Sink[T, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.insertOne(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will insert batches of documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T]): Sink[java.util.List[T], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    insertMany(collection, DefaultInsertManyOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will insert batches of documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: InsertManyOptions): Sink[java.util.List[T], CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.insertMany(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will update documents as defined by a [[akka.stream.alpakka.mongodb.DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T](collection: MongoCollection[T]): Sink[DocumentUpdate, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateOne(collection, DefaultUpdateOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will update documents as defined by a [[akka.stream.alpakka.mongodb.DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: UpdateOptions): Sink[DocumentUpdate, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.updateOne(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T](collection: MongoCollection[T]): Sink[DocumentUpdate, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    updateMany(collection, DefaultUpdateOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: UpdateOptions): Sink[DocumentUpdate, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.updateMany(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T]): Sink[Bson, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteOne(collection, DefaultDeleteOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T], options: DeleteOptions): Sink[Bson, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.deleteOne(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T]): Sink[Bson, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    deleteMany(collection, DefaultDeleteOptions)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.javadsl.Sink Sink]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T], options: DeleteOptions): Sink[Bson, CompletionStage[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.deleteMany(collection, options).toMat(Sink.ignore(), Keep.right[NotUsed, CompletionStage[Done]])[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/scaladsl/MongoFlow.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Flow, Source}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.annotation.InternalApi[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.DocumentUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.model.{DeleteOptions, InsertManyOptions, InsertOneOptions, UpdateOptions}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.result.{DeleteResult, UpdateResult}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.reactivestreams.client.MongoCollection[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.bson.conversions.Bson[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.collection.JavaConverters._[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoFlow {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[mongodb] val DefaultInsertOneOptions = new InsertOneOptions()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[mongodb] val DefaultInsertManyOptions = new InsertManyOptions()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[mongodb] val DefaultUpdateOptions = new UpdateOptions()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /** Internal Api */[0m
[0m[[0m[0mdebug[0m] [0m[0m  @InternalApi private[mongodb] val DefaultDeleteOptions = new DeleteOptions()[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: InsertOneOptions = DefaultInsertOneOptions): Flow[T, T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[T][0m
[0m[[0m[0mdebug[0m] [0m[0m      .flatMapConcat(doc => Source.fromPublisher(collection.insertOne(doc, options)).map(_ => doc))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will insert batches documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: InsertManyOptions = DefaultInsertManyOptions): Flow[Seq[T], Seq[T], NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[Seq[T]].flatMapConcat(docs => Source.fromPublisher(collection.insertMany(docs.asJava, options)).map(_ => docs))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will update documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m      options: UpdateOptions = DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, (UpdateResult, DocumentUpdate), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[DocumentUpdate].flatMapConcat([0m
[0m[[0m[0mdebug[0m] [0m[0m      documentUpdate =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Source[0m
[0m[[0m[0mdebug[0m] [0m[0m          .fromPublisher(collection.updateOne(documentUpdate.filter, documentUpdate.update, options))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .map(_ -> documentUpdate)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m      options: UpdateOptions = DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Flow[DocumentUpdate, (UpdateResult, DocumentUpdate), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[DocumentUpdate].flatMapConcat([0m
[0m[[0m[0mdebug[0m] [0m[0m      documentUpdate =>[0m
[0m[[0m[0mdebug[0m] [0m[0m        Source[0m
[0m[[0m[0mdebug[0m] [0m[0m          .fromPublisher(collection.updateMany(documentUpdate.filter, documentUpdate.update, options))[0m
[0m[[0m[0mdebug[0m] [0m[0m          .map(_ -> documentUpdate)[0m
[0m[[0m[0mdebug[0m] [0m[0m    )[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: DeleteOptions = DefaultDeleteOptions): Flow[Bson, (DeleteResult, Bson), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[Bson].flatMapConcat(bson => Source.fromPublisher(collection.deleteOne(bson, options)).map(_ -> bson))[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Flow Flow]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: DeleteOptions = DefaultDeleteOptions): Flow[Bson, (DeleteResult, Bson), NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Flow[Bson].flatMapConcat(bson => Source.fromPublisher(collection.deleteMany(bson, options)).map(_ -> bson))[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/scaladsl/MongoSource.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.NotUsed[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.Source[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.reactivestreams.Publisher[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoSource {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply[T](query: Publisher[T]): Source[T, NotUsed] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    Source.fromPublisher(query)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/scaladsl/MongoSink.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb.scaladsl[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.scaladsl.{Keep, Sink}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.Done[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.DocumentUpdate[0m
[0m[[0m[0mdebug[0m] [0m[0mimport akka.stream.alpakka.mongodb.scaladsl.MongoFlow.{[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultDeleteOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertManyOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultInsertOneOptions,[0m
[0m[[0m[0mdebug[0m] [0m[0m  DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.client.model.{DeleteOptions, InsertManyOptions, InsertOneOptions, UpdateOptions}[0m
[0m[[0m[0mdebug[0m] [0m[0mimport com.mongodb.reactivestreams.client.MongoCollection[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.bson.conversions.Bson[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mimport scala.concurrent.Future[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject MongoSink {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will insert documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: InsertOneOptions = DefaultInsertOneOptions): Sink[T, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.insertOne(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will insert batches of documents into a collection.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection mongo db collection to insert to.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def insertMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: InsertManyOptions = DefaultInsertManyOptions): Sink[Seq[T], Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.insertMany(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will update documents as defined by a [[akka.stream.alpakka.mongodb.DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: UpdateOptions = DefaultUpdateOptions): Sink[DocumentUpdate, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.updateOne(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will update many documents as defined by a [[DocumentUpdate]].[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def updateMany[T]([0m
[0m[[0m[0mdebug[0m] [0m[0m      collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m      options: UpdateOptions = DefaultUpdateOptions[0m
[0m[[0m[0mdebug[0m] [0m[0m  ): Sink[DocumentUpdate, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.updateMany(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will delete individual documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteOne[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                   options: DeleteOptions = DefaultDeleteOptions): Sink[Bson, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.deleteOne(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * A [[akka.stream.scaladsl.Sink Sink]] that will delete many documents as defined by a [[org.bson.conversions.Bson Bson]] filter query.[0m
[0m[[0m[0mdebug[0m] [0m[0m   *[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param collection the mongo db collection to update.[0m
[0m[[0m[0mdebug[0m] [0m[0m   * @param options options to apply to the operation[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def deleteMany[T](collection: MongoCollection[T],[0m
[0m[[0m[0mdebug[0m] [0m[0m                    options: DeleteOptions = DefaultDeleteOptions): Sink[Bson, Future[Done]] =[0m
[0m[[0m[0mdebug[0m] [0m[0m    MongoFlow.deleteMany(collection, options).toMat(Sink.ignore)(Keep.right)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to create/update header for /root/alpakka/mongodb/src/main/scala/akka/stream/alpakka/mongodb/DocumentUpdate.scala[0m
[0m[[0m[0mdebug[0m] [0m[0mFirst line of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mText of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0m/*[0m
[0m[[0m[0mdebug[0m] [0m[0m * Copyright (C) 2016-2019 Lightbend Inc. <http://www.lightbend.com>[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mpackage akka.stream.alpakka.mongodb[0m
[0m[[0m[0mdebug[0m] [0m[0mimport org.bson.conversions.Bson[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m/**[0m
[0m[[0m[0mdebug[0m] [0m[0m *[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param filter a document describing the query filter, which may not be null. This can be of any type for which a { @code Codec} is[0m
[0m[[0m[0mdebug[0m] [0m[0m *               registered[0m
[0m[[0m[0mdebug[0m] [0m[0m * @param update a document describing the update, which may not be null. The update to apply must include only update operators. This[0m
[0m[[0m[0mdebug[0m] [0m[0m *               can be of any type for which a { @code Codec} is registered[0m
[0m[[0m[0mdebug[0m] [0m[0m */[0m
[0m[[0m[0mdebug[0m] [0m[0mfinal class DocumentUpdate private (val filter: Bson, val update: Bson) {[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withFilter(filter: Bson): DocumentUpdate = copy(filter = filter)[0m
[0m[[0m[0mdebug[0m] [0m[0m  def withUpdate(update: Bson): DocumentUpdate = copy(update = update)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  override def toString: String =[0m
[0m[[0m[0mdebug[0m] [0m[0m    "DocumentUpdate(" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"filter=$filter," +[0m
[0m[[0m[0mdebug[0m] [0m[0m    s"update=$update" +[0m
[0m[[0m[0mdebug[0m] [0m[0m    ")"[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  private def copy(filter: Bson = filter, update: Bson = update) =[0m
[0m[[0m[0mdebug[0m] [0m[0m    new DocumentUpdate(filter, update)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mobject DocumentUpdate {[0m
[0m[[0m[0mdebug[0m] [0m[0m  def apply(filter: Bson, update: Bson) = new DocumentUpdate(filter, update)[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0m  /**[0m
[0m[[0m[0mdebug[0m] [0m[0m   * Java Api[0m
[0m[[0m[0mdebug[0m] [0m[0m   */[0m
[0m[[0m[0mdebug[0m] [0m[0m  def create(filter: Bson, update: Bson) = DocumentUpdate(filter, update)[0m
[0m[[0m[0mdebug[0m] [0m[0m}[0m
[0m[[0m[0mdebug[0m] [0m[0mModified text of file is:[0m
[0m[[0m[0mdebug[0m] [0m[0mNone[0m
